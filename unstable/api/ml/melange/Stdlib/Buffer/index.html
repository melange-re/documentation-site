<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buffer (melange.Stdlib.Buffer)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="canonical" href="https://melange.re/v1.0.0/api/ml/Stdlib/Buffer/index.html" /></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">melange</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Buffer</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Buffer</span></code></h1><p>Extensible buffers.</p><p>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in linear time (instead of quadratic time when strings are concatenated pairwise). For example:</p><pre class="language-ocaml"><code>let concat_strings ss =
  let b = Buffer.create 16 in
    List.iter (Buffer.add_string b) ss;
    Buffer.contents b</code></pre></header><nav class="odoc-toc"><ul><li><a href="#appending">Appending</a></li><li><a href="#buffers-and-sequences">Buffers and Sequences</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The abstract type of buffers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create n</code> returns a fresh buffer, initially empty. The <code>n</code> parameter is the initial size of the internal byte sequence that holds the buffer contents. That byte sequence is automatically reallocated when more than <code>n</code> characters are stored in the buffer, but shrinks back to <code>n</code> characters when <code>reset</code> is called. For best performance, <code>n</code> should be of the same order of magnitude as the number of characters that are expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line). Nothing bad will happen if the buffer grows beyond that limit, however. In doubt, take <code>n = 16</code> for instance. If <code>n</code> is not between 1 and <a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a>, it will be clipped to that interval.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-contents"><a href="#val-contents" class="anchor"></a><code><span><span class="keyword">val</span> contents : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>Buffer.sub b off len</code> returns a copy of <code>len</code> bytes from the current contents of the buffer <code>b</code>, starting at offset <code>off</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>off</code> and <code>len</code> do not designate a valid range of <code>b</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Buffer.blit src srcoff dst dstoff len</code> copies <code>len</code> characters from the current contents of the buffer <code>src</code>, starting at offset <code>srcoff</code> to <code>dst</code>, starting at character <code>dstoff</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11.2</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> char</span></code></div><div class="spec-doc"><p>Get the n-th character of the buffer.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if index out of bounds</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of characters currently contained in the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length <code>n</code> that was allocated by <a href="#val-create"><code>Buffer.create</code></a> <code>n</code>. For long-lived buffers that may have grown a lot, <code>reset</code> allows faster reclamation of the space used by the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_buffer"><a href="#val-output_buffer" class="anchor"></a><code><span><span class="keyword">val</span> output_buffer : <span><a href="../index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output_buffer oc b</code> writes the current contents of buffer <code>b</code> on the output channel <code>oc</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-truncate"><a href="#val-truncate" class="anchor"></a><code><span><span class="keyword">val</span> truncate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>truncate b len</code> truncates the length of <code>b</code> to <code>len</code> Note: the internal byte sequence is not shortened.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len &lt; 0</code> or <code>len &gt; length b</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.05.0</li></ul></div></div><h2 id="appending"><a href="#appending" class="anchor"></a>Appending</h2><p>Note: all <code>add_*</code> operations can raise <code>Failure</code> if the internal byte sequence of the buffer would need to grow beyond <a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-add_char"><a href="#val-add_char" class="anchor"></a><code><span><span class="keyword">val</span> add_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_char b c</code> appends the character <code>c</code> at the end of buffer <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_string"><a href="#val-add_string" class="anchor"></a><code><span><span class="keyword">val</span> add_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_string b s</code> appends the string <code>s</code> at the end of buffer <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_bytes"><a href="#val-add_bytes" class="anchor"></a><code><span><span class="keyword">val</span> add_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_bytes b s</code> appends the byte sequence <code>s</code> at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_substring"><a href="#val-add_substring" class="anchor"></a><code><span><span class="keyword">val</span> add_substring : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_substring b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in string <code>s</code> and appends them at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>ofs</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_subbytes"><a href="#val-add_subbytes" class="anchor"></a><code><span><span class="keyword">val</span> add_subbytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_subbytes b s ofs len</code> takes <code>len</code> characters from offset <code>ofs</code> in byte sequence <code>s</code> and appends them at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>ofs</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_substitute"><a href="#val-add_substitute" class="anchor"></a><code><span><span class="keyword">val</span> add_substitute : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_substitute b f s</code> appends the string pattern <code>s</code> at the end of buffer <code>b</code> with substitution. The substitution process looks for variables into the pattern and substitutes each variable name by its value, as obtained by applying the mapping <code>f</code> to the variable name. Inside the string pattern, a variable name immediately follows a non-escaped <code>$</code> character and is one of the following:</p><ul><li>a non empty sequence of alphanumeric or <code>_</code> characters,</li><li>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped <code>$</code> character is a <code>$</code> that immediately follows a backslash character; it then stands for a plain <code>$</code>.</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the closing character of a parenthesized variable cannot be found.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_buffer"><a href="#val-add_buffer" class="anchor"></a><code><span><span class="keyword">val</span> add_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_buffer b1 b2</code> appends the current contents of buffer <code>b2</code> at the end of buffer <code>b1</code>. <code>b2</code> is not modified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_channel"><a href="#val-add_channel" class="anchor"></a><code><span><span class="keyword">val</span> add_channel : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_channel b ic n</code> reads at most <code>n</code> characters from the input channel <code>ic</code> and stores them at the end of buffer <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>if the channel contains fewer than <code>n</code> characters. In this case, the characters are still added to the buffer, so as to avoid loss of data.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>len &lt; 0</code> or <code>len &gt; Sys.max_string_length</code>.</p></li></ul></div></div><h2 id="buffers-and-sequences"><a href="#buffers-and-sequences" class="anchor"></a>Buffers and Sequences</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the buffer, in increasing order.</p><p>The behavior is not specified if the buffer is modified during iteration.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seqi"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * char)</span> <a href="../Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the buffer, in increasing order, yielding indices along chars.</p><p>The behavior is not specified if the buffer is modified during iteration.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>char <a href="../Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add chars to the buffer</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span>char <a href="../Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a buffer from the generator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div></div></body></html>
