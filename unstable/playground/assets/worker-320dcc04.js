(function(){"use strict";var ec=`// Generated by Melange


function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_bool_compare(x, y) {
  if (x) {
    if (y) {
      return 0;
    } else {
      return 1;
    }
  } else if (y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_float_compare(x, y) {
  if (x === y) {
    return 0;
  } else if (x < y) {
    return -1;
  } else if (x > y || x === x) {
    return 1;
  } else if (y === y) {
    return -1;
  } else {
    return 0;
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_bool_min(x, y) {
  if (x) {
    return y;
  } else {
    return x;
  }
}

function caml_int_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function caml_bool_max(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function caml_int_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_float_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_string_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function caml_int32_max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function i64_eq(x, y) {
  if (x[1] === y[1]) {
    return x[0] === y[0];
  } else {
    return false;
  }
}

function i64_ge(param, param$1) {
  var other_hi = param$1[0];
  var hi = param[0];
  if (hi > other_hi) {
    return true;
  } else if (hi < other_hi) {
    return false;
  } else {
    return param[1] >= param$1[1];
  }
}

function i64_neq(x, y) {
  return !i64_eq(x, y);
}

function i64_lt(x, y) {
  return !i64_ge(x, y);
}

function i64_gt(x, y) {
  if (x[0] > y[0]) {
    return true;
  } else if (x[0] < y[0]) {
    return false;
  } else {
    return x[1] > y[1];
  }
}

function i64_le(x, y) {
  return !i64_gt(x, y);
}

function i64_min(x, y) {
  if (i64_ge(x, y)) {
    return y;
  } else {
    return x;
  }
}

function i64_max(x, y) {
  if (i64_gt(x, y)) {
    return x;
  } else {
    return y;
  }
}

export {
  caml_int_compare ,
  caml_bool_compare ,
  caml_float_compare ,
  caml_string_compare ,
  caml_bool_min ,
  caml_int_min ,
  caml_float_min ,
  caml_string_min ,
  caml_int32_min ,
  caml_bool_max ,
  caml_int_max ,
  caml_float_max ,
  caml_string_max ,
  caml_int32_max ,
  i64_eq ,
  i64_neq ,
  i64_lt ,
  i64_gt ,
  i64_le ,
  i64_ge ,
  i64_min ,
  i64_max ,
}
/* No side effect */
`,rc=`// Generated by Melange


function sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (!l) {
      return acc;
    }
    _l = l.tl;
    _acc = l.hd.length + acc | 0;
    continue ;
  };
}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (!l) {
      return ;
    }
    var x = l.hd;
    var l$1 = x.length;
    var k = i;
    var j = 0;
    while(j < l$1) {
      arr[k] = x[j];
      k = k + 1 | 0;
      j = j + 1 | 0;
    };
    _l = l.tl;
    _i = k;
    continue ;
  };
}

function concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  xs[index] = newval;
}

function get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return xs[index];
}

function make(len, init) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = init;
  }
  return b;
}

function make_float(len) {
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = 0;
  }
  return b;
}

function blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0; j < len; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return ;
  }
  for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
    a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
  }
}

function dup(prim) {
  return prim.slice(0);
}

export {
  dup ,
  sub ,
  concat ,
  make ,
  make_float ,
  blit ,
  get ,
  set ,
}
/* No side effect */
`,ac=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,ic=`// Generated by Melange

import * as Js__Caml_int64 from "./caml_int64.js";

function set(s, i, ch) {
  if (i < 0 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  s[i] = ch;
}

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return s[i];
}

function caml_fill_bytes(s, i, l, c) {
  if (l <= 0) {
    return ;
  }
  for(var k = i ,k_finish = l + i | 0; k < k_finish; ++k){
    s[k] = c;
  }
}

function caml_create_bytes(len) {
  if (len < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.create",
          Error: new Error()
        };
  }
  var result = new Array(len);
  for(var i = 0; i < len; ++i){
    result[i] = /* '\\000' */0;
  }
  return result;
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return ;
  }
  if (s1 === s2) {
    if (i1 < i2) {
      var range_a = (s1.length - i2 | 0) - 1 | 0;
      var range_b = len - 1 | 0;
      var range = range_a > range_b ? range_b : range_a;
      for(var j = range; j >= 0; --j){
        s1[i2 + j | 0] = s1[i1 + j | 0];
      }
      return ;
    }
    if (i1 <= i2) {
      return ;
    }
    var range_a$1 = (s1.length - i1 | 0) - 1 | 0;
    var range_b$1 = len - 1 | 0;
    var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
    for(var k = 0; k <= range$1; ++k){
      s1[i2 + k | 0] = s1[i1 + k | 0];
    }
    return ;
  }
  var off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for(var i = 0; i < len; ++i){
      s2[i2 + i | 0] = s1[i1 + i | 0];
    }
    return ;
  }
  for(var i$1 = 0; i$1 < off1; ++i$1){
    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
  }
  for(var i$2 = off1; i$2 < len; ++i$2){
    s2[i2 + i$2 | 0] = /* '\\000' */0;
  }
}

function bytes_to_string(a) {
  var i = 0;
  var len = a.length;
  var s = "";
  var s_len = len;
  if (i === 0 && len <= 4096 && len === a.length) {
    return String.fromCharCode.apply(null, a);
  }
  var offset = 0;
  while(s_len > 0) {
    var next = s_len < 1024 ? s_len : 1024;
    var tmp_bytes = new Array(next);
    for(var k = 0; k < next; ++k){
      tmp_bytes[k] = a[k + offset | 0];
    }
    s = s + String.fromCharCode.apply(null, tmp_bytes);
    s_len = s_len - next | 0;
    offset = offset + next | 0;
  };
  return s;
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return ;
  }
  var off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for(var i = 0; i < len; ++i){
      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
    }
    return ;
  }
  for(var i$1 = 0; i$1 < off1; ++i$1){
    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
  }
  for(var i$2 = off1; i$2 < len; ++i$2){
    s2[i2 + i$2 | 0] = /* '\\000' */0;
  }
}

function bytes_of_string(s) {
  var len = s.length;
  var res = new Array(len);
  for(var i = 0; i < len; ++i){
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function caml_bytes_compare_aux(s1, s2, _off, len, def) {
  while(true) {
    var off = _off;
    if (off >= len) {
      return def;
    }
    var a = s1[off];
    var b = s2[off];
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    _off = off + 1 | 0;
    continue ;
  };
}

function caml_bytes_compare(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);
  } else if (len1 < len2) {
    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);
  } else {
    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);
  }
}

function caml_bytes_equal(s1, s2) {
  var len1 = s1.length;
  var len2 = s2.length;
  if (len1 === len2) {
    var _off = 0;
    while(true) {
      var off = _off;
      if (off === len1) {
        return true;
      }
      var a = s1[off];
      var b = s2[off];
      if (a !== b) {
        return false;
      }
      _off = off + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function caml_bytes_greaterthan(s1, s2) {
  return caml_bytes_compare(s1, s2) > 0;
}

function caml_bytes_greaterequal(s1, s2) {
  return caml_bytes_compare(s1, s2) >= 0;
}

function caml_bytes_lessthan(s1, s2) {
  return caml_bytes_compare(s1, s2) < 0;
}

function caml_bytes_lessequal(s1, s2) {
  return caml_bytes_compare(s1, s2) <= 0;
}

function bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function bswap32(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & -16777216) >>> 24);
}

function bswap64(x) {
  return Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.and_(x, [
                                              0,
                                              255
                                            ]), 56), Js__Caml_int64.lsl_(Js__Caml_int64.and_(x, [
                                              0,
                                              65280
                                            ]), 40)), Js__Caml_int64.lsl_(Js__Caml_int64.and_(x, [
                                          0,
                                          16711680
                                        ]), 24)), Js__Caml_int64.lsl_(Js__Caml_int64.and_(x, [
                                      0,
                                      4278190080
                                    ]), 8)), Js__Caml_int64.lsr_(Js__Caml_int64.and_(x, [
                                  255,
                                  0
                                ]), 8)), Js__Caml_int64.lsr_(Js__Caml_int64.and_(x, [
                              65280,
                              0
                            ]), 24)), Js__Caml_int64.lsr_(Js__Caml_int64.and_(x, [
                          16711680,
                          0
                        ]), 40)), Js__Caml_int64.lsr_(Js__Caml_int64.and_(x, [
                      -16777216,
                      0
                    ]), 56));
}

function get16u(str, idx) {
  var b1 = str[idx];
  var b2 = str[idx + 1 | 0];
  return (b2 << 8) | b1;
}

function get16(str, idx) {
  if (idx < 0 || (idx + 1 | 0) >= str.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return get16u(str, idx);
}

function get32(str, idx) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  var b1 = str[idx];
  var b2 = str[idx + 1 | 0];
  var b3 = str[idx + 2 | 0];
  var b4 = str[idx + 3 | 0];
  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
}

function get64(str, idx) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  var b1 = str[idx];
  var b2 = str[idx + 1 | 0];
  var b3 = str[idx + 2 | 0];
  var b4 = str[idx + 3 | 0];
  var b5 = str[idx + 4 | 0];
  var b6 = str[idx + 5 | 0];
  var b7 = str[idx + 6 | 0];
  var b8 = str[idx + 7 | 0];
  return Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.or_(Js__Caml_int64.lsl_(Js__Caml_int64.of_int32(b8), 56), Js__Caml_int64.of_int32(b7)), 48), Js__Caml_int64.of_int32(b6)), 40), Js__Caml_int64.of_int32(b5)), 32), Js__Caml_int64.of_int32(b4)), 24), Js__Caml_int64.of_int32(b3)), 16), Js__Caml_int64.of_int32(b2)), 8), Js__Caml_int64.of_int32(b1));
}

function set16u(b, idx, newval) {
  var b2 = 255 & (newval >>> 8);
  var b1 = 255 & newval;
  b[idx] = b1;
  b[idx + 1 | 0] = b2;
}

function set16(b, idx, newval) {
  if (idx < 0 || (idx + 1 | 0) >= b.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  set16u(b, idx, newval);
}

function set32u(str, idx, newval) {
  var b4 = 255 & (newval >>> 24);
  var b3 = 255 & (newval >>> 16);
  var b2 = 255 & (newval >>> 8);
  var b1 = 255 & newval;
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
}

function set32(str, idx, newval) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  set32u(str, idx, newval);
}

function set64u(str, idx, newval) {
  var x = Js__Caml_int64.lsr_(newval, 56);
  var b8 = 255 & (x[1] | 0);
  var x$1 = Js__Caml_int64.lsr_(newval, 48);
  var b7 = 255 & (x$1[1] | 0);
  var x$2 = Js__Caml_int64.lsr_(newval, 40);
  var b6 = 255 & (x$2[1] | 0);
  var x$3 = Js__Caml_int64.lsr_(newval, 32);
  var b5 = 255 & (x$3[1] | 0);
  var x$4 = Js__Caml_int64.lsr_(newval, 24);
  var b4 = 255 & (x$4[1] | 0);
  var x$5 = Js__Caml_int64.lsr_(newval, 16);
  var b3 = 255 & (x$5[1] | 0);
  var x$6 = Js__Caml_int64.lsr_(newval, 8);
  var b2 = 255 & (x$6[1] | 0);
  var b1 = 255 & (newval[1] | 0);
  str[idx] = b1;
  str[idx + 1 | 0] = b2;
  str[idx + 2 | 0] = b3;
  str[idx + 3 | 0] = b4;
  str[idx + 4 | 0] = b5;
  str[idx + 5 | 0] = b6;
  str[idx + 6 | 0] = b7;
  str[idx + 7 | 0] = b8;
}

function set64(str, idx, newval) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  set64u(str, idx, newval);
}

export {
  caml_create_bytes ,
  caml_fill_bytes ,
  get ,
  set ,
  bytes_to_string ,
  caml_blit_bytes ,
  caml_blit_string ,
  bytes_of_string ,
  caml_bytes_compare ,
  caml_bytes_greaterthan ,
  caml_bytes_greaterequal ,
  caml_bytes_lessthan ,
  caml_bytes_lessequal ,
  caml_bytes_equal ,
  bswap16 ,
  bswap32 ,
  bswap64 ,
  get16u ,
  get16 ,
  get32 ,
  get64 ,
  set16u ,
  set16 ,
  set32u ,
  set32 ,
  set64u ,
  set64 ,
}
/* No side effect */
`,sc=`// Generated by Melange


var id = {
  contents: 0
};

function create(str) {
  id.contents = id.contents + 1 | 0;
  return str + ("/" + id.contents);
}

function caml_is_extension(e) {
  if (e == null) {
    return false;
  } else {
    return typeof e.MEL_EXN_ID === "string";
  }
}

function caml_exn_slot_name(x) {
  return x.MEL_EXN_ID;
}

var caml_exn_slot_id = (function(x){
  if (x.MEL_EXN_ID != null) {
    var parts = x.MEL_EXN_ID.split("/");
    if (parts.length > 1) {
      return Number(parts[parts.length - 1])
    } else {
      return -1;
    }
  } else {
    return -1;
  }
});

export {
  id ,
  create ,
  caml_is_extension ,
  caml_exn_slot_name ,
  caml_exn_slot_id ,
}
/* No side effect */
`,oc=`// Generated by Melange


var getGlobalThis = (function(){
  if (typeof globalThis !== 'undefined') return globalThis;
	if (typeof self !== 'undefined') return self;
	if (typeof window !== 'undefined') return window;
	if (typeof global !== 'undefined') return global;
	if (typeof this !== 'undefined') return this;
	throw new Error('Unable to locate global \`this\`');
});

var resolve = (function(s){
  var myGlobal = getGlobalThis();
  if (myGlobal[s] === undefined){
    throw new Error(s + " not polyfilled by Melange yet\\n")
  }
  return myGlobal[s]
});

var register = (function(s,fn){
  var myGlobal = getGlobalThis();
  myGlobal[s] = fn
  return 0
});

export {
  getGlobalThis ,
  resolve ,
  register ,
}
/* No side effect */
`,_c=`// Generated by Melange


var caml_int32_float_of_bits = (function(x){
    return new Float32Array(new Int32Array([x]).buffer)[0]
    });

var caml_int32_bits_of_float = (function(x){
  return new Int32Array(new Float32Array([x]).buffer)[0]
});

function caml_modf_float(x) {
  if (!isFinite(x)) {
    if (isNaN(x)) {
      return [
              NaN,
              NaN
            ];
    } else {
      return [
              1 / x,
              x
            ];
    }
  }
  var neg = 1 / x < 0;
  var x$1 = Math.abs(x);
  var i = Math.floor(x$1);
  var f = x$1 - i;
  if (neg) {
    return [
            - f,
            - i
          ];
  } else {
    return [
            f,
            i
          ];
  }
}

function caml_ldexp_float(x, exp) {
  var x$p = x;
  var exp$p = exp;
  if (exp$p > 1023) {
    exp$p = exp$p - 1023;
    x$p = x$p * Math.pow(2, 1023);
    if (exp$p > 1023) {
      exp$p = exp$p - 1023;
      x$p = x$p * Math.pow(2, 1023);
    }
    
  } else if (exp$p < -1023) {
    exp$p = exp$p + 1023;
    x$p = x$p * Math.pow(2, -1023);
  }
  return x$p * Math.pow(2, exp$p);
}

function caml_frexp_float(x) {
  if (x === 0 || !isFinite(x)) {
    return [
            x,
            0
          ];
  }
  var neg = x < 0;
  var x$p = Math.abs(x);
  var exp = Math.floor(Math.LOG2E * Math.log(x$p)) + 1;
  x$p = x$p * Math.pow(2, - exp);
  if (x$p < 0.5) {
    x$p = x$p * 2;
    exp = exp - 1;
  }
  if (neg) {
    x$p = - x$p;
  }
  return [
          x$p,
          exp | 0
        ];
}

function caml_copysign_float(x, y) {
  var x$1 = Math.abs(x);
  var y$1 = y === 0 ? 1 / y : y;
  if (y$1 < 0) {
    return - x$1;
  } else {
    return x$1;
  }
}

function caml_expm1_float(x) {
  var y = Math.exp(x);
  var z = y - 1;
  if (Math.abs(x) > 1) {
    return z;
  } else if (z === 0) {
    return x;
  } else {
    return x * z / Math.log(y);
  }
}

function caml_hypot_float(x, y) {
  var x0 = Math.abs(x);
  var y0 = Math.abs(y);
  var a = x0 > y0 ? x0 : y0;
  var b = (
    x0 < y0 ? x0 : y0
  ) / (
    a !== 0 ? a : 1
  );
  return a * Math.sqrt(1 + b * b);
}

function caml_log10_float(x) {
  return Math.LOG10E * Math.log(x);
}

export {
  caml_int32_float_of_bits ,
  caml_int32_bits_of_float ,
  caml_modf_float ,
  caml_ldexp_float ,
  caml_frexp_float ,
  caml_copysign_float ,
  caml_expm1_float ,
  caml_hypot_float ,
  caml_log10_float ,
}
/* No side effect */
`,lc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,cc=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Js__Caml_int64 from "./caml_int64.js";

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* '0' */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    case /* Bin */3 :
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  var match = s.charCodeAt(i);
  switch (match) {
    case 43 :
        i = i + 1 | 0;
        break;
    case 44 :
        break;
    case 45 :
        sign = -1;
        i = i + 1 | 0;
        break;
    default:
      
  }
  if (s[i] === "0") {
    var match$1 = s.charCodeAt(i + 1 | 0);
    if (match$1 >= 89) {
      if (match$1 >= 111) {
        if (match$1 < 121) {
          switch (match$1) {
            case 111 :
                base = /* Oct */0;
                i = i + 2 | 0;
                break;
            case 117 :
                i = i + 2 | 0;
                break;
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
                break;
            case 120 :
                base = /* Hex */1;
                i = i + 2 | 0;
                break;
            
          }
        }
        
      } else if (match$1 === 98) {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
      
    } else if (match$1 !== 66) {
      if (match$1 >= 79) {
        switch (match$1) {
          case 79 :
              base = /* Oct */0;
              i = i + 2 | 0;
              break;
          case 85 :
              i = i + 2 | 0;
              break;
          case 80 :
          case 81 :
          case 82 :
          case 83 :
          case 84 :
          case 86 :
          case 87 :
              break;
          case 88 :
              base = /* Hex */1;
              i = i + 2 | 0;
              break;
          
        }
      }
      
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return [
          i,
          sign,
          base
        ];
}

function caml_int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* '\\000' */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw {
          MEL_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.charCodeAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = parse_digit(a);
      if (v < 0 || v >= base) {
        throw {
              MEL_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      var acc$1 = base * acc + v;
      if (acc$1 > threshold) {
        throw {
              MEL_EXN_ID: "Failure",
              _1: "int_of_string",
              Error: new Error()
            };
      }
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    };
  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw {
          MEL_EXN_ID: "Failure",
          _1: "int_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function caml_int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = Caml_int64.of_int32(int_of_string_base(hbase));
  var sign = Caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case /* Oct */0 :
        threshold = [
          536870911,
          4294967295
        ];
        break;
    case /* Hex */1 :
        threshold = [
          268435455,
          4294967295
        ];
        break;
    case /* Dec */2 :
        threshold = [
          429496729,
          2576980377
        ];
        break;
    case /* Bin */3 :
        threshold = Caml_int64.max_int;
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* '\\000' */0;
  var d = Caml_int64.of_int32(parse_digit(c));
  if (Caml.i64_lt(d, Caml_int64.zero) || Caml.i64_ge(d, base)) {
    throw {
          MEL_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      }
      var a = s.charCodeAt(k);
      if (a === /* '_' */95) {
        _k = k + 1 | 0;
        continue ;
      }
      var v = Caml_int64.of_int32(parse_digit(a));
      if (Caml.i64_lt(v, Caml_int64.zero) || Caml.i64_ge(v, base) || Caml.i64_gt(acc, threshold)) {
        throw {
              MEL_EXN_ID: "Failure",
              _1: "int64_of_string",
              Error: new Error()
            };
      }
      var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
      _k = k + 1 | 0;
      _acc = acc$1;
      continue ;
    };
  };
  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = Caml_int64.or_(res, Caml_int64.zero);
  if (Caml.i64_eq(base, [
          0,
          10
        ]) && Caml.i64_neq(res, or_res)) {
    throw {
          MEL_EXN_ID: "Failure",
          _1: "int64_of_string",
          Error: new Error()
        };
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case /* Oct */0 :
        return 8;
    case /* Hex */1 :
        return 16;
    case /* Dec */2 :
        return 10;
    
  }
}

function lowercase(c) {
  if (c >= /* 'A' */65 && c <= /* 'Z' */90 || c >= /* '\\192' */192 && c <= /* '\\214' */214 || c >= /* '\\216' */216 && c <= /* '\\222' */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "format_int: format too long",
          Error: new Error()
        };
  }
  var f = {
    justify: "+",
    signstyle: "-",
    filter: " ",
    alternate: false,
    base: /* Dec */2,
    signedconv: false,
    width: 0,
    uppercase: false,
    sign: 1,
    prec: -1,
    conv: "f"
  };
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    }
    var c = fmt.charCodeAt(i);
    var exit = 0;
    if (c >= 69) {
      if (c >= 88) {
        if (c >= 121) {
          exit = 1;
        } else {
          switch (c) {
            case 88 :
                f.base = /* Hex */1;
                f.uppercase = true;
                _i = i + 1 | 0;
                continue ;
            case 101 :
            case 102 :
            case 103 :
                exit = 5;
                break;
            case 100 :
            case 105 :
                exit = 4;
                break;
            case 111 :
                f.base = /* Oct */0;
                _i = i + 1 | 0;
                continue ;
            case 117 :
                f.base = /* Dec */2;
                _i = i + 1 | 0;
                continue ;
            case 89 :
            case 90 :
            case 91 :
            case 92 :
            case 93 :
            case 94 :
            case 95 :
            case 96 :
            case 97 :
            case 98 :
            case 99 :
            case 104 :
            case 106 :
            case 107 :
            case 108 :
            case 109 :
            case 110 :
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
                exit = 1;
                break;
            case 120 :
                f.base = /* Hex */1;
                _i = i + 1 | 0;
                continue ;
            
          }
        }
      } else if (c >= 72) {
        exit = 1;
      } else {
        f.signedconv = true;
        f.uppercase = true;
        f.conv = String.fromCharCode(lowercase(c));
        _i = i + 1 | 0;
        continue ;
      }
    } else {
      switch (c) {
        case 35 :
            f.alternate = true;
            _i = i + 1 | 0;
            continue ;
        case 32 :
        case 43 :
            exit = 2;
            break;
        case 45 :
            f.justify = "-";
            _i = i + 1 | 0;
            continue ;
        case 46 :
            f.prec = 0;
            var j = i + 1 | 0;
            while((function(j){
                return function () {
                  var w = fmt.charCodeAt(j) - /* '0' */48 | 0;
                  return w >= 0 && w <= 9;
                }
                }(j))()) {
              f.prec = (Math.imul(f.prec, 10) + fmt.charCodeAt(j) | 0) - /* '0' */48 | 0;
              j = j + 1 | 0;
            };
            _i = j;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 47 :
            exit = 1;
            break;
        case 48 :
            f.filter = "0";
            _i = i + 1 | 0;
            continue ;
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            exit = 3;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          _i = i + 1 | 0;
          continue ;
      case 2 :
          f.signstyle = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      case 3 :
          f.width = 0;
          var j$1 = i;
          while((function(j$1){
              return function () {
                var w = fmt.charCodeAt(j$1) - /* '0' */48 | 0;
                return w >= 0 && w <= 9;
              }
              }(j$1))()) {
            f.width = (Math.imul(f.width, 10) + fmt.charCodeAt(j$1) | 0) - /* '0' */48 | 0;
            j$1 = j$1 + 1 | 0;
          };
          _i = j$1;
          continue ;
      case 4 :
          f.signedconv = true;
          f.base = /* Dec */2;
          _i = i + 1 | 0;
          continue ;
      case 5 :
          f.signedconv = true;
          f.conv = String.fromCharCode(c);
          _i = i + 1 | 0;
          continue ;
      
    }
  };
}

function finish_formatting(config, rawbuffer) {
  var justify = config.justify;
  var signstyle = config.signstyle;
  var filter = config.filter;
  var alternate = config.alternate;
  var base = config.base;
  var signedconv = config.signedconv;
  var width = config.width;
  var uppercase = config.uppercase;
  var sign = config.sign;
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base === /* Oct */0) {
      len = len + 1 | 0;
    } else if (base === /* Hex */1) {
      len = len + 2 | 0;
    }
    
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var _for = len; _for < width; ++_for){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var _for$1 = len; _for$1 < width; ++_for$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var _for$2 = len; _for$2 < width; ++_for$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  }
  var f = parse_format(fmt);
  var i$1 = i < 0 ? (
      f.signedconv ? (f.sign = -1, (-i >>> 0)) : (i >>> 0)
    ) : i;
  var s = i$1.toString(int_of_base(f.base));
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    if (n > 0) {
      s = "0".repeat(n) + s;
    }
    
  }
  return finish_formatting(f, s);
}

function dec_of_pos_int64(x) {
  if (!Caml.i64_lt(x, Caml_int64.zero)) {
    return Js__Caml_int64.to_string(x);
  }
  var wbase = [
    0,
    10
  ];
  var y = Js__Caml_int64.discard_sign(x);
  var match = Js__Caml_int64.div_mod(y, wbase);
  var match$1 = Js__Caml_int64.div_mod(Caml_int64.add([
            0,
            8
          ], match[1]), wbase);
  var quotient = Caml_int64.add(Caml_int64.add([
            214748364,
            3435973836
          ], match[0]), match$1[0]);
  return Js__Caml_int64.to_string(quotient) + "0123456789"[Caml_int64.to_int32(match$1[1])];
}

function oct_of_int64(x) {
  var s = "";
  var wbase = [
    0,
    8
  ];
  var cvtbl = "01234567";
  if (Caml.i64_lt(x, Caml_int64.zero)) {
    var y = Js__Caml_int64.discard_sign(x);
    var match = Js__Caml_int64.div_mod(y, wbase);
    var quotient = Caml_int64.add([
          268435456,
          0
        ], match[0]);
    var modulus = match[1];
    s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    while(Caml.i64_neq(quotient, Caml_int64.zero)) {
      var match$1 = Js__Caml_int64.div_mod(quotient, wbase);
      quotient = match$1[0];
      modulus = match$1[1];
      s = cvtbl[Caml_int64.to_int32(modulus)] + s;
    };
  } else {
    var match$2 = Js__Caml_int64.div_mod(x, wbase);
    var quotient$1 = match$2[0];
    var modulus$1 = match$2[1];
    s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    while(Caml.i64_neq(quotient$1, Caml_int64.zero)) {
      var match$3 = Js__Caml_int64.div_mod(quotient$1, wbase);
      quotient$1 = match$3[0];
      modulus$1 = match$3[1];
      s = cvtbl[Caml_int64.to_int32(modulus$1)] + s;
    };
  }
  return s;
}

function caml_int64_format(fmt, x) {
  if (fmt === "%d") {
    return Js__Caml_int64.to_string(x);
  }
  var f = parse_format(fmt);
  var x$1 = f.signedconv && Caml.i64_lt(x, Caml_int64.zero) ? (f.sign = -1, Caml_int64.neg(x)) : x;
  var match = f.base;
  var s;
  switch (match) {
    case /* Oct */0 :
        s = oct_of_int64(x$1);
        break;
    case /* Hex */1 :
        s = Js__Caml_int64.to_hex(x$1);
        break;
    case /* Dec */2 :
        s = dec_of_pos_int64(x$1);
        break;
    
  }
  var fill_s;
  if (f.prec >= 0) {
    f.filter = " ";
    var n = f.prec - s.length | 0;
    fill_s = n > 0 ? "0".repeat(n) + s : s;
  } else {
    fill_s = s;
  }
  return finish_formatting(f, fill_s);
}

function caml_format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f.prec < 0 ? 6 : f.prec;
  var x$1 = x < 0 ? (f.sign = -1, - x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f.filter = " ";
  } else if (isFinite(x$1)) {
    var match = f.conv;
    switch (match) {
      case "e" :
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s[i - 3 | 0] === "e") {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" :
          s = x$1.toFixed(prec);
          break;
      case "g" :
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s[i$1] === "0") {
              i$1 = i$1 - 1 | 0;
            };
            if (s[i$1] === ".") {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s[i$2 - 3 | 0] === "e") {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return s.length > (prec$1 + 1 | 0);
                    })()) {
                p = p - 1 | 0;
              };
            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s[k] === "0") {
                k = k - 1 | 0;
              };
              if (s[k] === ".") {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
      default:
        
    }
  } else {
    s = "inf";
    f.filter = " ";
  }
  return finish_formatting(f, s);
}

var caml_hexstring_of_float = (function(x,prec,style){
  if (!isFinite(x)) {
    if (isNaN(x)) return "nan";
    return x > 0 ? "infinity":"-infinity";
  }
  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;
  if(sign) x = -x;
  var exp = 0;
  if (x == 0) { }
  else if (x < 1) {
    while (x < 1 && exp > -1022)  { x *= 2; exp-- }
  } else {
    while (x >= 2) { x /= 2; exp++ }
  }
  var exp_sign = exp < 0 ? '' : '+';
  var sign_str = '';
  if (sign) sign_str = '-'
  else {
    switch(style){
    case 43 /* '+' */: sign_str = '+'; break;
    case 32 /* ' ' */: sign_str = ' '; break;
    default: break;
    }
  }
  if (prec >= 0 && prec < 13) {
    /* If a precision is given, and is small, round mantissa accordingly */
      var cst = Math.pow(2,prec * 4);
      x = Math.round(x * cst) / cst;
  }
  var x_str = x.toString(16);
  if(prec >= 0){
      var idx = x_str.indexOf('.');
    if(idx<0) {
      x_str += '.' +  '0'.repeat(prec);
    }
    else {
      var size = idx+1+prec;
      if(x_str.length < size)
        x_str += '0'.repeat(size - x_str.length);
      else
        x_str = x_str.substr(0,size);
    }
  }
  return  (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));
});

var float_of_string = (function(s,exn){

    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    };
    var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
    //            1        2             3           4
    if(m){
        var m3 = m[3].replace(/0+$/,'');
        var mantissa = parseInt(m[1] + m[2] + m3, 16);
        var exponent = (m[4]|0) - 4*m3.length;
        res = mantissa * Math.pow(2, exponent);
        return res;
    }
    if (/^\\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    throw exn;
});

function caml_float_of_string(s) {
  return float_of_string(s, {
              MEL_EXN_ID: "Failure",
              _1: "float_of_string"
            });
}

var caml_nativeint_format = caml_format_int;

var caml_int32_format = caml_format_int;

var caml_int32_of_string = caml_int_of_string;

var caml_nativeint_of_string = caml_int_of_string;

export {
  caml_format_float ,
  caml_hexstring_of_float ,
  caml_format_int ,
  caml_nativeint_format ,
  caml_int32_format ,
  caml_float_of_string ,
  caml_int64_format ,
  caml_int_of_string ,
  caml_int32_of_string ,
  caml_int64_of_string ,
  caml_nativeint_of_string ,
}
/* No side effect */
`,uc=`// Generated by Melange


function caml_gc_counters(param) {
  return [
          0,
          0,
          0
        ];
}

function caml_gc_set(param) {
  
}

function caml_gc_minor(param) {
  
}

function caml_gc_major_slice(param) {
  return 0;
}

function caml_gc_major(param) {
  
}

function caml_gc_full_major(param) {
  
}

function caml_gc_compaction(param) {
  
}

function caml_final_register(param, param$1) {
  
}

function caml_final_release(param) {
  
}

export {
  caml_gc_counters ,
  caml_gc_set ,
  caml_gc_minor ,
  caml_gc_major_slice ,
  caml_gc_major ,
  caml_gc_full_major ,
  caml_gc_compaction ,
  caml_final_register ,
  caml_final_release ,
}
/* No side effect */
`,fc=`// Generated by Melange

import * as Js__Caml_hash_primitive from "./caml_hash_primitive.js";

function push_back(q, v) {
  var cell = {
    content: v,
    next: undefined
  };
  var last = q.last;
  if (last !== undefined) {
    q.length = q.length + 1 | 0;
    last.next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
}

function unsafe_pop(q) {
  var cell = q.first;
  var next = cell.next;
  if (next === undefined) {
    q.length = 0;
    q.first = undefined;
    q.last = undefined;
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
  }
  return cell.content;
}

function caml_hash(count, _limit, seed, obj) {
  var hash = seed;
  if (typeof obj === "number") {
    var u = obj | 0;
    hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, (u + u | 0) + 1 | 0);
    return Js__Caml_hash_primitive.caml_hash_final_mix(hash);
  }
  if (typeof obj === "string") {
    hash = Js__Caml_hash_primitive.caml_hash_mix_string(hash, obj);
    return Js__Caml_hash_primitive.caml_hash_final_mix(hash);
  }
  var queue = {
    length: 0,
    first: undefined,
    last: undefined
  };
  var num = count;
  push_back(queue, obj);
  num = num - 1 | 0;
  while(queue.length !== 0 && num > 0) {
    var obj$1 = unsafe_pop(queue);
    if (typeof obj$1 === "number") {
      var u$1 = obj$1 | 0;
      hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, (u$1 + u$1 | 0) + 1 | 0);
      num = num - 1 | 0;
    } else if (typeof obj$1 === "string") {
      hash = Js__Caml_hash_primitive.caml_hash_mix_string(hash, obj$1);
      num = num - 1 | 0;
    } else if (typeof obj$1 === "boolean") {
      var u$2 = obj$1 ? 1 : 0;
      hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, (u$2 + u$2 | 0) + 1 | 0);
      num = num - 1 | 0;
    } else if (typeof obj$1 !== "undefined" && typeof obj$1 !== "symbol" && typeof obj$1 !== "function") {
      var size = obj$1.length | 0;
      if (size !== 0) {
        var obj_tag = obj$1.TAG | 0;
        var tag = (size << 10) | obj_tag;
        if (obj_tag === 248) {
          hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, obj$1[1]);
        } else {
          hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, tag);
          var v = size - 1 | 0;
          var block = v < num ? v : num;
          for(var i = 0; i <= block; ++i){
            push_back(queue, obj$1[i]);
          }
        }
      } else {
        var size$1 = (function(obj,cb){
            var size = 0
            for(var k in obj){
              cb(obj[k])
              ++ size
            }
            return size
          })(obj$1, (function (v) {
                push_back(queue, v);
              }));
        hash = Js__Caml_hash_primitive.caml_hash_mix_int(hash, (size$1 << 10) | 0);
      }
    }
    
  };
  return Js__Caml_hash_primitive.caml_hash_final_mix(hash);
}

export {
  caml_hash ,
}
/* No side effect */
`,mc=`// Generated by Melange


function rotl32(x, n) {
  return (x << n) | (x >>> (32 - n | 0)) | 0;
}

function caml_hash_mix_int(h, d) {
  var d$1 = d;
  d$1 = Math.imul(d$1, -862048943);
  d$1 = rotl32(d$1, 15);
  d$1 = Math.imul(d$1, 461845907);
  var h$1 = h ^ d$1;
  h$1 = rotl32(h$1, 13);
  return (h$1 + (h$1 << 2) | 0) - 430675100 | 0;
}

function caml_hash_final_mix(h) {
  var h$1 = h ^ (h >>> 16);
  h$1 = Math.imul(h$1, -2048144789);
  h$1 = h$1 ^ (h$1 >>> 13);
  h$1 = Math.imul(h$1, -1028477387);
  return h$1 ^ (h$1 >>> 16);
}

function caml_hash_mix_string(h, s) {
  var len = s.length;
  var block = (len / 4 | 0) - 1 | 0;
  var hash = h;
  for(var i = 0; i <= block; ++i){
    var j = (i << 2);
    var w = s.charCodeAt(j) | (s.charCodeAt(j + 1 | 0) << 8) | (s.charCodeAt(j + 2 | 0) << 16) | (s.charCodeAt(j + 3 | 0) << 24);
    hash = caml_hash_mix_int(hash, w);
  }
  var modulo = len & 3;
  if (modulo !== 0) {
    var w$1 = modulo === 3 ? (s.charCodeAt(len - 1 | 0) << 16) | (s.charCodeAt(len - 2 | 0) << 8) | s.charCodeAt(len - 3 | 0) : (
        modulo === 2 ? (s.charCodeAt(len - 1 | 0) << 8) | s.charCodeAt(len - 2 | 0) : s.charCodeAt(len - 1 | 0)
      );
    hash = caml_hash_mix_int(hash, w$1);
  }
  hash = hash ^ len;
  return hash;
}

export {
  caml_hash_mix_int ,
  caml_hash_mix_string ,
  caml_hash_final_mix ,
}
/* No side effect */
`,pc=`// Generated by Melange


function div(x, y) {
  if (y === 0) {
    throw {
          MEL_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  }
  return x / y | 0;
}

function mod_(x, y) {
  if (y === 0) {
    throw {
          MEL_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  }
  return x % y;
}

export {
  div ,
  mod_ ,
}
/* No side effect */
`,dc=`// Generated by Melange


var Ops = {};

export {
  Ops ,
}
/* No side effect */
`,hc=`// Generated by Melange

import * as Js__Caml from "./caml.js";

function mk(lo, hi) {
  return [
          hi,
          (lo >>> 0)
        ];
}

var min_int = [
  -2147483648,
  0
];

var max_int = [
  2147483647,
  4294967295
];

var one = [
  0,
  1
];

var zero = [
  0,
  0
];

var neg_one = [
  -1,
  4294967295
];

function neg_signed(x) {
  return (x & -2147483648) !== 0;
}

function non_neg_signed(x) {
  return (x & -2147483648) === 0;
}

function succ(param) {
  var x_lo = param[1];
  var x_hi = param[0];
  var lo = x_lo + 1 | 0;
  return [
          x_hi + (
            lo === 0 ? 1 : 0
          ) | 0,
          (lo >>> 0)
        ];
}

function neg(param) {
  var other_lo = (param[1] ^ -1) + 1 | 0;
  return [
          (param[0] ^ -1) + (
            other_lo === 0 ? 1 : 0
          ) | 0,
          (other_lo >>> 0)
        ];
}

function add_aux(param, y_lo, y_hi) {
  var x_lo = param[1];
  var lo = x_lo + y_lo | 0;
  var overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;
  return [
          param[0] + y_hi + overflow | 0,
          (lo >>> 0)
        ];
}

function add(self, param) {
  return add_aux(self, param[1], param[0]);
}

function equal_null(x, y) {
  if (y !== null) {
    return Js__Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_undefined(x, y) {
  if (y !== undefined) {
    return Js__Caml.i64_eq(x, y);
  } else {
    return false;
  }
}

function equal_nullable(x, y) {
  if (y == null) {
    return false;
  } else {
    return Js__Caml.i64_eq(x, y);
  }
}

function sub_aux(x, lo, hi) {
  var y_lo = ((lo ^ -1) + 1 >>> 0);
  var y_hi = (hi ^ -1) + (
    y_lo === 0 ? 1 : 0
  ) | 0;
  return add_aux(x, y_lo, y_hi);
}

function sub(self, param) {
  return sub_aux(self, param[1], param[0]);
}

function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var lo = x[1];
  if (numBits >= 32) {
    return [
            (lo << (numBits - 32 | 0)),
            0
          ];
  } else {
    return [
            (lo >>> (32 - numBits | 0)) | (x[0] << numBits),
            ((lo << numBits) >>> 0)
          ];
  }
}

function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  var offset = numBits - 32 | 0;
  if (offset === 0) {
    return [
            0,
            (hi >>> 0)
          ];
  } else if (offset > 0) {
    return [
            0,
            (hi >>> offset)
          ];
  } else {
    return [
            (hi >>> numBits),
            (((hi << (-offset | 0)) | (x[1] >>> numBits)) >>> 0)
          ];
  }
}

function asr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  var hi = x[0];
  if (numBits < 32) {
    return [
            (hi >> numBits),
            (((hi << (32 - numBits | 0)) | (x[1] >>> numBits)) >>> 0)
          ];
  } else {
    return [
            hi >= 0 ? 0 : -1,
            ((hi >> (numBits - 32 | 0)) >>> 0)
          ];
  }
}

function is_zero(param) {
  if (param[0] !== 0) {
    return false;
  } else {
    return param[1] === 0;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var lo;
    var this_hi = $$this[0];
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (this_hi !== 0) {
      exit$2 = 4;
    } else {
      if ($$this[1] === 0) {
        return zero;
      }
      exit$2 = 4;
    }
    if (exit$2 === 4) {
      if (other[0] !== 0) {
        exit$1 = 3;
      } else {
        if (other[1] === 0) {
          return zero;
        }
        exit$1 = 3;
      }
    }
    if (exit$1 === 3) {
      if (this_hi !== -2147483648 || $$this[1] !== 0) {
        exit = 2;
      } else {
        lo = other[1];
      }
    }
    if (exit === 2) {
      var other_hi = other[0];
      var lo$1 = $$this[1];
      var exit$3 = 0;
      if (other_hi !== -2147483648 || other[1] !== 0) {
        exit$3 = 3;
      } else {
        lo = lo$1;
      }
      if (exit$3 === 3) {
        var other_lo = other[1];
        if (this_hi < 0) {
          if (other_hi >= 0) {
            return neg(mul(neg($$this), other));
          }
          _other = neg(other);
          _this = neg($$this);
          continue ;
        }
        if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        }
        var a48 = (this_hi >>> 16);
        var a32 = this_hi & 65535;
        var a16 = (lo$1 >>> 16);
        var a00 = lo$1 & 65535;
        var b48 = (other_hi >>> 16);
        var b32 = other_hi & 65535;
        var b16 = (other_lo >>> 16);
        var b00 = other_lo & 65535;
        var c48 = 0;
        var c32 = 0;
        var c16 = 0;
        var c00 = a00 * b00;
        c16 = (c00 >>> 16) + a16 * b00;
        c32 = (c16 >>> 16);
        c16 = (c16 & 65535) + a00 * b16;
        c32 = c32 + (c16 >>> 16) + a32 * b00;
        c48 = (c32 >>> 16);
        c32 = (c32 & 65535) + a16 * b16;
        c48 = c48 + (c32 >>> 16);
        c32 = (c32 & 65535) + a00 * b32;
        c48 = c48 + (c32 >>> 16);
        c32 = c32 & 65535;
        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
        return [
                c32 | (c48 << 16),
                ((c00 & 65535 | ((c16 & 65535) << 16)) >>> 0)
              ];
      }
      
    }
    if ((lo & 1) === 0) {
      return zero;
    } else {
      return min_int;
    }
  };
}

function xor(param, param$1) {
  return [
          param[0] ^ param$1[0],
          ((param[1] ^ param$1[1]) >>> 0)
        ];
}

function or_(param, param$1) {
  return [
          param[0] | param$1[0],
          ((param[1] | param$1[1]) >>> 0)
        ];
}

function and_(param, param$1) {
  return [
          param[0] & param$1[0],
          ((param[1] & param$1[1]) >>> 0)
        ];
}

function to_float(param) {
  return param[0] * 0x100000000 + param[1];
}

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  }
  if (x <= -9.22337203685477581e+18) {
    return min_int;
  }
  if (x + 1 >= 9.22337203685477581e+18) {
    return max_int;
  }
  if (x < 0) {
    return neg(of_float(- x));
  }
  var hi = x / 4294967296 | 0;
  var lo = x % 4294967296 | 0;
  return [
          hi,
          (lo >>> 0)
        ];
}

function isSafeInteger(param) {
  var hi = param[0];
  var top11Bits = (hi >> 21);
  if (top11Bits === 0) {
    return true;
  } else if (top11Bits === -1) {
    return !(param[1] === 0 && hi === -2097152);
  } else {
    return false;
  }
}

function to_string(self) {
  if (isSafeInteger(self)) {
    return String(to_float(self));
  }
  if (self[0] < 0) {
    if (Js__Caml.i64_eq(self, min_int)) {
      return "-9223372036854775808";
    } else {
      return "-" + to_string(neg(self));
    }
  }
  var approx_div1 = of_float(Math.floor(to_float(self) / 10));
  var lo = approx_div1[1];
  var hi = approx_div1[0];
  var match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));
  var rem_lo = match[1];
  var rem_hi = match[0];
  if (rem_lo === 0 && rem_hi === 0) {
    return to_string(approx_div1) + "0";
  }
  if (rem_hi < 0) {
    var rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);
    var delta = Math.ceil(rem_lo$1 / 10);
    var remainder = 10 * delta - rem_lo$1;
    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);
  }
  var delta$1 = Math.floor(rem_lo / 10);
  var remainder$1 = rem_lo - 10 * delta$1;
  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);
}

function div(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var exit = 0;
    if (other[0] !== 0 || other[1] !== 0) {
      exit = 1;
    } else {
      throw {
            MEL_EXN_ID: "Division_by_zero",
            Error: new Error()
          };
    }
    if (exit === 1) {
      var self_hi = self[0];
      var exit$1 = 0;
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit$1 = 2;
        } else {
          if (self[1] === 0) {
            return zero;
          }
          exit$1 = 2;
        }
      } else if (self[1] !== 0) {
        exit$1 = 2;
      } else {
        if (Js__Caml.i64_eq(other, one) || Js__Caml.i64_eq(other, neg_one)) {
          return self;
        }
        if (Js__Caml.i64_eq(other, min_int)) {
          return one;
        }
        var half_this = asr_(self, 1);
        var approx = lsl_(div(half_this, other), 1);
        var exit$2 = 0;
        if (approx[0] !== 0) {
          exit$2 = 3;
        } else {
          if (approx[1] === 0) {
            if (other[0] < 0) {
              return one;
            } else {
              return neg(one);
            }
          }
          exit$2 = 3;
        }
        if (exit$2 === 3) {
          var rem = sub(self, mul(other, approx));
          return add(approx, div(rem, other));
        }
        
      }
      if (exit$1 === 2) {
        var other_hi = other[0];
        var exit$3 = 0;
        if (other_hi !== -2147483648) {
          exit$3 = 3;
        } else {
          if (other[1] === 0) {
            return zero;
          }
          exit$3 = 3;
        }
        if (exit$3 === 3) {
          if (self_hi < 0) {
            if (other_hi >= 0) {
              return neg(div(neg(self), other));
            }
            _other = neg(other);
            _self = neg(self);
            continue ;
          }
          if (other_hi < 0) {
            return neg(div(self, neg(other)));
          }
          var res = zero;
          var rem$1 = self;
          while(Js__Caml.i64_ge(rem$1, other)) {
            var b = Math.floor(to_float(rem$1) / to_float(other));
            var approx$1 = 1 > b ? 1 : b;
            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            var approxRes = of_float(approx$1);
            var approxRem = mul(approxRes, other);
            while(approxRem[0] < 0 || Js__Caml.i64_gt(approxRem, rem$1)) {
              approx$1 = approx$1 - delta;
              approxRes = of_float(approx$1);
              approxRem = mul(approxRes, other);
            };
            if (is_zero(approxRes)) {
              approxRes = one;
            }
            res = add(res, approxRes);
            rem$1 = sub(rem$1, approxRem);
          };
          return res;
        }
        
      }
      
    }
    
  };
}

function mod_(self, other) {
  return sub(self, mul(div(self, other), other));
}

function div_mod(self, other) {
  var quotient = div(self, other);
  return [
          quotient,
          sub(self, mul(quotient, other))
        ];
}

function compare(self, other) {
  var y = other[0];
  var x = self[0];
  var v = x < y ? -1 : (
      x === y ? 0 : 1
    );
  if (v !== 0) {
    return v;
  }
  var y$1 = other[1];
  var x$1 = self[1];
  if (x$1 < y$1) {
    return -1;
  } else if (x$1 === y$1) {
    return 0;
  } else {
    return 1;
  }
}

function of_int32(lo) {
  return [
          lo < 0 ? -1 : 0,
          (lo >>> 0)
        ];
}

function to_int32(x) {
  return x[1] | 0;
}

function to_hex(x) {
  var x_lo = x[1];
  var x_hi = x[0];
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  if (x_hi === 0 && x_lo === 0) {
    return "0";
  }
  if (x_lo === 0) {
    return aux(x_hi) + "00000000";
  }
  if (x_hi === 0) {
    return aux(x_lo);
  }
  var lo = aux(x_lo);
  var pad = 8 - lo.length | 0;
  if (pad <= 0) {
    return aux(x_hi) + lo;
  } else {
    return aux(x_hi) + ("0".repeat(pad) + lo);
  }
}

function discard_sign(x) {
  return [
          2147483647 & x[0],
          x[1]
        ];
}

function float_of_bits(x) {
  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]})(x[1], x[0]);
}

function bits_of_float(x) {
  var match = (function(x){return new Int32Array(new Float64Array([x]).buffer)})(x);
  return [
          match[1],
          (match[0] >>> 0)
        ];
}

export {
  mk ,
  succ ,
  min_int ,
  max_int ,
  one ,
  zero ,
  neg_one ,
  of_int32 ,
  to_int32 ,
  add ,
  neg ,
  sub ,
  lsl_ ,
  lsr_ ,
  asr_ ,
  is_zero ,
  mul ,
  xor ,
  or_ ,
  and_ ,
  equal_null ,
  equal_undefined ,
  equal_nullable ,
  to_float ,
  of_float ,
  div ,
  mod_ ,
  compare ,
  float_of_bits ,
  bits_of_float ,
  div_mod ,
  to_hex ,
  discard_sign ,
  to_string ,
}
/* No side effect */
`,gc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,bc=`// Generated by Melange


var stdout = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (((typeof process !== "undefined") && process.stdout && process.stdout.write)) {
        return process.stdout.write(s);
      } else {
        if (s[v] === "\\n") {
          console.log(s.slice(0, v));
        } else {
          console.log(s);
        }
        return ;
      }
    })
};

var stderr = {
  buffer: "",
  output: (function (param, s) {
      var v = s.length - 1 | 0;
      if (s[v] === "\\n") {
        console.log(s.slice(0, v));
      } else {
        console.log(s);
      }
    })
};

function caml_ml_flush(oc) {
  if (oc.buffer !== "") {
    oc.output(oc, oc.buffer);
    oc.buffer = "";
    return ;
  }
  
}

function caml_ml_output(oc, str, offset, len) {
  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (((typeof process !== "undefined") && process.stdout && process.stdout.write) && oc === stdout) {
    return process.stdout.write(str$1);
  }
  var id = str$1.lastIndexOf("\\n");
  if (id < 0) {
    oc.buffer = oc.buffer + str$1;
  } else {
    oc.buffer = oc.buffer + str$1.slice(0, id + 1 | 0);
    caml_ml_flush(oc);
    oc.buffer = oc.buffer + str$1.slice(id + 1 | 0);
  }
}

function caml_ml_output_char(oc, $$char) {
  caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_out_channels_list(param) {
  return {
          hd: stdout,
          tl: {
            hd: stderr,
            tl: /* [] */0
          }
        };
}

var stdin;

export {
  stdin ,
  stdout ,
  stderr ,
  caml_ml_flush ,
  caml_ml_output ,
  caml_ml_output_char ,
  caml_ml_out_channels_list ,
}
/* No side effect */
`,vc=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Js__Caml_exceptions from "./caml_exceptions.js";

var $$Error = /* @__PURE__ */Caml_exceptions.create("Js__Caml_js_exceptions.Error");

function internalToOCamlException(e) {
  if (Js__Caml_exceptions.caml_is_extension(e)) {
    return e;
  } else {
    return {
            MEL_EXN_ID: $$Error,
            _1: e
          };
  }
}

function caml_as_js_exn(exn) {
  if (exn.MEL_EXN_ID === $$Error) {
    return Caml_option.some(exn._1);
  }
  
}

export {
  $$Error ,
  internalToOCamlException ,
  caml_as_js_exn ,
}
/* No side effect */
`,yc=`// Generated by Melange


/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */

/* The table-driven automaton for lexers generated by camllex. */

function caml_lex_array(s) {
    var l = s.length / 2;
    var a = new Array(l);
    // when s.charCodeAt(2 * i + 1 ) > 128 (0x80)
    // a[i] < 0
    // for(var i = 0 ; i <= 0xffff; ++i) { if (i << 16 >> 16 !==i){console.log(i<<16>>16, 'vs',i)}}
    //
    for (var i = 0; i < l; i++)
        a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;
    return a;
}
;

var caml_lex_engine_aux = (function (tbl, start_state, lexbuf, exn){

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);
    }
    var c;
    var state = start_state;
    //var buffer = bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0)
            return -base - 1;
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached === 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        if (tbl.lex_check[base + c] === state) {
            state = tbl.lex_trans[base + c];
        }
        else {
            state = tbl.lex_default[state];
        }
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
                throw exn
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
});

var empty_token_lit = "lexing: empty token";

function caml_lex_engine(tbls, i, buf) {
  return caml_lex_engine_aux(tbls, i, buf, {
              MEL_EXN_ID: "Failure",
              _1: empty_token_lit
            });
}

/***********************************************/
/* New lexer engine, with memory of positions  */
/***********************************************/

/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */

function caml_lex_run_mem(s, i, mem, curr_pos) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = curr_pos;
        else
            mem[dst] = mem[src];
    }
}


/**
 * s -> Lexing.lex_tables.lex_code
 * mem -> Lexing.lexbuf.lex_mem (* int array *)
 */

function caml_lex_run_tag(s, i, mem) {
    for (;;) {
        var dst = s.charCodeAt(i);
        i++;
        if (dst == 0xff)
            return;
        var src = s.charCodeAt(i);
        i++;
        if (src == 0xff)
            mem[dst] = -1;
        else
            mem[dst] = mem[src];
    }
}
;

var caml_new_lex_engine_aux = (function (tbl, start_state, lexbuf, exn) {

    if (!Array.isArray(tbl.lex_default)) {
        tbl.lex_base = caml_lex_array(tbl.lex_base);
        tbl.lex_backtrk = caml_lex_array(tbl.lex_backtrk);
        tbl.lex_check = caml_lex_array(tbl.lex_check);
        tbl.lex_trans = caml_lex_array(tbl.lex_trans);
        tbl.lex_default = caml_lex_array(tbl.lex_default);
    }
    if(!Array.isArray(tbl.lex_default_code)){
        tbl.lex_base_code = caml_lex_array(tbl.lex_base_code);
        tbl.lex_backtrk_code = caml_lex_array(tbl.lex_backtrk_code);
        tbl.lex_check_code = caml_lex_array(tbl.lex_check_code);
        tbl.lex_trans_code = caml_lex_array(tbl.lex_trans_code);
        tbl.lex_default_code = caml_lex_array(tbl.lex_default_code);
    }
    var c, state = start_state;
    //var buffer = caml_bytes_of_string(lexbuf.lex_buffer);
    var buffer = lexbuf.lex_buffer;
    if (state >= 0) {
        /* First entry */
        lexbuf.lex_last_pos = lexbuf.lex_start_pos = lexbuf.lex_curr_pos;
        lexbuf.lex_last_action = -1;
    }
    else {
        /* Reentry after refill */
        state = -state - 1;
    }
    for (;;) {
        /* Lookup base address or action number for current state */
        var base = tbl.lex_base[state];
        if (base < 0) {
            var pc_off = tbl.lex_base_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            return -base - 1;
        }
        /* See if it's a backtrack point */
        var backtrk = tbl.lex_backtrk[state];
        if (backtrk >= 0) {
            var pc_off = tbl.lex_backtrk_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf.lex_mem);
            lexbuf.lex_last_pos = lexbuf.lex_curr_pos;
            lexbuf.lex_last_action = backtrk;
        }
        /* See if we need a refill */
        if (lexbuf.lex_curr_pos >= lexbuf.lex_buffer_len) {
            if (lexbuf.lex_eof_reached == 0)
                return -state - 1;
            else
                c = 256;
        }
        else {
            /* Read next input char */
            c = buffer[lexbuf.lex_curr_pos];
            lexbuf.lex_curr_pos++;
        }
        /* Determine next state */
        var pstate = state;
        if (tbl.lex_check[base + c] == state)
            state = tbl.lex_trans[base + c];
        else
            state = tbl.lex_default[state];
        /* If no transition on this char, return to last backtrack point */
        if (state < 0) {
            lexbuf.lex_curr_pos = lexbuf.lex_last_pos;
            if (lexbuf.lex_last_action == -1)
                throw exn;
            else
                return lexbuf.lex_last_action;
        }
        else {
            /* If some transition, get and perform memory moves */
            var base_code = tbl.lex_base_code[pstate], pc_off;
            if (tbl.lex_check_code[base_code + c] == pstate)
                pc_off = tbl.lex_trans_code[base_code + c];
            else
                pc_off = tbl.lex_default_code[pstate];
            if (pc_off > 0)
                caml_lex_run_mem(tbl.lex_code, pc_off, lexbuf.lex_mem, lexbuf.lex_curr_pos);
            /* Erase the EOF condition only if the EOF pseudo-character was
             consumed by the automaton (i.e. there was no backtrack above)
             */
            if (c == 256)
                lexbuf.lex_eof_reached = 0;
        }
    }
    });

function caml_new_lex_engine(tbl, i, buf) {
  return caml_new_lex_engine_aux(tbl, i, buf, {
              MEL_EXN_ID: "Failure",
              _1: empty_token_lit
            });
}

export {
  caml_lex_engine ,
  caml_new_lex_engine ,
}
/*  Not a pure module */
`,xc=`// Generated by Melange


function cmn(q, a, b, x, s, t) {
  var a$1 = ((a + q | 0) + x | 0) + t | 0;
  return ((a$1 << s) | (a$1 >>> (32 - s | 0)) | 0) + b | 0;
}

function f(a, b, c, d, x, s, t) {
  return cmn(b & c | (b ^ -1) & d, a, b, x, s, t);
}

function g(a, b, c, d, x, s, t) {
  return cmn(b & d | c & (d ^ -1), a, b, x, s, t);
}

function h(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}

function i(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | d ^ -1), a, b, x, s, t);
}

function cycle(x, k) {
  var a = x[0];
  var b = x[1];
  var c = x[2];
  var d = x[3];
  a = f(a, b, c, d, k[0], 7, -680876936);
  d = f(d, a, b, c, k[1], 12, -389564586);
  c = f(c, d, a, b, k[2], 17, 606105819);
  b = f(b, c, d, a, k[3], 22, -1044525330);
  a = f(a, b, c, d, k[4], 7, -176418897);
  d = f(d, a, b, c, k[5], 12, 1200080426);
  c = f(c, d, a, b, k[6], 17, -1473231341);
  b = f(b, c, d, a, k[7], 22, -45705983);
  a = f(a, b, c, d, k[8], 7, 1770035416);
  d = f(d, a, b, c, k[9], 12, -1958414417);
  c = f(c, d, a, b, k[10], 17, -42063);
  b = f(b, c, d, a, k[11], 22, -1990404162);
  a = f(a, b, c, d, k[12], 7, 1804603682);
  d = f(d, a, b, c, k[13], 12, -40341101);
  c = f(c, d, a, b, k[14], 17, -1502002290);
  b = f(b, c, d, a, k[15], 22, 1236535329);
  a = g(a, b, c, d, k[1], 5, -165796510);
  d = g(d, a, b, c, k[6], 9, -1069501632);
  c = g(c, d, a, b, k[11], 14, 643717713);
  b = g(b, c, d, a, k[0], 20, -373897302);
  a = g(a, b, c, d, k[5], 5, -701558691);
  d = g(d, a, b, c, k[10], 9, 38016083);
  c = g(c, d, a, b, k[15], 14, -660478335);
  b = g(b, c, d, a, k[4], 20, -405537848);
  a = g(a, b, c, d, k[9], 5, 568446438);
  d = g(d, a, b, c, k[14], 9, -1019803690);
  c = g(c, d, a, b, k[3], 14, -187363961);
  b = g(b, c, d, a, k[8], 20, 1163531501);
  a = g(a, b, c, d, k[13], 5, -1444681467);
  d = g(d, a, b, c, k[2], 9, -51403784);
  c = g(c, d, a, b, k[7], 14, 1735328473);
  b = g(b, c, d, a, k[12], 20, -1926607734);
  a = h(a, b, c, d, k[5], 4, -378558);
  d = h(d, a, b, c, k[8], 11, -2022574463);
  c = h(c, d, a, b, k[11], 16, 1839030562);
  b = h(b, c, d, a, k[14], 23, -35309556);
  a = h(a, b, c, d, k[1], 4, -1530992060);
  d = h(d, a, b, c, k[4], 11, 1272893353);
  c = h(c, d, a, b, k[7], 16, -155497632);
  b = h(b, c, d, a, k[10], 23, -1094730640);
  a = h(a, b, c, d, k[13], 4, 681279174);
  d = h(d, a, b, c, k[0], 11, -358537222);
  c = h(c, d, a, b, k[3], 16, -722521979);
  b = h(b, c, d, a, k[6], 23, 76029189);
  a = h(a, b, c, d, k[9], 4, -640364487);
  d = h(d, a, b, c, k[12], 11, -421815835);
  c = h(c, d, a, b, k[15], 16, 530742520);
  b = h(b, c, d, a, k[2], 23, -995338651);
  a = i(a, b, c, d, k[0], 6, -198630844);
  d = i(d, a, b, c, k[7], 10, 1126891415);
  c = i(c, d, a, b, k[14], 15, -1416354905);
  b = i(b, c, d, a, k[5], 21, -57434055);
  a = i(a, b, c, d, k[12], 6, 1700485571);
  d = i(d, a, b, c, k[3], 10, -1894986606);
  c = i(c, d, a, b, k[10], 15, -1051523);
  b = i(b, c, d, a, k[1], 21, -2054922799);
  a = i(a, b, c, d, k[8], 6, 1873313359);
  d = i(d, a, b, c, k[15], 10, -30611744);
  c = i(c, d, a, b, k[6], 15, -1560198380);
  b = i(b, c, d, a, k[13], 21, 1309151649);
  a = i(a, b, c, d, k[4], 6, -145523070);
  d = i(d, a, b, c, k[11], 10, -1120210379);
  c = i(c, d, a, b, k[2], 15, 718787259);
  b = i(b, c, d, a, k[9], 21, -343485551);
  x[0] = a + x[0] | 0;
  x[1] = b + x[1] | 0;
  x[2] = c + x[2] | 0;
  x[3] = d + x[3] | 0;
}

var state = [
  1732584193,
  -271733879,
  -1732584194,
  271733878
];

var md5blk = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];

function caml_md5_string(s, start, len) {
  var s$1 = s.slice(start, len);
  var n = s$1.length;
  state[0] = 1732584193;
  state[1] = -271733879;
  state[2] = -1732584194;
  state[3] = 271733878;
  for(var i = 0; i <= 15; ++i){
    md5blk[i] = 0;
  }
  var i_end = n / 64 | 0;
  for(var i$1 = 1; i$1 <= i_end; ++i$1){
    for(var j = 0; j <= 15; ++j){
      var k = ((i$1 << 6) - 64 | 0) + (j << 2) | 0;
      md5blk[j] = ((s$1.charCodeAt(k) + (s$1.charCodeAt(k + 1 | 0) << 8) | 0) + (s$1.charCodeAt(k + 2 | 0) << 16) | 0) + (s$1.charCodeAt(k + 3 | 0) << 24) | 0;
    }
    cycle(state, md5blk);
  }
  var s_tail = s$1.slice((i_end << 6));
  for(var kk = 0; kk <= 15; ++kk){
    md5blk[kk] = 0;
  }
  var i_end$1 = s_tail.length - 1 | 0;
  for(var i$2 = 0; i$2 <= i_end$1; ++i$2){
    md5blk[i$2 / 4 | 0] = md5blk[i$2 / 4 | 0] | (s_tail.charCodeAt(i$2) << (i$2 % 4 << 3));
  }
  var i$3 = i_end$1 + 1 | 0;
  md5blk[i$3 / 4 | 0] = md5blk[i$3 / 4 | 0] | (128 << (i$3 % 4 << 3));
  if (i$3 > 55) {
    cycle(state, md5blk);
    for(var i$4 = 0; i$4 <= 15; ++i$4){
      md5blk[i$4] = 0;
    }
  }
  md5blk[14] = (n << 3);
  cycle(state, md5blk);
  return String.fromCharCode(state[0] & 255, (state[0] >> 8) & 255, (state[0] >> 16) & 255, (state[0] >> 24) & 255, state[1] & 255, (state[1] >> 8) & 255, (state[1] >> 16) & 255, (state[1] >> 24) & 255, state[2] & 255, (state[2] >> 8) & 255, (state[2] >> 16) & 255, (state[2] >> 24) & 255, state[3] & 255, (state[3] >> 8) & 255, (state[3] >> 16) & 255, (state[3] >> 24) & 255);
}

export {
  caml_md5_string ,
}
/* No side effect */
`,$c=`// Generated by Melange

import * as Js__Caml_obj from "./caml_obj.js";

function init_mod(loc, shape) {
  var undef_module = function (param) {
    throw {
          MEL_EXN_ID: "Undefined_recursive_module",
          _1: loc,
          Error: new Error()
        };
  };
  var loop = function (shape, struct_, idx) {
    if (typeof shape === "number") {
      switch (shape) {
        case /* Function */0 :
            struct_[idx] = undef_module;
            return ;
        case /* Lazy */1 :
            struct_[idx] = {
              LAZY_DONE: true,
              VAL: undef_module
            };
            return ;
        case /* Class */2 :
            struct_[idx] = [
              undef_module,
              undef_module,
              undef_module,
              0
            ];
            return ;
        
      }
    } else {
      if (shape.TAG === /* Module */0) {
        var comps = shape._0;
        var v = {};
        struct_[idx] = v;
        var len = comps.length;
        for(var i = 0; i < len; ++i){
          var match = comps[i];
          loop(match[0], v, match[1]);
        }
        return ;
      }
      struct_[idx] = shape._0;
      return ;
    }
  };
  var res = {};
  var dummy_name = "dummy";
  loop(shape, res, dummy_name);
  return res[dummy_name];
}

function update_mod(shape, o, n) {
  var aux = function (shape, o, n, parent, i) {
    if (typeof shape === "number") {
      switch (shape) {
        case /* Function */0 :
            parent[i] = n;
            return ;
        case /* Lazy */1 :
        case /* Class */2 :
            return Js__Caml_obj.update_dummy(o, n);
        
      }
    } else {
      if (shape.TAG !== /* Module */0) {
        return ;
      }
      var comps = shape._0;
      for(var i$1 = 0 ,i_finish = comps.length; i$1 < i_finish; ++i$1){
        var match = comps[i$1];
        var name = match[1];
        aux(match[0], o[name], n[name], o, name);
      }
      return ;
    }
  };
  if (typeof shape === "number") {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/runtime/caml_module.ml",
            99,
            9
          ],
          Error: new Error()
        };
  }
  if (shape.TAG === /* Module */0) {
    var comps = shape._0;
    for(var i = 0 ,i_finish = comps.length; i < i_finish; ++i){
      var match = comps[i];
      var name = match[1];
      aux(match[0], o[name], n[name], o, name);
    }
    return ;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/runtime/caml_module.ml",
          99,
          9
        ],
        Error: new Error()
      };
}

export {
  init_mod ,
  update_mod ,
}
/* No side effect */
`,Ec=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,kc=`// Generated by Melange

import * as Caml from "melange.js/caml.js";

var for_in = (function(o,foo){
        for (var x in o) { foo(x) }});

var caml_obj_dup = (function(x){
  if(Array.isArray(x)){
    var len = x.length
    var v = new Array(len)
    for(var i = 0 ; i < len ; ++i){
      v[i] = x[i]
    }
    if(x.TAG !== undefined){
      v.TAG = x.TAG // TODO this can be removed eventually
    }
    return v
  }
  return Object.assign({},x)
});

var update_dummy = (function(x,y){
  var k
  if(Array.isArray(y)){
    for(k = 0; k < y.length ; ++k){
      x[k] = y[k]
    }
    if(y.TAG !== undefined){
      x.TAG = y.TAG
    }
  } else {
    for (var k in y){
      x[k] = y[k]
    }
  }
});

function caml_compare(a, b) {
  if (a === b) {
    return 0;
  }
  var a_type = typeof a;
  var b_type = typeof b;
  switch (a_type) {
    case "bigint" :
        if (b_type === "bigint") {
          return Caml.caml_float_compare(a, b);
        }
        break;
    case "boolean" :
        if (b_type === "boolean") {
          return Caml.caml_int_compare(a, b);
        }
        break;
    case "function" :
        if (b_type === "function") {
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "compare: functional value",
                Error: new Error()
              };
        }
        break;
    case "number" :
        if (b_type === "number") {
          return Caml.caml_float_compare(a, b);
        }
        break;
    case "string" :
        if (b_type === "string") {
          return Caml.caml_string_compare(a, b);
        } else {
          return 1;
        }
    case "undefined" :
        return -1;
    default:
      
  }
  switch (b_type) {
    case "string" :
        return -1;
    case "undefined" :
        return 1;
    default:
      if (a_type === "boolean") {
        return 1;
      }
      if (b_type === "boolean") {
        return -1;
      }
      if (a_type === "function") {
        return 1;
      }
      if (b_type === "function") {
        return -1;
      }
      if (a_type === "number") {
        if (b === null || b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b_type === "number") {
        if (a === null || a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a === null) {
        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return 1;
        } else {
          return -1;
        }
      }
      if (b === null) {
        if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return -1;
        } else {
          return 1;
        }
      }
      if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
          return aux_obj_compare(a, b);
        } else {
          return -1;
        }
      }
      var tag_a = a.TAG | 0;
      var tag_b = b.TAG | 0;
      if (tag_a === 248) {
        return Caml.caml_int_compare(a[1], b[1]);
      }
      if (tag_a === 251) {
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "equal: abstract value",
              Error: new Error()
            };
      }
      if (tag_a !== tag_b) {
        if (tag_a < tag_b) {
          return -1;
        } else {
          return 1;
        }
      }
      var len_a = a.length | 0;
      var len_b = b.length | 0;
      if (len_a === len_b) {
        if (Array.isArray(a)) {
          var _i = 0;
          while(true) {
            var i = _i;
            if (i === len_a) {
              return 0;
            }
            var res = caml_compare(a[i], b[i]);
            if (res !== 0) {
              return res;
            }
            _i = i + 1 | 0;
            continue ;
          };
        } else if ((a instanceof Date && b instanceof Date)) {
          return (a - b);
        } else {
          return aux_obj_compare(a, b);
        }
      } else if (len_a < len_b) {
        var _i$1 = 0;
        while(true) {
          var i$1 = _i$1;
          if (i$1 === len_a) {
            return -1;
          }
          var res$1 = caml_compare(a[i$1], b[i$1]);
          if (res$1 !== 0) {
            return res$1;
          }
          _i$1 = i$1 + 1 | 0;
          continue ;
        };
      } else {
        var _i$2 = 0;
        while(true) {
          var i$2 = _i$2;
          if (i$2 === len_b) {
            return 1;
          }
          var res$2 = caml_compare(a[i$2], b[i$2]);
          if (res$2 !== 0) {
            return res$2;
          }
          _i$2 = i$2 + 1 | 0;
          continue ;
        };
      }
  }
}

function aux_obj_compare(a, b) {
  var min_key_lhs = {
    contents: undefined
  };
  var min_key_rhs = {
    contents: undefined
  };
  var do_key = function (param, key) {
    var min_key = param[2];
    var b = param[1];
    if (!(!Object.prototype.hasOwnProperty.call(b, key) || caml_compare(param[0][key], b[key]) > 0)) {
      return ;
    }
    var mk = min_key.contents;
    if (mk !== undefined && key >= mk) {
      return ;
    } else {
      min_key.contents = key;
      return ;
    }
  };
  var partial_arg = [
    a,
    b,
    min_key_rhs
  ];
  var do_key_a = function (param) {
    return do_key(partial_arg, param);
  };
  var partial_arg$1 = [
    b,
    a,
    min_key_lhs
  ];
  var do_key_b = function (param) {
    return do_key(partial_arg$1, param);
  };
  for_in(a, do_key_a);
  for_in(b, do_key_b);
  var match = min_key_lhs.contents;
  var match$1 = min_key_rhs.contents;
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return Caml.caml_string_compare(match, match$1);
    } else {
      return -1;
    }
  } else if (match$1 !== undefined) {
    return 1;
  } else {
    return 0;
  }
}

function caml_equal(a, b) {
  if (a === b) {
    return true;
  }
  var a_type = typeof a;
  if (a_type === "string" || a_type === "number" || a_type === "bigint" || a_type === "boolean" || a_type === "undefined" || a === null) {
    return false;
  }
  var b_type = typeof b;
  if (a_type === "function" || b_type === "function") {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "equal: functional value",
          Error: new Error()
        };
  }
  if (b_type === "number" || b_type === "bigint" || b_type === "undefined" || b === null) {
    return false;
  }
  var tag_a = a.TAG | 0;
  var tag_b = b.TAG | 0;
  if (tag_a === 248) {
    return a[1] === b[1];
  }
  if (tag_a === 251) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "equal: abstract value",
          Error: new Error()
        };
  }
  if (tag_a !== tag_b) {
    return false;
  }
  var len_a = a.length | 0;
  var len_b = b.length | 0;
  if (len_a === len_b) {
    if (Array.isArray(a)) {
      var _i = 0;
      while(true) {
        var i = _i;
        if (i === len_a) {
          return true;
        }
        if (!caml_equal(a[i], b[i])) {
          return false;
        }
        _i = i + 1 | 0;
        continue ;
      };
    } else if ((a instanceof Date && b instanceof Date)) {
      return !(a > b || a < b);
    } else {
      var result = {
        contents: true
      };
      var do_key_a = function (key) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) {
          result.contents = false;
          return ;
        }
        
      };
      var do_key_b = function (key) {
        if (!Object.prototype.hasOwnProperty.call(a, key) || !caml_equal(b[key], a[key])) {
          result.contents = false;
          return ;
        }
        
      };
      for_in(a, do_key_a);
      if (result.contents) {
        for_in(b, do_key_b);
      }
      return result.contents;
    }
  } else {
    return false;
  }
}

function caml_equal_null(x, y) {
  if (y !== null) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_undefined(x, y) {
  if (y !== undefined) {
    return caml_equal(x, y);
  } else {
    return x === y;
  }
}

function caml_equal_nullable(x, y) {
  if (y == null) {
    return x === y;
  } else {
    return caml_equal(x, y);
  }
}

function caml_notequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a !== b;
  } else {
    return !caml_equal(a, b);
  }
}

function caml_greaterequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a >= b;
  } else {
    return caml_compare(a, b) >= 0;
  }
}

function caml_greaterthan(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a > b;
  } else {
    return caml_compare(a, b) > 0;
  }
}

function caml_lessequal(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a <= b;
  } else {
    return caml_compare(a, b) <= 0;
  }
}

function caml_lessthan(a, b) {
  if ((typeof a === "number" || typeof a === "bigint") && (typeof b === "number" || typeof b === "bigint")) {
    return a < b;
  } else {
    return caml_compare(a, b) < 0;
  }
}

function caml_min(x, y) {
  if (caml_compare(x, y) <= 0) {
    return x;
  } else {
    return y;
  }
}

function caml_max(x, y) {
  if (caml_compare(x, y) >= 0) {
    return x;
  } else {
    return y;
  }
}

export {
  caml_obj_dup ,
  update_dummy ,
  caml_compare ,
  caml_equal ,
  caml_equal_null ,
  caml_equal_undefined ,
  caml_equal_nullable ,
  caml_notequal ,
  caml_greaterequal ,
  caml_greaterthan ,
  caml_lessthan ,
  caml_lessequal ,
  caml_min ,
  caml_max ,
}
/* No side effect */
`,wc=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Js__Caml_exceptions from "./caml_exceptions.js";

var caml_methods_cache = Caml_array.make(1000, 0);

function caml_set_oo_id(b) {
  b[1] = Js__Caml_exceptions.id.contents;
  Js__Caml_exceptions.id.contents = Js__Caml_exceptions.id.contents + 1 | 0;
  return b;
}

function caml_get_public_method(obj, tag, cacheid) {
  var meths = obj[0];
  var offs = caml_methods_cache[cacheid];
  if (meths[offs] === tag) {
    return meths[offs - 1 | 0];
  }
  var aux = function (_i) {
    while(true) {
      var i = _i;
      if (i < 3) {
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/runtime/caml_oo.ml",
                66,
                20
              ],
              Error: new Error()
            };
      }
      if (meths[i] === tag) {
        caml_methods_cache[cacheid] = i;
        return i;
      }
      _i = i - 2 | 0;
      continue ;
    };
  };
  return meths[aux((meths[0] << 1) + 1 | 0) - 1 | 0];
}

export {
  caml_get_public_method ,
  caml_set_oo_id ,
}
/* No side effect */
`,Cc=`// Generated by Melange

import * as Js__Caml_oo from "./caml_oo.js";
import * as Js__Curry from "./curry.js";

function js(label, cacheid, obj, args) {
  var meth = Js__Caml_oo.caml_get_public_method(obj, label, cacheid);
  return Js__Curry.app(meth, args);
}

function js1(label, cacheid, a0) {
  return Js__Curry._1(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0);
}

function js2(label, cacheid, a0, a1) {
  return Js__Curry._2(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1);
}

function js3(label, cacheid, a0, a1, a2) {
  return Js__Curry._3(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2);
}

function js4(label, cacheid, a0, a1, a2, a3) {
  return Js__Curry._4(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3);
}

function js5(label, cacheid, a0, a1, a2, a3, a4) {
  return Js__Curry._5(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4);
}

function js6(label, cacheid, a0, a1, a2, a3, a4, a5) {
  return Js__Curry._6(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5);
}

function js7(label, cacheid, a0, a1, a2, a3, a4, a5, a6) {
  return Js__Curry._7(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6);
}

function js8(label, cacheid, a0, a1, a2, a3, a4, a5, a6, a7) {
  return Js__Curry._8(Js__Caml_oo.caml_get_public_method(a0, label, cacheid), a0, a1, a2, a3, a4, a5, a6, a7);
}

export {
  js ,
  js1 ,
  js2 ,
  js3 ,
  js4 ,
  js5 ,
  js6 ,
  js7 ,
  js8 ,
}
/* No side effect */
`,Sc=`// Generated by Melange


function isNested(x) {
  return x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined;
}

function some(x) {
  if (x === undefined) {
    return {
            MEL_PRIVATE_NESTED_SOME_NONE: 0
          };
  } else if (x !== null && x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {
    return {
            MEL_PRIVATE_NESTED_SOME_NONE: x.MEL_PRIVATE_NESTED_SOME_NONE + 1 | 0
          };
  } else {
    return x;
  }
}

function nullable_to_opt(x) {
  if (x == null) {
    return ;
  } else {
    return some(x);
  }
}

function undefined_to_opt(x) {
  if (x === undefined) {
    return ;
  } else {
    return some(x);
  }
}

function null_to_opt(x) {
  if (x === null) {
    return ;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x.MEL_PRIVATE_NESTED_SOME_NONE !== undefined)) {
    return x;
  }
  var depth = x.MEL_PRIVATE_NESTED_SOME_NONE;
  if (depth === 0) {
    return ;
  } else {
    return {
            MEL_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0
          };
  }
}

function option_get(x) {
  if (x === undefined) {
    return ;
  } else {
    return valFromOption(x);
  }
}

function option_unwrap(x) {
  if (x !== undefined) {
    return x.VAL;
  } else {
    return x;
  }
}

export {
  nullable_to_opt ,
  undefined_to_opt ,
  null_to_opt ,
  valFromOption ,
  some ,
  isNested ,
  option_get ,
  option_unwrap ,
}
/* No side effect */
`,Ac=`// Generated by Melange


/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: parsing.c 8983 2008-08-06 09:38:25Z xleroy $ */

/* The PDA automaton for parsers generated by camlyacc */

/* The pushdown automata */

/**
 * caml_lex_array("abcd")
 * [25185, 25699]
 * @param s
 * @returns {any[]}
 * TODO: duplicated with module {!Caml_lex}
 */
function caml_lex_array(s) {
    var l = s.length / 2;
    var a = new Array(l);
    for (var i = 0; i < l; i++)
        a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;
    return a;
}
/**
 * Note that TS enum is not friendly to Closure compiler
 * @enum{number}
 */
var Automata = {
    START: 0,
    LOOP: 6,
    TOKEN_READ: 1,
    TEST_SHIFT: 7,
    ERROR_DETECTED: 5,
    SHIFT: 8,
    SHIFT_RECOVER: 9,
    STACK_GROWN_1: 2,
    REDUCE: 10,
    STACK_GROWN_2: 3,
    SEMANTIC_ACTION_COMPUTED: 4
};
/**
 * @enum{number}
 */
var Result = {
    READ_TOKEN: 0,
    RAISE_PARSE_ERROR: 1,
    GROW_STACKS_1: 2,
    GROW_STACKS_2: 3,
    COMPUTE_SEMANTIC_ACTION: 4,
    CALL_ERROR_FUNCTION: 5
};
var PARSER_TRACE = false;
;

var caml_parse_engine = (function (tables /* parser_table */, env /* parser_env */, cmd /* parser_input*/, arg /* Obj.t*/) {
    var ERRCODE = 256;
    //var START = 0;
    //var TOKEN_READ = 1;
    //var STACKS_GROWN_1 = 2;
    //var STACKS_GROWN_2 = 3;
    //var SEMANTIC_ACTION_COMPUTED = 4;
    //var ERROR_DETECTED = 5;
    //var loop = 6;
    //var testshift = 7;
    //var shift = 8;
    //var shift_recover = 9;
    //var reduce = 10;
    // Parsing.parser_env
    var env_s_stack = 's_stack'; // array
    var env_v_stack = 'v_stack'; // array
    var env_symb_start_stack = 'symb_start_stack'; // array
    var env_symb_end_stack = 'symb_end_stack'; // array
    var env_stacksize = 'stacksize';
    var env_stackbase = 'stackbase';
    var env_curr_char = 'curr_char';
    var env_lval = 'lval'; // Obj.t
    var env_symb_start = 'symb_start'; // position
    var env_symb_end = 'symb_end'; // position
    var env_asp = 'asp';
    var env_rule_len = 'rule_len';
    var env_rule_number = 'rule_number';
    var env_sp = 'sp';
    var env_state = 'state';
    var env_errflag = 'errflag';
    // Parsing.parse_tables
    // var _tbl_actions = 1;
    var tbl_transl_const = 'transl_const'; // array
    var tbl_transl_block = 'transl_block'; // array
    var tbl_lhs = 'lhs';
    var tbl_len = 'len';
    var tbl_defred = 'defred';
    var tbl_dgoto = 'dgoto';
    var tbl_sindex = 'sindex';
    var tbl_rindex = 'rindex';
    var tbl_gindex = 'gindex';
    var tbl_tablesize = 'tablesize';
    var tbl_table = 'table';
    var tbl_check = 'check';
    // var _tbl_error_function = 14;
    // var _tbl_names_const = 15;
    // var _tbl_names_block = 16;
    if (!tables.preprocessed) {
        tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
        tables.preprocessed = true;
    }
    var res;
    var n, n1, n2, state1;
    // RESTORE
    var sp = env[env_sp];
    var state = env[env_state];
    var errflag = env[env_errflag];
    exit: for (;;) {
        //console.error("State", Automata[cmd]);
        switch (cmd) {
            case Automata.START:
                state = 0;
                errflag = 0;
            // Fall through
            case Automata.LOOP:
                n = tables.defred[state];
                if (n != 0) {
                    cmd = Automata.REDUCE;
                    break;
                }
                if (env[env_curr_char] >= 0) {
                    cmd = Automata.TEST_SHIFT;
                    break;
                }
                res = Result.READ_TOKEN;
                break exit;
            /* The ML code calls the lexer and updates */
            /* symb_start and symb_end */
            case Automata.TOKEN_READ:
                if (typeof arg !== 'number') {
                    env[env_curr_char] = tables[tbl_transl_block][arg.TAG | 0 /* + 1 */];
                    env[env_lval] = arg._0; // token carries payload
                }
                else {
                    env[env_curr_char] = tables[tbl_transl_const][arg /* + 1 */];
                    env[env_lval] = 0; // const token
                }
                if (PARSER_TRACE) {
                    console.error("State %d, read token", state, arg);
                }
            // Fall through
            case Automata.TEST_SHIFT:
                n1 = tables.sindex[state];
                n2 = n1 + env[env_curr_char];
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == env[env_curr_char]) {
                    cmd = Automata.SHIFT;
                    break;
                }
                n1 = tables.rindex[state];
                n2 = n1 + env[env_curr_char];
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == env[env_curr_char]) {
                    n = tables.table[n2];
                    cmd = Automata.REDUCE;
                    break;
                }
                if (errflag <= 0) {
                    res = Result.CALL_ERROR_FUNCTION;
                    break exit;
                }
            // Fall through
            /* The ML code calls the error function */
            case Automata.ERROR_DETECTED:
                if (errflag < 3) {
                    errflag = 3;
                    for (;;) {
                        state1 = env[env_s_stack][sp /* + 1*/];
                        n1 = tables.sindex[state1];
                        n2 = n1 + ERRCODE;
                        if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                            tables.check[n2] == ERRCODE) {
                            cmd = Automata.SHIFT_RECOVER;
                            break;
                        }
                        else {
                            if (sp <= env[env_stackbase])
                                return Result.RAISE_PARSE_ERROR;
                            /* The ML code raises Parse_error */
                            sp--;
                        }
                    }
                }
                else {
                    if (env[env_curr_char] == 0)
                        return Result.RAISE_PARSE_ERROR;
                    /* The ML code raises Parse_error */
                    env[env_curr_char] = -1;
                    cmd = Automata.LOOP;
                    break;
                }
            // Fall through
            case Automata.SHIFT:
                env[env_curr_char] = -1;
                if (errflag > 0)
                    errflag--;
            // Fall through
            case Automata.SHIFT_RECOVER:
                if (PARSER_TRACE) {
                    console.error("State %d: shift to state %d", state, tables.table[n2]);
                }
                state = tables.table[n2];
                sp++;
                if (sp >= env[env_stacksize]) {
                    res = Result.GROW_STACKS_1;
                    break exit;
                }
            // Fall through
            /* The ML code resizes the stacks */
            case Automata.STACK_GROWN_1:
                env[env_s_stack][sp /* + 1 */] = state;
                env[env_v_stack][sp /* + 1 */] = env[env_lval];
                env[env_symb_start_stack][sp /* + 1 */] = env[env_symb_start];
                env[env_symb_end_stack][sp /* + 1 */] = env[env_symb_end];
                cmd = Automata.LOOP;
                break;
            case Automata.REDUCE:
                if (PARSER_TRACE) {
                    console.error("State %d : reduce by rule %d", state, n);
                }
                var m = tables.len[n];
                env[env_asp] = sp;
                env[env_rule_number] = n;
                env[env_rule_len] = m;
                sp = sp - m + 1;
                m = tables.lhs[n];
                state1 = env[env_s_stack][sp - 1]; //
                n1 = tables.gindex[m];
                n2 = n1 + state1;
                if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&
                    tables.check[n2] == state1)
                    state = tables.table[n2];
                else
                    state = tables.dgoto[m];
                if (sp >= env[env_stacksize]) {
                    res = Result.GROW_STACKS_2;
                    break exit;
                }
            // Fall through
            /* The ML code resizes the stacks */
            case Automata.STACK_GROWN_2:
                res = Result.COMPUTE_SEMANTIC_ACTION;
                break exit;
            /* The ML code calls the semantic action */
            case Automata.SEMANTIC_ACTION_COMPUTED:
                env[env_s_stack][sp /* + 1 */] = state;
                env[env_v_stack][sp /* + 1*/] = arg;
                var asp = env[env_asp];
                env[env_symb_end_stack][sp /* + 1*/] = env[env_symb_end_stack][asp /* + 1*/];
                if (sp > asp) {
                    /* This is an epsilon production. Take symb_start equal to symb_end. */
                    env[env_symb_start_stack][sp /* + 1*/] = env[env_symb_end_stack][asp /*+ 1*/];
                }
                cmd = Automata.LOOP;
                break;
            /* Should not happen */
            default:
                return Result.RAISE_PARSE_ERROR;
        }
    }
    // SAVE
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
});

var caml_set_parser_trace = (function (v) {
    var old = PARSER_TRACE;
    PARSER_TRACE = v;
    return old;
});

export {
  caml_parse_engine ,
  caml_set_parser_trace ,
}
/*  Not a pure module */
`,Ic=`// Generated by Melange


var spliceApply = (function(fn,args){
  var i, argLen;
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return fn.apply(null,applied)
});

var spliceNewApply = (function (ctor,args){
  var i, argLen;
  argLen = args.length
  var applied = [null] // Function.prototype.bind.apply(fn, args) requires the first element in \`args\` to be \`null\`
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  var C = Function.prototype.bind.apply(ctor, applied)
  return new C()
});

var spliceObjApply = (function(obj,name,args){
  var i, argLen;
  argLen = args.length
  var applied = []
  for(i = 0; i < argLen - 1; ++i){
    applied.push(args[i])
  }
  var lastOne = args[argLen - 1]
  for(i = 0; i < lastOne.length; ++i ){
    applied.push(lastOne[i])
  }
  return (obj[name]).apply(obj,applied)
});

export {
  spliceApply ,
  spliceNewApply ,
  spliceObjApply ,
}
/* No side effect */
`,Nc=`// Generated by Melange


function get(s, i) {
  if (i >= s.length || i < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  return s.charCodeAt(i);
}

function make(n, ch) {
  return String.fromCharCode(ch).repeat(n);
}

export {
  get ,
  make ,
}
/* No side effect */
`,Tc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,jc=`// Generated by Melange


function caml_sys_getenv(s) {
  if (typeof process === "undefined" || process.env === undefined) {
    throw {
          MEL_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var x = process.env[s];
  if (x !== undefined) {
    return x;
  }
  throw {
        MEL_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var os_type = (function(_){
  if(typeof process !== 'undefined' && process.platform === 'win32'){
        return "Win32"
  }
  else {
    return "Unix"
  }
});

function caml_sys_time(param) {
  if (typeof process === "undefined" || process.uptime === undefined) {
    return -1;
  } else {
    return process.uptime();
  }
}

function caml_sys_system_command(_cmd) {
  return 127;
}

var caml_sys_getcwd = (function(param){
    if (typeof process === "undefined" || process.cwd === undefined){
      return "/"
    }
    return process.cwd()
  });

function caml_sys_executable_name(param) {
  if (typeof process === "undefined") {
    return "";
  }
  var argv = process.argv;
  if (argv == null) {
    return "";
  } else {
    return argv[0];
  }
}

function caml_sys_argv(param) {
  if (typeof process === "undefined") {
    return [""];
  }
  var argv = process.argv;
  if (argv == null) {
    return [""];
  } else {
    return argv;
  }
}

function caml_sys_exit(exit_code) {
  if (typeof process !== "undefined") {
    return process.exit(exit_code);
  }
  
}

function caml_sys_is_directory(_s) {
  throw {
        MEL_EXN_ID: "Failure",
        _1: "caml_sys_is_directory not implemented",
        Error: new Error()
      };
}

function caml_sys_file_exists(_s) {
  throw {
        MEL_EXN_ID: "Failure",
        _1: "caml_sys_file_exists not implemented",
        Error: new Error()
      };
}

export {
  caml_sys_getenv ,
  caml_sys_time ,
  os_type ,
  caml_sys_system_command ,
  caml_sys_getcwd ,
  caml_sys_executable_name ,
  caml_sys_argv ,
  caml_sys_exit ,
  caml_sys_is_directory ,
  caml_sys_file_exists ,
}
/* No side effect */
`,Lc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Mc=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var init_arity = f.length;
    var arity = init_arity === 0 ? 1 : init_arity;
    var len = args.length;
    var d = arity - len | 0;
    if (d === 0) {
      return f.apply(null, args);
    }
    if (d >= 0) {
      return (function(f,args){
      return function (x) {
        return app(f, args.concat([x]));
      }
      }(f,args));
    }
    _args = Caml_array.sub(args, arity, -d | 0);
    _f = f.apply(null, Caml_array.sub(args, 0, arity));
    continue ;
  };
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    switch (arity) {
      case 1 :
          return o(a0);
      case 2 :
          return function (param) {
            return o(a0, param);
          };
      case 3 :
          return function (param, param$1) {
            return o(a0, param, param$1);
          };
      case 4 :
          return function (param, param$1, param$2) {
            return o(a0, param, param$1, param$2);
          };
      case 5 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, param, param$1, param$2, param$3);
          };
      case 6 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, param, param$1, param$2, param$3, param$4);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4, param$5) {
            return o(a0, param, param$1, param$2, param$3, param$4, param$5);
          };
      default:
        return app(o, [a0]);
    }
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return function (a0) {
      return _1(o, a0);
    };
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [a1]);
      case 2 :
          return o(a0, a1);
      case 3 :
          return function (param) {
            return o(a0, a1, param);
          };
      case 4 :
          return function (param, param$1) {
            return o(a0, a1, param, param$1);
          };
      case 5 :
          return function (param, param$1, param$2) {
            return o(a0, a1, param, param$1, param$2);
          };
      case 6 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, param, param$1, param$2, param$3);
          };
      case 7 :
          return function (param, param$1, param$2, param$3, param$4) {
            return o(a0, a1, param, param$1, param$2, param$3, param$4);
          };
      default:
        return app(o, [
                    a0,
                    a1
                  ]);
    }
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return function (a0, a1) {
      return _2(o, a0, a1);
    };
  }
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2
                    ]);
      case 2 :
          return app(o(a0, a1), [a2]);
      case 3 :
          return o(a0, a1, a2);
      case 4 :
          return function (param) {
            return o(a0, a1, a2, param);
          };
      case 5 :
          return function (param, param$1) {
            return o(a0, a1, a2, param, param$1);
          };
      case 6 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, param, param$1, param$2);
          };
      case 7 :
          return function (param, param$1, param$2, param$3) {
            return o(a0, a1, a2, param, param$1, param$2, param$3);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2
                  ]);
    }
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return function (a0, a1, a2) {
      return _3(o, a0, a1, a2);
    };
  }
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [a3]);
      case 4 :
          return o(a0, a1, a2, a3);
      case 5 :
          return function (param) {
            return o(a0, a1, a2, a3, param);
          };
      case 6 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, param, param$1);
          };
      case 7 :
          return function (param, param$1, param$2) {
            return o(a0, a1, a2, a3, param, param$1, param$2);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3
                  ]);
    }
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return function (a0, a1, a2, a3) {
      return _4(o, a0, a1, a2, a3);
    };
  }
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [a4]);
      case 5 :
          return o(a0, a1, a2, a3, a4);
      case 6 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, param);
          };
      case 7 :
          return function (param, param$1) {
            return o(a0, a1, a2, a3, a4, param, param$1);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4
                  ]);
    }
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4) {
      return _5(o, a0, a1, a2, a3, a4);
    };
  }
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [a5]);
      case 6 :
          return o(a0, a1, a2, a3, a4, a5);
      case 7 :
          return function (param) {
            return o(a0, a1, a2, a3, a4, a5, param);
          };
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5
                  ]);
    }
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5) {
      return _6(o, a0, a1, a2, a3, a4, a5);
    };
  }
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [a6]);
      case 7 :
          return o(a0, a1, a2, a3, a4, a5, a6);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6
                  ]);
    }
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6) {
      return _7(o, a0, a1, a2, a3, a4, a5, a6);
    };
  }
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    switch (arity) {
      case 1 :
          return app(o(a0), [
                      a1,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 2 :
          return app(o(a0, a1), [
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 :
          return app(o(a0, a1, a2), [
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 :
          return app(o(a0, a1, a2, a3), [
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 :
          return app(o(a0, a1, a2, a3, a4), [
                      a5,
                      a6,
                      a7
                    ]);
      case 6 :
          return app(o(a0, a1, a2, a3, a4, a5), [
                      a6,
                      a7
                    ]);
      case 7 :
          return app(o(a0, a1, a2, a3, a4, a5, a6), [a7]);
      default:
        return app(o, [
                    a0,
                    a1,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7
                  ]);
    }
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return function (a0, a1, a2, a3, a4, a5, a6, a7) {
      return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
    };
  }
}

export {
  app ,
  _1 ,
  __1 ,
  _2 ,
  __2 ,
  _3 ,
  __3 ,
  _4 ,
  __4 ,
  _5 ,
  __5 ,
  _6 ,
  __6 ,
  _7 ,
  __7 ,
  _8 ,
  __8 ,
}
/* No side effect */
`,Dc=`// Generated by Melange

import * as Js__Js_OO from "./js_OO.js";
import * as Js__Js_internal from "./js_internal.js";

var Obj = {};

var Js_OO = Js__Js_OO;

var Private = {
  Js_OO: Js_OO
};

var Fn = Js__Js_internal.Fn;

var Internal = Js__Js_internal.Internal;

export {
  Fn ,
  Internal ,
  Obj ,
  Private ,
}
/* No side effect */
`,Pc=`// Generated by Melange


var Callback = {};

var Meth = {};

var Internal = {};

export {
  Callback ,
  Meth ,
  Internal ,
}
/* No side effect */
`,Oc=`// Generated by Melange


var Js__ = {};

export {
  Js__ ,
}
/* No side effect */
`,zc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Fc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Bc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Gc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Rc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,qc=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function get(dict, k) {
  if ((k in dict)) {
    return Caml_option.some(dict[k]);
  }
  
}

var unsafeDeleteKey = (function (dict,key){
      delete dict[key];
     });

function entries(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = new Array(l);
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    values[i] = [
      key,
      dict[key]
    ];
  }
  return values;
}

function values(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values$1 = new Array(l);
  for(var i = 0; i < l; ++i){
    values$1[i] = dict[keys[i]];
  }
  return values$1;
}

function fromList(entries) {
  var dict = {};
  var _param = entries;
  while(true) {
    var param = _param;
    if (!param) {
      return dict;
    }
    var match = param.hd;
    dict[match[0]] = match[1];
    _param = param.tl;
    continue ;
  };
}

function fromArray(entries) {
  var dict = {};
  var l = entries.length;
  for(var i = 0; i < l; ++i){
    var match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

function map(f, source) {
  var target = {};
  var keys = Object.keys(source);
  var l = keys.length;
  for(var i = 0; i < l; ++i){
    var key = keys[i];
    target[key] = f(source[key]);
  }
  return target;
}

export {
  get ,
  unsafeDeleteKey ,
  entries ,
  values ,
  fromList ,
  fromArray ,
  map ,
}
/* No side effect */
`,Vc=`// Generated by Melange

import * as Js__Caml_js_exceptions from "./caml_js_exceptions.js";

var anyToExnInternal = Js__Caml_js_exceptions.internalToOCamlException;

function raiseError(str) {
  throw new Error(str);
}

function raiseEvalError(str) {
  throw new EvalError(str);
}

function raiseRangeError(str) {
  throw new RangeError(str);
}

function raiseReferenceError(str) {
  throw new ReferenceError(str);
}

function raiseSyntaxError(str) {
  throw new SyntaxError(str);
}

function raiseTypeError(str) {
  throw new TypeError(str);
}

function raiseUriError(str) {
  throw new URIError(str);
}

var $$Error$1 = Js__Caml_js_exceptions.$$Error;

export {
  $$Error$1 as $$Error,
  anyToExnInternal ,
  raiseError ,
  raiseEvalError ,
  raiseRangeError ,
  raiseReferenceError ,
  raiseSyntaxError ,
  raiseTypeError ,
  raiseUriError ,
}
/* No side effect */
`,Xc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Uc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Hc=`// Generated by Melange


function equal(x, y) {
  return x === y;
}

var max = 2147483647;

var min = -2147483648;

export {
  equal ,
  max ,
  min ,
}
/* No side effect */
`,Wc=`// Generated by Melange


var Fn = {};

var Internal = {};

export {
  Fn ,
  Internal ,
}
/* No side effect */
`,Jc=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function classify(x) {
  var ty = typeof x;
  if (ty === "string") {
    return {
            TAG: /* JSONString */0,
            _0: x
          };
  } else if (ty === "number") {
    return {
            TAG: /* JSONNumber */1,
            _0: x
          };
  } else if (ty === "boolean") {
    if (x === true) {
      return /* JSONTrue */1;
    } else {
      return /* JSONFalse */0;
    }
  } else if (x === null) {
    return /* JSONNull */2;
  } else if (Array.isArray(x)) {
    return {
            TAG: /* JSONArray */3,
            _0: x
          };
  } else {
    return {
            TAG: /* JSONObject */2,
            _0: x
          };
  }
}

function test(x, v) {
  switch (v) {
    case /* String */0 :
        return typeof x === "string";
    case /* Number */1 :
        return typeof x === "number";
    case /* Object */2 :
        if (x !== null && typeof x === "object") {
          return !Array.isArray(x);
        } else {
          return false;
        }
    case /* Array */3 :
        return Array.isArray(x);
    case /* Boolean */4 :
        return typeof x === "boolean";
    case /* Null */5 :
        return x === null;
    
  }
}

function decodeString(json) {
  if (typeof json === "string") {
    return json;
  }
  
}

function decodeNumber(json) {
  if (typeof json === "number") {
    return json;
  }
  
}

function decodeObject(json) {
  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
    return Caml_option.some(json);
  }
  
}

function decodeArray(json) {
  if (Array.isArray(json)) {
    return json;
  }
  
}

function decodeBoolean(json) {
  if (typeof json === "boolean") {
    return json;
  }
  
}

function decodeNull(json) {
  if (json === null) {
    return null;
  }
  
}

var patch = (function (json) {
  var x = [json];
  var q = [{ kind: 0, i: 0, parent: x }];
  while (q.length !== 0) {
    // begin pop the stack
    var cur = q[q.length - 1];
    if (cur.kind === 0) {
      cur.val = cur.parent[cur.i]; // patch the undefined value for array
      if (++cur.i === cur.parent.length) {
        q.pop();
      }
    } else {
      q.pop();
    }
    // finish
    var task = cur.val;
    if (typeof task === "object") {
      if (Array.isArray(task) && task.length !== 0) {
        q.push({ kind: 0, i: 0, parent: task, val: undefined });
      } else {
        for (var k in task) {
          if (k === "RE_PRIVATE_NONE") {
            if (cur.kind === 0) {
              cur.parent[cur.i - 1] = undefined;
            } else {
              cur.parent[cur.i] = undefined;
            }
            continue;
          }
          q.push({ kind: 1, i: k, parent: task, val: task[k] });
        }
      }
    }
  }
  return x[0];
});

function serializeExn(x) {
  return (function(obj){
  var output= JSON.stringify(obj,function(_,value){
      if(value===undefined){
          return {RE_PRIVATE_NONE : true}
      }
    return value
  });

 if(output === undefined){
   // JSON.stringify will raise TypeError when it detects cylic objects
   throw new TypeError("output is undefined")
 }
 return output
 })(x);
}

function deserializeUnsafe(s) {
  return patch(JSON.parse(s));
}

export {
  classify ,
  test ,
  decodeString ,
  decodeNumber ,
  decodeObject ,
  decodeArray ,
  decodeBoolean ,
  decodeNull ,
  deserializeUnsafe ,
  serializeExn ,
}
/* No side effect */
`,Kc=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Yc=`// Generated by Melange


function raiseWhenNotFound(x) {
  if (x == null) {
    throw {
          MEL_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  return x;
}

function fromInt(len, xs, $$enum) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      return ;
    }
    var k = xs[i];
    if (k === $$enum) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function fromIntAssert(len, xs, $$enum) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === len) {
      throw {
            MEL_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    var k = xs[i];
    if (k === $$enum) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

export {
  raiseWhenNotFound ,
  fromInt ,
  fromIntAssert ,
}
/* No side effect */
`,Zc=`// Generated by Melange

import * as Js__Js_int from "./js_int.js";

function unsafe_ceil(prim) {
  return Math.ceil(prim);
}

function ceil_int(f) {
  if (f > Js__Js_int.max) {
    return Js__Js_int.max;
  } else if (f < Js__Js_int.min) {
    return Js__Js_int.min;
  } else {
    return Math.ceil(f);
  }
}

function unsafe_floor(prim) {
  return Math.floor(prim);
}

function floor_int(f) {
  if (f > Js__Js_int.max) {
    return Js__Js_int.max;
  } else if (f < Js__Js_int.min) {
    return Js__Js_int.min;
  } else {
    return Math.floor(f);
  }
}

function random_int(min, max) {
  return floor_int(Math.random() * (max - min | 0)) + min | 0;
}

var ceil = ceil_int;

var floor = floor_int;

export {
  unsafe_ceil ,
  ceil_int ,
  ceil ,
  unsafe_floor ,
  floor_int ,
  floor ,
  random_int ,
}
/* No side effect */
`,Qc=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function test(x) {
  return x === null;
}

function getExn(f) {
  if (f !== null) {
    return f;
  }
  throw new Error("Js.Null.getExn");
}

function bind(x, f) {
  if (x !== null) {
    return f(x);
  } else {
    return null;
  }
}

function iter(x, f) {
  if (x !== null) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return null;
  }
}

var from_opt = fromOption;

export {
  test ,
  getExn ,
  bind ,
  iter ,
  fromOption ,
  from_opt ,
}
/* No side effect */
`,nu=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function bind(x, f) {
  if (x == null) {
    return x;
  } else {
    return f(x);
  }
}

function iter(x, f) {
  if (!(x == null)) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  
}

var from_opt = fromOption;

export {
  bind ,
  iter ,
  fromOption ,
  from_opt ,
}
/* No side effect */
`,tu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,eu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,ru=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,au=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,iu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,su=`// Generated by Melange


var $$ArrayBuffer = {};

var $$Int8Array = {};

var $$Uint8Array = {};

var $$Uint8ClampedArray = {};

var $$Int16Array = {};

var $$Uint16Array = {};

var $$Int32Array = {};

var $$Uint32Array = {};

var $$Float32Array = {};

var $$Float64Array = {};

var $$DataView = {};

export {
  $$ArrayBuffer ,
  $$Int8Array ,
  $$Uint8Array ,
  $$Uint8ClampedArray ,
  $$Int16Array ,
  $$Uint16Array ,
  $$Int32Array ,
  $$Uint32Array ,
  $$Float32Array ,
  $$Float64Array ,
  $$DataView ,
}
/* No side effect */
`,ou=`// Generated by Melange


var $$ArrayBuffer = {};

var $$Int8Array = {};

var $$Uint8Array = {};

var $$Uint8ClampedArray = {};

var $$Int16Array = {};

var $$Uint16Array = {};

var $$Int32Array = {};

var $$Uint32Array = {};

var $$Float32Array = {};

var $$Float64Array = {};

var $$DataView = {};

export {
  $$ArrayBuffer ,
  $$Int8Array ,
  $$Uint8Array ,
  $$Uint8ClampedArray ,
  $$Int16Array ,
  $$Uint16Array ,
  $$Int32Array ,
  $$Uint32Array ,
  $$Float32Array ,
  $$Float64Array ,
  $$DataView ,
}
/* No side effect */
`,_u=`// Generated by Melange


function classify(x) {
  var ty = typeof x;
  if (ty === "undefined") {
    return /* JSUndefined */3;
  } else if (x === null) {
    return /* JSNull */2;
  } else if (ty === "number") {
    return {
            TAG: /* JSNumber */0,
            _0: x
          };
  } else if (ty === "bigint") {
    return {
            TAG: /* JSBigInt */5,
            _0: x
          };
  } else if (ty === "string") {
    return {
            TAG: /* JSString */1,
            _0: x
          };
  } else if (ty === "boolean") {
    if (x === true) {
      return /* JSTrue */1;
    } else {
      return /* JSFalse */0;
    }
  } else if (ty === "symbol") {
    return {
            TAG: /* JSSymbol */4,
            _0: x
          };
  } else if (ty === "function") {
    return {
            TAG: /* JSFunction */2,
            _0: x
          };
  } else {
    return {
            TAG: /* JSObject */3,
            _0: x
          };
  }
}

function test(x, v) {
  switch (v) {
    case /* Undefined */0 :
        return typeof x === "undefined";
    case /* Null */1 :
        return x === null;
    case /* Boolean */2 :
        return typeof x === "boolean";
    case /* Number */3 :
        return typeof x === "number";
    case /* String */4 :
        return typeof x === "string";
    case /* Function */5 :
        return typeof x === "function";
    case /* Object */6 :
        return typeof x === "object";
    case /* Symbol */7 :
        return typeof x === "symbol";
    case /* BigInt */8 :
        return typeof x === "bigint";
    
  }
}

export {
  test ,
  classify ,
}
/* No side effect */
`,lu=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";

function test(x) {
  return x === undefined;
}

function testAny(x) {
  return x === undefined;
}

function getExn(f) {
  if (f !== undefined) {
    return f;
  }
  throw new Error("Js.Undefined.getExn");
}

function bind(x, f) {
  if (x !== undefined) {
    return f(x);
  }
  
}

function iter(x, f) {
  if (x !== undefined) {
    return f(x);
  }
  
}

function fromOption(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  
}

var from_opt = fromOption;

export {
  test ,
  testAny ,
  getExn ,
  bind ,
  iter ,
  fromOption ,
  from_opt ,
}
/* No side effect */
`,cu=`// Generated by Melange


function filterInPlace(p, a) {
  var i = 0;
  var j = 0;
  while(i < a.length) {
    var v = a[i];
    if (p(v)) {
      a[j] = v;
      j = j + 1 | 0;
    }
    i = i + 1 | 0;
  };
  a.splice(j);
}

function empty(a) {
  a.splice(0);
}

function pushBack(x, xs) {
  xs.push(x);
}

function memByRef(x, xs) {
  return xs.indexOf(x) >= 0;
}

function iter(f, xs) {
  for(var i = 0 ,i_finish = xs.length; i < i_finish; ++i){
    f(xs[i]);
  }
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    f(i, a[i]);
  }
}

function toList(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function init(n, f) {
  var v = new Array(n);
  for(var i = 0; i < n; ++i){
    v[i] = f(i);
  }
  return v;
}

function copy(x) {
  var len = x.length;
  var b = new Array(len);
  for(var i = 0; i < len; ++i){
    b[i] = x[i];
  }
  return b;
}

function map(f, a) {
  var l = a.length;
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(a[i]);
  }
  return r;
}

function foldLeft(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = f(r, a[i]);
  }
  return r;
}

function foldRight(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = f(a[i], r);
  }
  return r;
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = new Array(l);
  for(var i = 0; i < l; ++i){
    r[i] = f(i, a[i]);
  }
  return r;
}

function append(x, a) {
  return a.concat([x]);
}

export {
  filterInPlace ,
  empty ,
  pushBack ,
  copy ,
  memByRef ,
  iter ,
  iteri ,
  toList ,
  map ,
  mapi ,
  foldLeft ,
  foldRight ,
  init ,
  append ,
}
/* No side effect */
`,uu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,fu=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,mu=`// Generated by Melange


var Obj = {};

var Pervasives = {};

export {
  Obj ,
  Pervasives ,
}
/* No side effect */
`,pu=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__String from "./string.js";

var Bad = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Bad");

var Help = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Help");

var Stop = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Stop");

function assoc3(x, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var match = l.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _l = l.tl;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

function split(s) {
  var i = Stdlib__String.index(s, /* '=' */61);
  var len = s.length;
  return [
          Stdlib__String.sub(s, 0, i),
          Stdlib__String.sub(s, i + 1 | 0, len - (i + 1 | 0) | 0)
        ];
}

function make_symlist(prefix, sep, suffix, l) {
  if (l) {
    return Stdlib__List.fold_left((function (x, y) {
                  return x + (sep + y);
                }), prefix + l.hd, l.tl) + suffix;
  } else {
    return "<none>";
  }
}

function help_action(param) {
  throw {
        MEL_EXN_ID: Stop,
        _1: {
          TAG: /* Unknown */0,
          _0: "-help"
        },
        Error: new Error()
      };
}

function add_help(speclist) {
  var add1;
  try {
    assoc3("-help", speclist);
    add1 = /* [] */0;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      add1 = {
        hd: [
          "-help",
          {
            TAG: /* Unit */0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */0
      };
    } else {
      throw exn;
    }
  }
  var add2;
  try {
    assoc3("--help", speclist);
    add2 = /* [] */0;
  }
  catch (raw_exn$1){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      add2 = {
        hd: [
          "--help",
          {
            TAG: /* Unit */0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */0
      };
    } else {
      throw exn$1;
    }
  }
  return Stdlib.$at(speclist, Stdlib.$at(add1, add2));
}

function usage_b(buf, speclist, errmsg) {
  Curry._1(Stdlib__Printf.bprintf(buf, /* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* Char_literal */12,
                _0: /* '\\n' */10,
                _1: /* End_of_format */0
              }
            },
            _1: "%s\\n"
          }), errmsg);
  Stdlib__List.iter((function (param) {
          var doc = param[2];
          if (doc.length === 0) {
            return ;
          }
          var spec = param[1];
          var key = param[0];
          if (spec.TAG === /* Symbol */11) {
            return Curry._3(Stdlib__Printf.bprintf(buf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "  ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Char_literal */12,
                                        _0: /* '\\n' */10,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "  %s %s%s\\n"
                          }), key, make_symlist("{", "|", "}", spec._0), doc);
          } else {
            return Curry._2(Stdlib__Printf.bprintf(buf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "  ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Char_literal */12,
                                      _0: /* '\\n' */10,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            },
                            _1: "  %s %s\\n"
                          }), key, doc);
          }
        }), add_help(speclist));
}

function usage_string(speclist, errmsg) {
  var b = Stdlib__Buffer.create(200);
  usage_b(b, speclist, errmsg);
  return Stdlib__Buffer.contents(b);
}

function usage(speclist, errmsg) {
  Curry._1(Stdlib__Printf.eprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), usage_string(speclist, errmsg));
}

var current = {
  contents: 0
};

function bool_of_string_opt(x) {
  try {
    return Stdlib.bool_of_string(x);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Invalid_argument) {
      return ;
    }
    throw exn;
  }
}

function int_of_string_opt(x) {
  try {
    return Caml_format.caml_int_of_string(x);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw exn;
  }
}

function float_of_string_opt(x) {
  try {
    return Caml_format.caml_float_of_string(x);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw exn;
  }
}

function parse_and_expand_argv_dynamic_aux(allow_expand, current, argv, speclist, anonfun, errmsg) {
  var initpos = current.contents;
  var convert_error = function (error) {
    var b = Stdlib__Buffer.create(200);
    var progname = initpos < argv.contents.length ? Caml_array.get(argv.contents, initpos) : "(?)";
    switch (error.TAG | 0) {
      case /* Unknown */0 :
          var s = error._0;
          switch (s) {
            case "--help" :
            case "-help" :
                break;
            default:
              Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ": unknown option '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "'.\\n",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%s: unknown option '%s'.\\n"
                      }), progname, s);
          }
          break;
      case /* Wrong */1 :
          Curry._4(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": wrong argument '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "'; option '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "' expects ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: ".\\n",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s: wrong argument '%s'; option '%s' expects %s.\\n"
                  }), progname, error._1, error._0, error._2);
          break;
      case /* Missing */2 :
          Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": option '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "' needs an argument.\\n",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%s: option '%s' needs an argument.\\n"
                  }), progname, error._0);
          break;
      case /* Message */3 :
          Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ".\\n",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%s: %s.\\n"
                  }), progname, error._0);
          break;
      
    }
    usage_b(b, speclist.contents, errmsg);
    if (Caml_obj.caml_equal(error, {
            TAG: /* Unknown */0,
            _0: "-help"
          }) || Caml_obj.caml_equal(error, {
            TAG: /* Unknown */0,
            _0: "--help"
          })) {
      return {
              MEL_EXN_ID: Help,
              _1: Stdlib__Buffer.contents(b)
            };
    } else {
      return {
              MEL_EXN_ID: Bad,
              _1: Stdlib__Buffer.contents(b)
            };
    }
  };
  current.contents = current.contents + 1 | 0;
  while(current.contents < argv.contents.length) {
    try {
      var s = Caml_array.get(argv.contents, current.contents);
      if (Stdlib__String.starts_with("-", s)) {
        var match;
        try {
          match = [
            assoc3(s, speclist.contents),
            undefined
          ];
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              var match$1 = split(s);
              match = [
                assoc3(match$1[0], speclist.contents),
                match$1[1]
              ];
            }
            catch (raw_exn$1){
              var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                throw {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Unknown */0,
                        _0: s
                      },
                      Error: new Error()
                    };
              }
              throw exn$1;
            }
          } else {
            throw exn;
          }
        }
        var follow = match[1];
        var no_arg = (function(s,follow){
        return function no_arg(param) {
          if (follow === undefined) {
            return ;
          }
          throw {
                MEL_EXN_ID: Stop,
                _1: {
                  TAG: /* Wrong */1,
                  _0: s,
                  _1: follow,
                  _2: "no argument"
                },
                Error: new Error()
              };
        }
        }(s,follow));
        var get_arg = (function(s,follow){
        return function get_arg(param) {
          if (follow !== undefined) {
            return follow;
          }
          if ((current.contents + 1 | 0) < argv.contents.length) {
            return Caml_array.get(argv.contents, current.contents + 1 | 0);
          }
          throw {
                MEL_EXN_ID: Stop,
                _1: {
                  TAG: /* Missing */2,
                  _0: s
                },
                Error: new Error()
              };
        }
        }(s,follow));
        var consume_arg = (function(follow){
        return function consume_arg(param) {
          if (follow !== undefined) {
            return ;
          } else {
            current.contents = current.contents + 1 | 0;
            return ;
          }
        }
        }(follow));
        var treat_action = (function(s){
        return function treat_action(param) {
          switch (param.TAG | 0) {
            case /* Unit */0 :
                no_arg(undefined);
                return Curry._1(param._0, undefined);
            case /* Bool */1 :
                var arg = get_arg(undefined);
                var s$1 = bool_of_string_opt(arg);
                if (s$1 !== undefined) {
                  Curry._1(param._0, s$1);
                } else {
                  throw {
                        MEL_EXN_ID: Stop,
                        _1: {
                          TAG: /* Wrong */1,
                          _0: s,
                          _1: arg,
                          _2: "a boolean"
                        },
                        Error: new Error()
                      };
                }
                return consume_arg(undefined);
            case /* Set */2 :
                no_arg(undefined);
                param._0.contents = true;
                return ;
            case /* Clear */3 :
                no_arg(undefined);
                param._0.contents = false;
                return ;
            case /* String */4 :
                var arg$1 = get_arg(undefined);
                Curry._1(param._0, arg$1);
                return consume_arg(undefined);
            case /* Set_string */5 :
                param._0.contents = get_arg(undefined);
                return consume_arg(undefined);
            case /* Int */6 :
                var arg$2 = get_arg(undefined);
                var x = int_of_string_opt(arg$2);
                if (x !== undefined) {
                  Curry._1(param._0, x);
                } else {
                  throw {
                        MEL_EXN_ID: Stop,
                        _1: {
                          TAG: /* Wrong */1,
                          _0: s,
                          _1: arg$2,
                          _2: "an integer"
                        },
                        Error: new Error()
                      };
                }
                return consume_arg(undefined);
            case /* Set_int */7 :
                var arg$3 = get_arg(undefined);
                var x$1 = int_of_string_opt(arg$3);
                if (x$1 !== undefined) {
                  param._0.contents = x$1;
                } else {
                  throw {
                        MEL_EXN_ID: Stop,
                        _1: {
                          TAG: /* Wrong */1,
                          _0: s,
                          _1: arg$3,
                          _2: "an integer"
                        },
                        Error: new Error()
                      };
                }
                return consume_arg(undefined);
            case /* Float */8 :
                var arg$4 = get_arg(undefined);
                var x$2 = float_of_string_opt(arg$4);
                if (x$2 !== undefined) {
                  Curry._1(param._0, x$2);
                } else {
                  throw {
                        MEL_EXN_ID: Stop,
                        _1: {
                          TAG: /* Wrong */1,
                          _0: s,
                          _1: arg$4,
                          _2: "a float"
                        },
                        Error: new Error()
                      };
                }
                return consume_arg(undefined);
            case /* Set_float */9 :
                var arg$5 = get_arg(undefined);
                var x$3 = float_of_string_opt(arg$5);
                if (x$3 !== undefined) {
                  param._0.contents = x$3;
                } else {
                  throw {
                        MEL_EXN_ID: Stop,
                        _1: {
                          TAG: /* Wrong */1,
                          _0: s,
                          _1: arg$5,
                          _2: "a float"
                        },
                        Error: new Error()
                      };
                }
                return consume_arg(undefined);
            case /* Tuple */10 :
                no_arg(undefined);
                return Stdlib__List.iter(treat_action, param._0);
            case /* Symbol */11 :
                var symb = param._0;
                var arg$6 = get_arg(undefined);
                if (Stdlib__List.mem(arg$6, symb)) {
                  Curry._1(param._1, arg$6);
                  return consume_arg(undefined);
                }
                throw {
                      MEL_EXN_ID: Stop,
                      _1: {
                        TAG: /* Wrong */1,
                        _0: s,
                        _1: arg$6,
                        _2: "one of: " + make_symlist("", " ", "", symb)
                      },
                      Error: new Error()
                    };
            case /* Rest */12 :
                var f = param._0;
                no_arg(undefined);
                while(current.contents < (argv.contents.length - 1 | 0)) {
                  Curry._1(f, Caml_array.get(argv.contents, current.contents + 1 | 0));
                  consume_arg(undefined);
                };
                return ;
            case /* Rest_all */13 :
                no_arg(undefined);
                var acc = /* [] */0;
                while(current.contents < (argv.contents.length - 1 | 0)) {
                  acc = {
                    hd: Caml_array.get(argv.contents, current.contents + 1 | 0),
                    tl: acc
                  };
                  consume_arg(undefined);
                };
                return Curry._1(param._0, Stdlib__List.rev(acc));
            case /* Expand */14 :
                if (!allow_expand) {
                  throw {
                        MEL_EXN_ID: Stdlib.Invalid_argument,
                        _1: "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic",
                        Error: new Error()
                      };
                }
                var arg$7 = get_arg(undefined);
                var newarg = Curry._1(param._0, arg$7);
                consume_arg(undefined);
                var before = Stdlib__Array.sub(argv.contents, 0, current.contents + 1 | 0);
                var after = Stdlib__Array.sub(argv.contents, current.contents + 1 | 0, (argv.contents.length - current.contents | 0) - 1 | 0);
                argv.contents = Caml_array.concat({
                      hd: before,
                      tl: {
                        hd: newarg,
                        tl: {
                          hd: after,
                          tl: /* [] */0
                        }
                      }
                    });
                return ;
            
          }
        }
        }(s));
        treat_action(match[0]);
      } else {
        Curry._1(anonfun, s);
      }
    }
    catch (raw_exn$2){
      var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
      if (exn$2.MEL_EXN_ID === Bad) {
        throw convert_error({
                  TAG: /* Message */3,
                  _0: exn$2._1
                });
      }
      if (exn$2.MEL_EXN_ID === Stop) {
        throw convert_error(exn$2._1);
      }
      throw exn$2;
    }
    current.contents = current.contents + 1 | 0;
  };
}

function parse_and_expand_argv_dynamic(current, argv, speclist, anonfun, errmsg) {
  parse_and_expand_argv_dynamic_aux(true, current, argv, speclist, anonfun, errmsg);
}

function parse_argv_dynamic(currentOpt, argv, speclist, anonfun, errmsg) {
  var current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_and_expand_argv_dynamic_aux(false, current$1, {
        contents: argv
      }, speclist, anonfun, errmsg);
}

function parse_argv(currentOpt, argv, speclist, anonfun, errmsg) {
  var current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_argv_dynamic(current$1, argv, {
        contents: speclist
      }, anonfun, errmsg);
}

function parse(l, f, msg) {
  try {
    return parse_argv(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(2);
    }
    if (exn.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(0);
    }
    throw exn;
  }
}

function parse_dynamic(l, f, msg) {
  try {
    return parse_argv_dynamic(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(2);
    }
    if (exn.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(0);
    }
    throw exn;
  }
}

function parse_expand(l, f, msg) {
  try {
    var argv = {
      contents: Caml_sys.caml_sys_argv(0)
    };
    var spec = {
      contents: l
    };
    var current$1 = {
      contents: current.contents
    };
    return parse_and_expand_argv_dynamic(current$1, argv, spec, f, msg);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(2);
    }
    if (exn.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), exn._1);
      return Stdlib.exit(0);
    }
    throw exn;
  }
}

function second_word(s) {
  var len = s.length;
  var loop = function (_n) {
    while(true) {
      var n = _n;
      if (n >= len) {
        return len;
      }
      if (Caml_string.get(s, n) !== /* ' ' */32) {
        return n;
      }
      _n = n + 1 | 0;
      continue ;
    };
  };
  var n;
  try {
    n = Stdlib__String.index(s, /* '\\t' */9);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      var exit = 0;
      var n$1;
      try {
        n$1 = Stdlib__String.index(s, /* ' ' */32);
        exit = 2;
      }
      catch (raw_exn$1){
        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          return len;
        }
        throw exn$1;
      }
      if (exit === 2) {
        return loop(n$1 + 1 | 0);
      }
      
    } else {
      throw exn;
    }
  }
  return loop(n + 1 | 0);
}

function max_arg_len(cur, param) {
  var kwd = param[0];
  if (param[1].TAG === /* Symbol */11) {
    return Stdlib__Int.max(cur, kwd.length);
  } else {
    return Stdlib__Int.max(cur, kwd.length + second_word(param[2]) | 0);
  }
}

function replace_leading_tab(s) {
  var seen = {
    contents: false
  };
  return Stdlib__String.map((function (c) {
                if (c !== 9 || seen.contents) {
                  return c;
                } else {
                  seen.contents = true;
                  return /* ' ' */32;
                }
              }), s);
}

function align(limitOpt, speclist) {
  var limit = limitOpt !== undefined ? limitOpt : Stdlib.max_int;
  var completed = add_help(speclist);
  var len = Stdlib__List.fold_left(max_arg_len, 0, completed);
  var len$1 = Stdlib__Int.min(len, limit);
  return Stdlib__List.map((function (param) {
                var kwd = param[0];
                var spec = param[1];
                if (param[2] === "") {
                  return param;
                }
                if (spec.TAG === /* Symbol */11) {
                  var msg = param[2];
                  var cutcol = second_word(msg);
                  var n = Stdlib__Int.max(0, len$1 - cutcol | 0) + 3 | 0;
                  var spaces = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, /* ' ' */32));
                  return [
                          kwd,
                          spec,
                          "\\n" + (spaces + replace_leading_tab(msg))
                        ];
                }
                var msg$1 = param[2];
                var spec$1 = param[1];
                var cutcol$1 = second_word(msg$1);
                var kwd_len = kwd.length;
                var diff = (len$1 - kwd_len | 0) - cutcol$1 | 0;
                if (diff <= 0) {
                  return [
                          kwd,
                          spec$1,
                          replace_leading_tab(msg$1)
                        ];
                }
                var spaces$1 = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(diff, /* ' ' */32));
                var prefix = Stdlib__String.sub(replace_leading_tab(msg$1), 0, cutcol$1);
                var suffix = Stdlib__String.sub(msg$1, cutcol$1, msg$1.length - cutcol$1 | 0);
                return [
                        kwd,
                        spec$1,
                        prefix + (spaces$1 + suffix)
                      ];
              }), completed);
}

function trim_cr(s) {
  var len = s.length;
  if (len > 0 && Caml_string.get(s, len - 1 | 0) === /* '\\r' */13) {
    return Stdlib__String.sub(s, 0, len - 1 | 0);
  } else {
    return s;
  }
}

function read_aux(trim, sep, file) {
  var ic = Stdlib.open_in_bin(file);
  var buf = Stdlib__Buffer.create(200);
  var words = {
    contents: /* [] */0
  };
  var stash = function (param) {
    var word = Stdlib__Buffer.contents(buf);
    var word$1 = trim ? trim_cr(word) : word;
    words.contents = {
      hd: word$1,
      tl: words.contents
    };
    buf.position = 0;
  };
  try {
    while(true) {
      var c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
      if (c === sep) {
        stash(undefined);
      } else {
        Stdlib__Buffer.add_char(buf, c);
      }
    };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID !== Stdlib.End_of_file) {
      throw exn;
    }
    
  }
  if (buf.position > 0) {
    stash(undefined);
  }
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return Stdlib__Array.of_list(Stdlib__List.rev(words.contents));
}

function read_arg(param) {
  return read_aux(true, /* '\\n' */10, param);
}

function read_arg0(param) {
  return read_aux(false, /* '\\000' */0, param);
}

function write_aux(sep, file, args) {
  var oc = Stdlib.open_out_bin(file);
  Stdlib__Array.iter((function (s) {
          Curry._2(Stdlib__Printf.fprintf(oc, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char */0,
                        _0: /* End_of_format */0
                      }
                    },
                    _1: "%s%c"
                  }), s, sep);
        }), args);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function write_arg(param, param$1) {
  return write_aux(/* '\\n' */10, param, param$1);
}

function write_arg0(param, param$1) {
  return write_aux(/* '\\000' */0, param, param$1);
}

export {
  parse ,
  parse_dynamic ,
  parse_argv ,
  parse_argv_dynamic ,
  parse_and_expand_argv_dynamic ,
  parse_expand ,
  Help ,
  Bad ,
  usage ,
  usage_string ,
  align ,
  current ,
  read_arg ,
  read_arg0 ,
  write_arg ,
  write_arg0 ,
}
/* No side effect */
`,du=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

var Floatarray = {};

function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.init",
          Error: new Error()
        };
  }
  var res = Caml_array.make(l, Curry._1(f, 0));
  for(var i = 1; i < l; ++i){
    res[i] = Curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, init) {
  var res = Caml_array.make(sx, []);
  for(var x = 0; x < sx; ++x){
    res[x] = Caml_array.make(sy, init);
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l === 0) {
    return [];
  } else {
    return Caml_array.sub(a, 0, l);
  }
}

function append(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return Caml_array.sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.sub",
          Error: new Error()
        };
  }
  return Caml_array.sub(a, ofs, len);
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.fill",
          Error: new Error()
        };
  }
  for(var i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    a[i] = v;
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.blit",
          Error: new Error()
        };
  }
  Caml_array.blit(a1, ofs1, a2, ofs2, len);
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.iter2: arrays must have the same length",
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = Caml_array.make(l, Curry._1(f, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_inplace(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._1(f, a[i]);
  }
}

function mapi_inplace(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._2(f, i, a[i]);
  }
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.map2: arrays must have the same length",
          Error: new Error()
        };
  }
  if (la === 0) {
    return [];
  }
  var r = Caml_array.make(la, Curry._2(f, a[0], b[0]));
  for(var i = 1; i < la; ++i){
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = Caml_array.make(l, Curry._2(f, 0, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function of_list(l) {
  if (!l) {
    return [];
  }
  var a = Caml_array.make(list_length(0, l), l.hd);
  var _i = 1;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    a[i] = param.hd;
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_left_map(f, acc, input_array) {
  var len = input_array.length;
  if (len === 0) {
    return [
            acc,
            []
          ];
  }
  var match = Curry._2(f, acc, input_array[0]);
  var output_array = Caml_array.make(len, match[1]);
  var acc$1 = match[0];
  for(var i = 1; i < len; ++i){
    var match$1 = Curry._2(f, acc$1, input_array[i]);
    acc$1 = match$1[0];
    output_array[i] = match$1[1];
  }
  return [
          acc$1,
          output_array
        ];
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.for_all2",
          Error: new Error()
        };
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return true;
    }
    if (!Curry._2(p, l1[i], l2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function exists2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.exists2",
          Error: new Error()
        };
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return false;
    }
    if (Curry._2(p, l1[i], l2[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.caml_equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function memq(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_opt(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var x = a[i];
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_index(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_map(f, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_mapi(f, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function split(x) {
  if (Caml_obj.caml_equal(x, [])) {
    return [
            [],
            []
          ];
  }
  var match = x[0];
  var n = x.length;
  var a = Caml_array.make(n, match[0]);
  var b = Caml_array.make(n, match[1]);
  for(var i = 1; i < n; ++i){
    var match$1 = x[i];
    a[i] = match$1[0];
    b[i] = match$1[1];
  }
  return [
          a,
          b
        ];
}

function combine(a, b) {
  var na = a.length;
  var nb = b.length;
  if (na !== nb) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Array.combine",
          Error: new Error()
        };
  }
  if (na === 0) {
    return [];
  }
  var x = Caml_array.make(na, [
        a[0],
        b[0]
      ]);
  for(var i = 1; i < na; ++i){
    x[i] = [
      a[i],
      b[i]
    ];
  }
  return x;
}

var Bottom = /* @__PURE__ */Caml_exceptions.create("Stdlib.Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          MEL_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return Caml_array.set(a, exn._1, e);
      }
      throw exn;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return exn._1;
      }
      throw exn;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "array.cppo.ml",
                353,
                4
              ],
              Error: new Error()
            };
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Caml_array.get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Caml_array.get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Caml_array.set(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = Caml_array.get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = Caml_array.make(l2, Caml_array.get(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

function to_seq(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = a[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = a[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  var l = Stdlib__Seq.fold_left((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, i);
  if (!l) {
    return [];
  }
  var len = list_length(0, l);
  var a = Caml_array.make(len, l.hd);
  var _i = len - 2 | 0;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue ;
  };
}

var concat = Caml_array.concat;

var fast_sort = stable_sort;

export {
  init ,
  make_matrix ,
  append ,
  concat ,
  sub ,
  copy ,
  fill ,
  blit ,
  to_list ,
  of_list ,
  iter ,
  iteri ,
  map ,
  map_inplace ,
  mapi ,
  mapi_inplace ,
  fold_left ,
  fold_left_map ,
  fold_right ,
  iter2 ,
  map2 ,
  for_all ,
  exists ,
  for_all2 ,
  exists2 ,
  mem ,
  memq ,
  find_opt ,
  find_index ,
  find_map ,
  find_mapi ,
  split ,
  combine ,
  sort ,
  stable_sort ,
  fast_sort ,
  to_seq ,
  to_seqi ,
  of_seq ,
  Floatarray ,
}
/* No side effect */
`,hu=`// Generated by Melange

import * as Stdlib__Array from "./array.js";

var init = Stdlib__Array.init;

var make_matrix = Stdlib__Array.make_matrix;

var append = Stdlib__Array.append;

var concat = Stdlib__Array.concat;

var sub = Stdlib__Array.sub;

var copy = Stdlib__Array.copy;

var fill = Stdlib__Array.fill;

var blit = Stdlib__Array.blit;

var to_list = Stdlib__Array.to_list;

var of_list = Stdlib__Array.of_list;

var iter = Stdlib__Array.iter;

var iteri = Stdlib__Array.iteri;

var map = Stdlib__Array.map;

var map_inplace = Stdlib__Array.map_inplace;

var mapi = Stdlib__Array.mapi;

var mapi_inplace = Stdlib__Array.mapi_inplace;

var fold_left = Stdlib__Array.fold_left;

var fold_left_map = Stdlib__Array.fold_left_map;

var fold_right = Stdlib__Array.fold_right;

var iter2 = Stdlib__Array.iter2;

var map2 = Stdlib__Array.map2;

var for_all = Stdlib__Array.for_all;

var exists = Stdlib__Array.exists;

var for_all2 = Stdlib__Array.for_all2;

var exists2 = Stdlib__Array.exists2;

var mem = Stdlib__Array.mem;

var memq = Stdlib__Array.memq;

var find_opt = Stdlib__Array.find_opt;

var find_index = Stdlib__Array.find_index;

var find_map = Stdlib__Array.find_map;

var find_mapi = Stdlib__Array.find_mapi;

var split = Stdlib__Array.split;

var combine = Stdlib__Array.combine;

var sort = Stdlib__Array.sort;

var stable_sort = Stdlib__Array.stable_sort;

var fast_sort = Stdlib__Array.fast_sort;

var to_seq = Stdlib__Array.to_seq;

var to_seqi = Stdlib__Array.to_seqi;

var of_seq = Stdlib__Array.of_seq;

var Floatarray = Stdlib__Array.Floatarray;

export {
  init ,
  make_matrix ,
  append ,
  concat ,
  sub ,
  copy ,
  fill ,
  blit ,
  to_list ,
  of_list ,
  iter ,
  iteri ,
  map ,
  map_inplace ,
  mapi ,
  mapi_inplace ,
  fold_left ,
  fold_left_map ,
  fold_right ,
  iter2 ,
  map2 ,
  for_all ,
  exists ,
  for_all2 ,
  exists2 ,
  mem ,
  memq ,
  find_opt ,
  find_index ,
  find_map ,
  find_mapi ,
  split ,
  combine ,
  sort ,
  stable_sort ,
  fast_sort ,
  to_seq ,
  to_seqi ,
  of_seq ,
  Floatarray ,
}
/* No side effect */
`,gu=`// Generated by Melange

import * as CamlinternalAtomic from "./camlinternalAtomic.js";

var make = CamlinternalAtomic.make;

var get = CamlinternalAtomic.get;

var set = CamlinternalAtomic.set;

var exchange = CamlinternalAtomic.exchange;

var compare_and_set = CamlinternalAtomic.compare_and_set;

var fetch_and_add = CamlinternalAtomic.fetch_and_add;

var incr = CamlinternalAtomic.incr;

var decr = CamlinternalAtomic.decr;

export {
  make ,
  get ,
  set ,
  exchange ,
  compare_and_set ,
  fetch_and_add ,
  incr ,
  decr ,
}
/* No side effect */
`,bu=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_hash from "melange.js/caml_hash.js";

function equal(prim0, prim1) {
  return prim0 === prim1;
}

var compare = Caml.caml_int_compare;

function to_int(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

function to_float(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

function to_string(param) {
  if (param) {
    return "true";
  } else {
    return "false";
  }
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function not(prim) {
  return !prim;
}

export {
  not ,
  equal ,
  compare ,
  to_int ,
  to_float ,
  to_string ,
  seeded_hash ,
  hash ,
}
/* No side effect */
`,vu=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__String from "./string.js";
import * as Stdlib__Sys from "./sys.js";

function create(n) {
  var n$1 = n < 1 ? 1 : n;
  var n$2 = n$1 > Stdlib__Sys.max_string_length ? Stdlib__Sys.max_string_length : n$1;
  var s = Caml_bytes.caml_create_bytes(n$2);
  return {
          inner: {
            buffer: s,
            length: n$2
          },
          position: 0,
          initial_buffer: s
        };
}

function contents(b) {
  return Stdlib__Bytes.sub_string(b.inner.buffer, 0, b.position);
}

function to_bytes(b) {
  return Stdlib__Bytes.sub(b.inner.buffer, 0, b.position);
}

function sub(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.sub",
          Error: new Error()
        };
  }
  return Stdlib__Bytes.sub_string(b.inner.buffer, ofs, len);
}

function blit(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.blit",
          Error: new Error()
        };
  }
  Stdlib__Bytes.blit(src.inner.buffer, srcoff, dst, dstoff, len);
}

function nth(b, ofs) {
  var position = b.position;
  var match = b.inner;
  if (ofs < 0 || ofs >= position || position > match.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.nth",
          Error: new Error()
        };
  }
  return match.buffer[ofs];
}

function length(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
}

function reset(b) {
  b.position = 0;
  var inner_buffer = b.initial_buffer;
  var inner_length = b.initial_buffer.length;
  var inner = {
    buffer: inner_buffer,
    length: inner_length
  };
  b.inner = inner;
}

function resize(b, more) {
  var old_pos = b.position;
  var old_len = b.inner.length;
  var new_len = old_len;
  while((old_pos + more | 0) > new_len) {
    new_len = (new_len << 1);
  };
  if (new_len > Stdlib__Sys.max_string_length) {
    if ((old_pos + more | 0) <= Stdlib__Sys.max_string_length) {
      new_len = Stdlib__Sys.max_string_length;
    } else {
      throw {
            MEL_EXN_ID: "Failure",
            _1: "Buffer.add: cannot grow buffer",
            Error: new Error()
          };
    }
  }
  var new_buffer = Caml_bytes.caml_create_bytes(new_len);
  Stdlib__Bytes.blit(b.inner.buffer, 0, new_buffer, 0, b.position);
  b.inner = {
    buffer: new_buffer,
    length: new_len
  };
}

function add_char(b, c) {
  var pos = b.position;
  var match = b.inner;
  if (pos >= match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, c);
  } else {
    match.buffer[pos] = c;
  }
  b.position = pos + 1 | 0;
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_substring/add_subbytes",
          Error: new Error()
        };
  }
  var position = b.position;
  var match = b.inner;
  var new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit_string(s, offset, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_string(s, offset, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_subbytes(b, s, offset, len) {
  add_substring(b, Caml_bytes.bytes_to_string(s), offset, len);
}

function add_string(b, s) {
  var len = s.length;
  var position = b.position;
  var match = b.inner;
  var new_position = position + len | 0;
  if (new_position > match.length) {
    resize(b, len);
    Stdlib__Bytes.blit_string(s, 0, b.inner.buffer, b.position, len);
  } else {
    Caml_bytes.caml_blit_string(s, 0, match.buffer, position, len);
  }
  b.position = new_position;
}

function add_bytes(b, s) {
  add_string(b, Caml_bytes.bytes_to_string(s));
}

function add_buffer(b, bs) {
  add_subbytes(b, bs.inner.buffer, 0, bs.position);
}

function really_input_up_to(ic, buf, ofs, len) {
  var _already_read = 0;
  var _ofs = ofs;
  var _to_read = len;
  while(true) {
    var to_read = _to_read;
    var ofs$1 = _ofs;
    var already_read = _already_read;
    if (to_read === 0) {
      return already_read;
    }
    var r = Stdlib.input(ic, buf, ofs$1, to_read);
    if (r === 0) {
      return already_read;
    }
    var already_read$1 = already_read + r | 0;
    var ofs$2 = ofs$1 + r | 0;
    var to_read$1 = to_read - r | 0;
    _to_read = to_read$1;
    _ofs = ofs$2;
    _already_read = already_read$1;
    continue ;
  };
}

function unsafe_add_channel_up_to(b, ic, len) {
  if ((b.position + len | 0) > b.inner.length) {
    resize(b, len);
  }
  var n = really_input_up_to(ic, b.inner.buffer, b.position, len);
  b.position = b.position + n | 0;
  return n;
}

function add_channel(b, ic, len) {
  if (len < 0 || len > Stdlib__Sys.max_string_length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.add_channel",
          Error: new Error()
        };
  }
  var n = unsafe_add_channel_up_to(b, ic, len);
  if (n < len) {
    throw {
          MEL_EXN_ID: Stdlib.End_of_file,
          Error: new Error()
        };
  }
  
}

function output_buffer(oc, b) {
  Stdlib.output(oc, b.inner.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ')' */41;
  }
  if (param === 123) {
    return /* '}' */125;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "buffer.cppo.ml",
          223,
          9
        ],
        Error: new Error()
      };
}

function advance_to_closing(opening, closing, k, s, start) {
  var _k = k;
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    var k$1 = _k;
    if (i >= lim) {
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    if (Caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue ;
    }
    if (Caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue ;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function advance_to_non_alpha(s, start) {
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    if (i >= lim) {
      return lim;
    }
    var match = Caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  }
  var c = Caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    var stop = advance_to_non_alpha(s, start + 1 | 0);
    return [
            Stdlib__String.sub(s, start, stop - start | 0),
            stop
          ];
  }
  var new_start = start + 1 | 0;
  var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
          Stdlib__String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
          stop$1 + 1 | 0
        ];
}

function add_substitute(b, f, s) {
  var lim = s.length;
  var _previous = /* ' ' */32;
  var _i = 0;
  while(true) {
    var i = _i;
    var previous = _previous;
    if (i >= lim) {
      if (previous === /* '\\\\' */92) {
        return add_char(b, previous);
      } else {
        return ;
      }
    }
    var current = Caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* '\\\\' */92) {
        add_char(b, /* '\\\\' */92);
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = /* ' ' */32;
        continue ;
      }
      if (current !== 92) {
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = current;
        continue ;
      }
      _i = i + 1 | 0;
      _previous = current;
      continue ;
    }
    if (previous === /* '\\\\' */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* ' ' */32;
      continue ;
    }
    var j = i + 1 | 0;
    var match = find_ident(s, j, lim);
    add_string(b, Curry._1(f, match[0]));
    _i = match[1];
    _previous = /* ' ' */32;
    continue ;
  };
}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Buffer.truncate",
          Error: new Error()
        };
  }
  b.position = len;
}

function to_seq(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(b.inner.buffer, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(b.inner.buffer, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function add_seq(b, seq) {
  Stdlib__Seq.iter((function (param) {
          return add_char(b, param);
        }), seq);
}

function of_seq(i) {
  var b = create(32);
  Stdlib__Seq.iter((function (param) {
          return add_char(b, param);
        }), i);
  return b;
}

function add_int8(b, x) {
  var position = b.position;
  var match = b.inner;
  var new_position = position + 1 | 0;
  if (new_position > match.length) {
    resize(b, 1);
    Caml_bytes.set(b.inner.buffer, b.position, x);
  } else {
    match.buffer[position] = x;
  }
  b.position = new_position;
}

function add_int16_ne(b, x) {
  var position = b.position;
  var match = b.inner;
  var new_position = position + 2 | 0;
  if (new_position > match.length) {
    resize(b, 2);
    Caml_bytes.set16(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set16u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int32_ne(b, x) {
  var position = b.position;
  var match = b.inner;
  var new_position = position + 4 | 0;
  if (new_position > match.length) {
    resize(b, 4);
    Caml_bytes.set32(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set32u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int64_ne(b, x) {
  var position = b.position;
  var match = b.inner;
  var new_position = position + 8 | 0;
  if (new_position > match.length) {
    resize(b, 8);
    Caml_bytes.set64(b.inner.buffer, b.position, x);
  } else {
    Caml_bytes.set64u(match.buffer, position, x);
  }
  b.position = new_position;
}

function add_int16_le(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap16(x) : x);
}

function add_int16_be(b, x) {
  add_int16_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap16(x));
}

function add_int32_le(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap32(x) : x);
}

function add_int32_be(b, x) {
  add_int32_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap32(x));
}

function add_int64_le(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? Caml_bytes.bswap64(x) : x);
}

function add_int64_be(b, x) {
  add_int64_ne(b, Stdlib__Sys.big_endian ? x : Caml_bytes.bswap64(x));
}

var add_uint8 = add_int8;

var add_uint16_ne = add_int16_ne;

var add_uint16_be = add_int16_be;

var add_uint16_le = add_int16_le;

export {
  create ,
  contents ,
  to_bytes ,
  sub ,
  blit ,
  nth ,
  length ,
  clear ,
  reset ,
  output_buffer ,
  truncate ,
  add_char ,
  add_string ,
  add_bytes ,
  add_substring ,
  add_subbytes ,
  add_substitute ,
  add_buffer ,
  add_channel ,
  to_seq ,
  to_seqi ,
  add_seq ,
  of_seq ,
  add_uint8 ,
  add_int8 ,
  add_uint16_ne ,
  add_uint16_be ,
  add_uint16_le ,
  add_int16_ne ,
  add_int16_be ,
  add_int16_le ,
  add_int32_ne ,
  add_int32_be ,
  add_int32_le ,
  add_int64_ne ,
  add_int64_be ,
  add_int64_le ,
}
/* No side effect */
`,yu=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function make(n, c) {
  var s = Caml_bytes.caml_create_bytes(n);
  Caml_bytes.caml_fill_bytes(s, 0, n, c);
  return s;
}

function init(n, f) {
  var s = Caml_bytes.caml_create_bytes(n);
  for(var i = 0; i < n; ++i){
    s[i] = Curry._1(f, i);
  }
  return s;
}

var empty = [];

function copy(s) {
  var len = s.length;
  var r = Caml_bytes.caml_create_bytes(len);
  Caml_bytes.caml_blit_bytes(s, 0, r, 0, len);
  return r;
}

function to_string(b) {
  return Caml_bytes.bytes_to_string(copy(b));
}

function of_string(s) {
  return copy(Caml_bytes.bytes_of_string(s));
}

function sub(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.sub / Bytes.sub",
          Error: new Error()
        };
  }
  var r = Caml_bytes.caml_create_bytes(len);
  Caml_bytes.caml_blit_bytes(s, ofs, r, 0, len);
  return r;
}

function sub_string(b, ofs, len) {
  return Caml_bytes.bytes_to_string(sub(b, ofs, len));
}

function $plus$plus(a, b) {
  var c = a + b | 0;
  var match = a < 0;
  var match$1 = b < 0;
  var match$2 = c < 0;
  if (match) {
    if (!match$1) {
      return c;
    }
    if (match$2) {
      return c;
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend",
          Error: new Error()
        };
  }
  if (match$1) {
    return c;
  }
  if (match$2) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.extend",
          Error: new Error()
        };
  }
  return c;
}

function extend(s, left, right) {
  var len = $plus$plus($plus$plus(s.length, left), right);
  var r = Caml_bytes.caml_create_bytes(len);
  var match = left < 0 ? [
      -left | 0,
      0
    ] : [
      0,
      left
    ];
  var dstoff = match[1];
  var srcoff = match[0];
  var cpylen = Stdlib__Int.min(s.length - srcoff | 0, len - dstoff | 0);
  if (cpylen > 0) {
    Caml_bytes.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
  }
  return r;
}

function fill(s, ofs, len, c) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.fill / Bytes.fill",
          Error: new Error()
        };
  }
  Caml_bytes.caml_fill_bytes(s, ofs, len, c);
}

function blit(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Bytes.blit",
          Error: new Error()
        };
  }
  Caml_bytes.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
}

function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.blit / Bytes.blit_string",
          Error: new Error()
        };
  }
  Caml_bytes.caml_blit_string(s1, ofs1, s2, ofs2, len);
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, a[i]);
  }
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Bytes.concat",
        Error: new Error()
      };
}

function sum_lengths(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    var hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue ;
  };
}

function concat(sep, l) {
  if (!l) {
    return empty;
  }
  var seplen = sep.length;
  var dst = Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l));
  var _pos = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var pos = _pos;
    if (!param) {
      return dst;
    }
    var hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_bytes(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue ;
    }
    Caml_bytes.caml_blit_bytes(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function cat(s1, s2) {
  var l1 = s1.length;
  var l2 = s2.length;
  var r = Caml_bytes.caml_create_bytes(l1 + l2 | 0);
  Caml_bytes.caml_blit_bytes(s1, 0, r, 0, l1);
  Caml_bytes.caml_blit_bytes(s2, 0, r, l1, l2);
  return r;
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  var len = s.length;
  var i = 0;
  while(i < len && is_space(s[i])) {
    i = i + 1 | 0;
  };
  var j = len - 1 | 0;
  while(j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  };
  if (j >= i) {
    return sub(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}

function unsafe_escape(s) {
  var n = 0;
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    var match = s[i];
    n = n + (
      match >= 32 ? (
          match > 92 || match < 34 ? (
              match >= 127 ? 4 : 1
            ) : (
              match > 91 || match < 35 ? 2 : 1
            )
        ) : (
          match >= 11 ? (
              match !== 13 ? 4 : 2
            ) : (
              match >= 8 ? 2 : 4
            )
        )
    ) | 0;
  }
  if (n === s.length) {
    return s;
  }
  var s$p = Caml_bytes.caml_create_bytes(n);
  n = 0;
  for(var i$1 = 0 ,i_finish$1 = s.length; i$1 < i_finish$1; ++i$1){
    var c = s[i$1];
    var exit = 0;
    if (c >= 35) {
      if (c !== 92) {
        if (c >= 127) {
          exit = 1;
        } else {
          s$p[n] = c;
        }
      } else {
        exit = 2;
      }
    } else if (c >= 32) {
      if (c >= 34) {
        exit = 2;
      } else {
        s$p[n] = c;
      }
    } else if (c >= 14) {
      exit = 1;
    } else {
      switch (c) {
        case 8 :
            s$p[n] = /* '\\\\' */92;
            n = n + 1 | 0;
            s$p[n] = /* 'b' */98;
            break;
        case 9 :
            s$p[n] = /* '\\\\' */92;
            n = n + 1 | 0;
            s$p[n] = /* 't' */116;
            break;
        case 10 :
            s$p[n] = /* '\\\\' */92;
            n = n + 1 | 0;
            s$p[n] = /* 'n' */110;
            break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 11 :
        case 12 :
            exit = 1;
            break;
        case 13 :
            s$p[n] = /* '\\\\' */92;
            n = n + 1 | 0;
            s$p[n] = /* 'r' */114;
            break;
        
      }
    }
    switch (exit) {
      case 1 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = 48 + (c / 100 | 0) | 0;
          n = n + 1 | 0;
          s$p[n] = 48 + (c / 10 | 0) % 10 | 0;
          n = n + 1 | 0;
          s$p[n] = 48 + c % 10 | 0;
          break;
      case 2 :
          s$p[n] = /* '\\\\' */92;
          n = n + 1 | 0;
          s$p[n] = c;
          break;
      
    }
    n = n + 1 | 0;
  }
  return s$p;
}

function escaped(b) {
  return unsafe_escape(copy(b));
}

function map(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  }
  var r = Caml_bytes.caml_create_bytes(l);
  for(var i = 0; i < l; ++i){
    r[i] = Curry._1(f, s[i]);
  }
  return r;
}

function mapi(f, s) {
  var l = s.length;
  if (l === 0) {
    return s;
  }
  var r = Caml_bytes.caml_create_bytes(l);
  for(var i = 0; i < l; ++i){
    r[i] = Curry._2(f, i, s[i]);
  }
  return r;
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, s) {
  var n = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, s[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, s) {
  var n = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, s[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function uppercase_ascii(s) {
  return map(Stdlib__Char.uppercase_ascii, s);
}

function lowercase_ascii(s) {
  return map(Stdlib__Char.lowercase_ascii, s);
}

function apply1(f, s) {
  if (s.length === 0) {
    return s;
  }
  var r = copy(s);
  r[0] = Curry._1(f, s[0]);
  return r;
}

function capitalize_ascii(s) {
  return apply1(Stdlib__Char.uppercase_ascii, s);
}

function uncapitalize_ascii(s) {
  return apply1(Stdlib__Char.lowercase_ascii, s);
}

function starts_with(prefix, s) {
  var len_s = s.length;
  var len_pre = prefix.length;
  if (len_s >= len_pre) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s[i] !== prefix[i]) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  var len_s = s.length;
  var len_suf = suffix.length;
  var diff = len_s - len_suf | 0;
  if (diff >= 0) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s[diff + i | 0] !== suffix[i]) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function index_rec(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from",
          Error: new Error()
        };
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt",
          Error: new Error()
        };
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from",
          Error: new Error()
        };
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    }
    if (s[i] === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt",
          Error: new Error()
        };
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from",
          Error: new Error()
        };
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from",
          Error: new Error()
        };
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

var compare = Caml_bytes.caml_bytes_compare;

function split_on_char(sep, s) {
  var r = /* [] */0;
  var j = s.length;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    if (s[i] === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
          hd: sub(s, 0, j),
          tl: r
        };
}

function to_seq(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  var n = {
    contents: 0
  };
  var buf = {
    contents: make(256, /* '\\000' */0)
  };
  var resize = function (param) {
    var new_len = Stdlib__Int.min((buf.contents.length << 1), Stdlib__Sys.max_string_length);
    if (buf.contents.length === new_len) {
      throw {
            MEL_EXN_ID: "Failure",
            _1: "Bytes.of_seq: cannot grow bytes",
            Error: new Error()
          };
    }
    var new_buf = make(new_len, /* '\\000' */0);
    blit(buf.contents, 0, new_buf, 0, n.contents);
    buf.contents = new_buf;
  };
  Stdlib__Seq.iter((function (c) {
          if (n.contents === buf.contents.length) {
            resize(undefined);
          }
          Caml_bytes.set(buf.contents, n.contents, c);
          n.contents = n.contents + 1 | 0;
        }), i);
  return sub(buf.contents, 0, n.contents);
}

function unsafe_get_uint16_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap16(Caml_bytes.get16u(b, i));
  } else {
    return Caml_bytes.get16u(b, i);
  }
}

function unsafe_get_uint16_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get16u(b, i);
  } else {
    return Caml_bytes.bswap16(Caml_bytes.get16u(b, i));
  }
}

function get_int8(b, i) {
  return ((Caml_bytes.get(b, i) << (Stdlib__Sys.int_size - 8 | 0)) >> (Stdlib__Sys.int_size - 8 | 0));
}

function get_uint16_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap16(Caml_bytes.get16(b, i));
  } else {
    return Caml_bytes.get16(b, i);
  }
}

function get_uint16_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get16(b, i);
  } else {
    return Caml_bytes.bswap16(Caml_bytes.get16(b, i));
  }
}

function get_int16_ne(b, i) {
  return ((Caml_bytes.get16(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int16_le(b, i) {
  return ((get_uint16_le(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int16_be(b, i) {
  return ((get_uint16_be(b, i) << (Stdlib__Sys.int_size - 16 | 0)) >> (Stdlib__Sys.int_size - 16 | 0));
}

function get_int32_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap32(Caml_bytes.get32(b, i));
  } else {
    return Caml_bytes.get32(b, i);
  }
}

function get_int32_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get32(b, i);
  } else {
    return Caml_bytes.bswap32(Caml_bytes.get32(b, i));
  }
}

function get_int64_le(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
  } else {
    return Caml_bytes.get64(b, i);
  }
}

function get_int64_be(b, i) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.get64(b, i);
  } else {
    return Caml_bytes.bswap64(Caml_bytes.get64(b, i));
  }
}

function unsafe_set_uint16_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x));
  } else {
    return Caml_bytes.set16u(b, i, x);
  }
}

function unsafe_set_uint16_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16u(b, i, x);
  } else {
    return Caml_bytes.set16u(b, i, Caml_bytes.bswap16(x));
  }
}

function set_int16_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x));
  } else {
    return Caml_bytes.set16(b, i, x);
  }
}

function set_int16_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set16(b, i, x);
  } else {
    return Caml_bytes.set16(b, i, Caml_bytes.bswap16(x));
  }
}

function set_int32_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x));
  } else {
    return Caml_bytes.set32(b, i, x);
  }
}

function set_int32_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set32(b, i, x);
  } else {
    return Caml_bytes.set32(b, i, Caml_bytes.bswap32(x));
  }
}

function set_int64_le(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x));
  } else {
    return Caml_bytes.set64(b, i, x);
  }
}

function set_int64_be(b, i, x) {
  if (Stdlib__Sys.big_endian) {
    return Caml_bytes.set64(b, i, x);
  } else {
    return Caml_bytes.set64(b, i, Caml_bytes.bswap64(x));
  }
}

var set_uint8 = Caml_bytes.set;

var set_uint16_ne = Caml_bytes.set16;

function get_utf_8_uchar(b, i) {
  var b0 = Caml_bytes.get(b, i);
  var max = b.length - 1 | 0;
  var exit = 0;
  if (b0 >= 224) {
    if (b0 >= 237) {
      if (b0 >= 245) {
        return 16842749;
      }
      switch (b0) {
        case 237 :
            var i$1 = i + 1 | 0;
            if (i$1 > max) {
              return 16842749;
            }
            var b1 = b[i$1];
            if ((b1 >>> 5) !== 4) {
              return 16842749;
            }
            var i$2 = i$1 + 1 | 0;
            if (i$2 > max) {
              return 33619965;
            }
            var b2 = b[i$2];
            if ((b2 >>> 6) !== 2) {
              return 33619965;
            }
            var u = ((b0 & 15) << 12) | ((b1 & 63) << 6) | b2 & 63;
            return 184549376 | u;
        case 238 :
        case 239 :
            exit = 1;
            break;
        case 240 :
            var i$3 = i + 1 | 0;
            if (i$3 > max) {
              return 16842749;
            }
            var b1$1 = b[i$3];
            if (b1$1 < 144 || 191 < b1$1) {
              return 16842749;
            }
            var i$4 = i$3 + 1 | 0;
            if (i$4 > max) {
              return 33619965;
            }
            var b2$1 = b[i$4];
            if ((b2$1 >>> 6) !== 2) {
              return 33619965;
            }
            var i$5 = i$4 + 1 | 0;
            if (i$5 > max) {
              return 50397181;
            }
            var b3 = b[i$5];
            if ((b3 >>> 6) !== 2) {
              return 50397181;
            }
            var u$1 = ((b0 & 7) << 18) | ((b1$1 & 63) << 12) | ((b2$1 & 63) << 6) | b3 & 63;
            return 201326592 | u$1;
        case 241 :
        case 242 :
        case 243 :
            exit = 2;
            break;
        case 244 :
            var i$6 = i + 1 | 0;
            if (i$6 > max) {
              return 16842749;
            }
            var b1$2 = b[i$6];
            if ((b1$2 >>> 4) !== 8) {
              return 16842749;
            }
            var i$7 = i$6 + 1 | 0;
            if (i$7 > max) {
              return 33619965;
            }
            var b2$2 = b[i$7];
            if ((b2$2 >>> 6) !== 2) {
              return 33619965;
            }
            var i$8 = i$7 + 1 | 0;
            if (i$8 > max) {
              return 50397181;
            }
            var b3$1 = b[i$8];
            if ((b3$1 >>> 6) !== 2) {
              return 50397181;
            }
            var u$2 = ((b0 & 7) << 18) | ((b1$2 & 63) << 12) | ((b2$2 & 63) << 6) | b3$1 & 63;
            return 201326592 | u$2;
        
      }
    } else if (b0 >= 225) {
      exit = 1;
    } else {
      var i$9 = i + 1 | 0;
      if (i$9 > max) {
        return 16842749;
      }
      var b1$3 = b[i$9];
      if ((b1$3 >>> 5) !== 5) {
        return 16842749;
      }
      var i$10 = i$9 + 1 | 0;
      if (i$10 > max) {
        return 33619965;
      }
      var b2$3 = b[i$10];
      if ((b2$3 >>> 6) !== 2) {
        return 33619965;
      }
      var u$3 = ((b0 & 15) << 12) | ((b1$3 & 63) << 6) | b2$3 & 63;
      return 184549376 | u$3;
    }
  } else {
    if (b0 < 128) {
      return 150994944 | b0;
    }
    if (b0 < 194) {
      return 16842749;
    }
    var i$11 = i + 1 | 0;
    if (i$11 > max) {
      return 16842749;
    }
    var b1$4 = b[i$11];
    if ((b1$4 >>> 6) !== 2) {
      return 16842749;
    }
    var u$4 = ((b0 & 31) << 6) | b1$4 & 63;
    return 167772160 | u$4;
  }
  switch (exit) {
    case 1 :
        var i$12 = i + 1 | 0;
        if (i$12 > max) {
          return 16842749;
        }
        var b1$5 = b[i$12];
        if ((b1$5 >>> 6) !== 2) {
          return 16842749;
        }
        var i$13 = i$12 + 1 | 0;
        if (i$13 > max) {
          return 33619965;
        }
        var b2$4 = b[i$13];
        if ((b2$4 >>> 6) !== 2) {
          return 33619965;
        }
        var u$5 = ((b0 & 15) << 12) | ((b1$5 & 63) << 6) | b2$4 & 63;
        return 184549376 | u$5;
    case 2 :
        var i$14 = i + 1 | 0;
        if (i$14 > max) {
          return 16842749;
        }
        var b1$6 = b[i$14];
        if ((b1$6 >>> 6) !== 2) {
          return 16842749;
        }
        var i$15 = i$14 + 1 | 0;
        if (i$15 > max) {
          return 33619965;
        }
        var b2$5 = b[i$15];
        if ((b2$5 >>> 6) !== 2) {
          return 33619965;
        }
        var i$16 = i$15 + 1 | 0;
        if (i$16 > max) {
          return 50397181;
        }
        var b3$2 = b[i$16];
        if ((b3$2 >>> 6) !== 2) {
          return 50397181;
        }
        var u$6 = ((b0 & 7) << 18) | ((b1$6 & 63) << 12) | ((b2$5 & 63) << 6) | b3$2 & 63;
        return 201326592 | u$6;
    
  }
}

function set_utf_8_uchar(b, i, u) {
  var max = b.length - 1 | 0;
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "bytes.cppo.ml",
            654,
            20
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 127) {
    Caml_bytes.set(b, i, u$1);
    return 1;
  }
  if (u$1 <= 2047) {
    var last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 192 | (u$1 >>> 6));
      b[last] = 128 | u$1 & 63;
      return 2;
    }
  }
  if (u$1 <= 65535) {
    var last$1 = i + 2 | 0;
    if (last$1 > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 224 | (u$1 >>> 12));
      b[i + 1 | 0] = 128 | (u$1 >>> 6) & 63;
      b[last$1] = 128 | u$1 & 63;
      return 3;
    }
  }
  if (u$1 <= 1114111) {
    var last$2 = i + 3 | 0;
    if (last$2 > max) {
      return 0;
    } else {
      Caml_bytes.set(b, i, 240 | (u$1 >>> 18));
      b[i + 1 | 0] = 128 | (u$1 >>> 12) & 63;
      b[i + 2 | 0] = 128 | (u$1 >>> 6) & 63;
      b[last$2] = 128 | u$1 & 63;
      return 4;
    }
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "bytes.cppo.ml",
          679,
          9
        ],
        Error: new Error()
      };
}

function is_valid_utf_8(b) {
  var max = b.length - 1 | 0;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i > max) {
      return true;
    }
    var match = b[i];
    var exit = 0;
    if (match >= 224) {
      if (match >= 237) {
        if (match >= 245) {
          return false;
        }
        switch (match) {
          case 237 :
              var last = i + 2 | 0;
              if (last > max || (b[i + 1 | 0] >>> 5) !== 4 || (b[last] >>> 6) !== 2) {
                return false;
              }
              _i = last + 1 | 0;
              continue ;
          case 238 :
          case 239 :
              exit = 1;
              break;
          case 240 :
              var last$1 = i + 3 | 0;
              var tmp = true;
              if (last$1 <= max) {
                var b$1 = b[i + 1 | 0];
                tmp = b$1 < 144 || 191 < b$1 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$1] >>> 6) !== 2;
              }
              if (tmp) {
                return false;
              }
              _i = last$1 + 1 | 0;
              continue ;
          case 241 :
          case 242 :
          case 243 :
              exit = 2;
              break;
          case 244 :
              var last$2 = i + 3 | 0;
              if (last$2 > max || (b[i + 1 | 0] >>> 4) !== 8 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$2] >>> 6) !== 2) {
                return false;
              }
              _i = last$2 + 1 | 0;
              continue ;
          
        }
      } else if (match >= 225) {
        exit = 1;
      } else {
        var last$3 = i + 2 | 0;
        if (last$3 > max || (b[i + 1 | 0] >>> 5) !== 5 || (b[last$3] >>> 6) !== 2) {
          return false;
        }
        _i = last$3 + 1 | 0;
        continue ;
      }
    } else {
      if (match >= 128) {
        if (match < 194) {
          return false;
        }
        var last$4 = i + 1 | 0;
        if (last$4 > max || (b[last$4] >>> 6) !== 2) {
          return false;
        }
        _i = last$4 + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    }
    switch (exit) {
      case 1 :
          var last$5 = i + 2 | 0;
          if (last$5 > max || (b[i + 1 | 0] >>> 6) !== 2 || (b[last$5] >>> 6) !== 2) {
            return false;
          }
          _i = last$5 + 1 | 0;
          continue ;
      case 2 :
          var last$6 = i + 3 | 0;
          if (last$6 > max || (b[i + 1 | 0] >>> 6) !== 2 || (b[i + 2 | 0] >>> 6) !== 2 || (b[last$6] >>> 6) !== 2) {
            return false;
          }
          _i = last$6 + 1 | 0;
          continue ;
      
    }
  };
}

function get_utf_16be_uchar(b, i) {
  var max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  if (i === max) {
    return 16842749;
  }
  var u = unsafe_get_uint16_be(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  var last = i + 3 | 0;
  if (last > max) {
    return (((max - i | 0) + 1 | 0) << 24) | 65533;
  }
  var u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  var u$2 = (((u & 1023) << 10) | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}

function set_utf_16be_uchar(b, i, u) {
  var max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "bytes.cppo.ml",
            766,
            20
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      unsafe_set_uint16_be(b, i, u$1);
      return 2;
    }
  }
  if (u$1 <= 1114111) {
    var last$1 = i + 3 | 0;
    if (last$1 > max) {
      return 0;
    }
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    unsafe_set_uint16_be(b, i, hi);
    unsafe_set_uint16_be(b, i + 2 | 0, lo);
    return 4;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "bytes.cppo.ml",
          777,
          9
        ],
        Error: new Error()
      };
}

function is_valid_utf_16be(b) {
  var max = b.length - 1 | 0;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    var u = unsafe_get_uint16_be(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue ;
    }
    if (u > 56319) {
      return false;
    }
    var last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    var u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue ;
  };
}

function get_utf_16le_uchar(b, i) {
  var max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  if (i === max) {
    return 16842749;
  }
  var u = unsafe_get_uint16_le(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  var last = i + 3 | 0;
  if (last > max) {
    return (((max - i | 0) + 1 | 0) << 24) | 65533;
  }
  var u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  var u$2 = (((u & 1023) << 10) | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}

function set_utf_16le_uchar(b, i, u) {
  var max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "index out of bounds",
          Error: new Error()
        };
  }
  var u$1 = u;
  if (u$1 < 0) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "bytes.cppo.ml",
            820,
            20
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var last = i + 1 | 0;
    if (last > max) {
      return 0;
    } else {
      unsafe_set_uint16_le(b, i, u$1);
      return 2;
    }
  }
  if (u$1 <= 1114111) {
    var last$1 = i + 3 | 0;
    if (last$1 > max) {
      return 0;
    }
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    unsafe_set_uint16_le(b, i, hi);
    unsafe_set_uint16_le(b, i + 2 | 0, lo);
    return 4;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "bytes.cppo.ml",
          831,
          9
        ],
        Error: new Error()
      };
}

function is_valid_utf_16le(b) {
  var max = b.length - 1 | 0;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    var u = unsafe_get_uint16_le(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue ;
    }
    if (u > 56319) {
      return false;
    }
    var last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    var u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue ;
  };
}

var equal = Caml_bytes.caml_bytes_equal;

var unsafe_to_string = Caml_bytes.bytes_to_string;

var unsafe_of_string = Caml_bytes.bytes_of_string;

var get_uint8 = Caml_bytes.get;

var get_uint16_ne = Caml_bytes.get16;

var get_int32_ne = Caml_bytes.get32;

var get_int64_ne = Caml_bytes.get64;

var set_int8 = Caml_bytes.set;

var set_uint16_be = set_int16_be;

var set_uint16_le = set_int16_le;

var set_int16_ne = Caml_bytes.set16;

var set_int32_ne = Caml_bytes.set32;

var set_int64_ne = Caml_bytes.set64;

export {
  make ,
  init ,
  empty ,
  copy ,
  of_string ,
  to_string ,
  sub ,
  sub_string ,
  extend ,
  fill ,
  blit ,
  blit_string ,
  concat ,
  cat ,
  iter ,
  iteri ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  for_all ,
  exists ,
  trim ,
  escaped ,
  index ,
  index_opt ,
  rindex ,
  rindex_opt ,
  index_from ,
  index_from_opt ,
  rindex_from ,
  rindex_from_opt ,
  contains ,
  contains_from ,
  rcontains_from ,
  uppercase_ascii ,
  lowercase_ascii ,
  capitalize_ascii ,
  uncapitalize_ascii ,
  compare ,
  equal ,
  starts_with ,
  ends_with ,
  unsafe_to_string ,
  unsafe_of_string ,
  split_on_char ,
  to_seq ,
  to_seqi ,
  of_seq ,
  get_utf_8_uchar ,
  set_utf_8_uchar ,
  is_valid_utf_8 ,
  get_utf_16be_uchar ,
  set_utf_16be_uchar ,
  is_valid_utf_16be ,
  get_utf_16le_uchar ,
  set_utf_16le_uchar ,
  is_valid_utf_16le ,
  get_uint8 ,
  get_int8 ,
  get_uint16_ne ,
  get_uint16_be ,
  get_uint16_le ,
  get_int16_ne ,
  get_int16_be ,
  get_int16_le ,
  get_int32_ne ,
  get_int32_be ,
  get_int32_le ,
  get_int64_ne ,
  get_int64_be ,
  get_int64_le ,
  set_uint8 ,
  set_int8 ,
  set_uint16_ne ,
  set_uint16_be ,
  set_uint16_le ,
  set_int16_ne ,
  set_int16_be ,
  set_int16_le ,
  set_int32_ne ,
  set_int32_be ,
  set_int32_le ,
  set_int64_ne ,
  set_int64_be ,
  set_int64_le ,
  unsafe_escape ,
}
/* No side effect */
`,xu=`// Generated by Melange

import * as Stdlib__Bytes from "./bytes.js";

var make = Stdlib__Bytes.make;

var init = Stdlib__Bytes.init;

var empty = Stdlib__Bytes.empty;

var copy = Stdlib__Bytes.copy;

var of_string = Stdlib__Bytes.of_string;

var to_string = Stdlib__Bytes.to_string;

var sub = Stdlib__Bytes.sub;

var sub_string = Stdlib__Bytes.sub_string;

var extend = Stdlib__Bytes.extend;

var fill = Stdlib__Bytes.fill;

var blit = Stdlib__Bytes.blit;

var blit_string = Stdlib__Bytes.blit_string;

var concat = Stdlib__Bytes.concat;

var cat = Stdlib__Bytes.cat;

var iter = Stdlib__Bytes.iter;

var iteri = Stdlib__Bytes.iteri;

var map = Stdlib__Bytes.map;

var mapi = Stdlib__Bytes.mapi;

var fold_left = Stdlib__Bytes.fold_left;

var fold_right = Stdlib__Bytes.fold_right;

var for_all = Stdlib__Bytes.for_all;

var exists = Stdlib__Bytes.exists;

var trim = Stdlib__Bytes.trim;

var escaped = Stdlib__Bytes.escaped;

var index = Stdlib__Bytes.index;

var index_opt = Stdlib__Bytes.index_opt;

var rindex = Stdlib__Bytes.rindex;

var rindex_opt = Stdlib__Bytes.rindex_opt;

var index_from = Stdlib__Bytes.index_from;

var index_from_opt = Stdlib__Bytes.index_from_opt;

var rindex_from = Stdlib__Bytes.rindex_from;

var rindex_from_opt = Stdlib__Bytes.rindex_from_opt;

var contains = Stdlib__Bytes.contains;

var contains_from = Stdlib__Bytes.contains_from;

var rcontains_from = Stdlib__Bytes.rcontains_from;

var uppercase_ascii = Stdlib__Bytes.uppercase_ascii;

var lowercase_ascii = Stdlib__Bytes.lowercase_ascii;

var capitalize_ascii = Stdlib__Bytes.capitalize_ascii;

var uncapitalize_ascii = Stdlib__Bytes.uncapitalize_ascii;

var compare = Stdlib__Bytes.compare;

var equal = Stdlib__Bytes.equal;

var starts_with = Stdlib__Bytes.starts_with;

var ends_with = Stdlib__Bytes.ends_with;

var unsafe_to_string = Stdlib__Bytes.unsafe_to_string;

var unsafe_of_string = Stdlib__Bytes.unsafe_of_string;

var split_on_char = Stdlib__Bytes.split_on_char;

var to_seq = Stdlib__Bytes.to_seq;

var to_seqi = Stdlib__Bytes.to_seqi;

var of_seq = Stdlib__Bytes.of_seq;

var unsafe_escape = Stdlib__Bytes.unsafe_escape;

export {
  make ,
  init ,
  empty ,
  copy ,
  of_string ,
  to_string ,
  sub ,
  sub_string ,
  extend ,
  fill ,
  blit ,
  blit_string ,
  concat ,
  cat ,
  iter ,
  iteri ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  for_all ,
  exists ,
  trim ,
  escaped ,
  index ,
  index_opt ,
  rindex ,
  rindex_opt ,
  index_from ,
  index_from_opt ,
  rindex_from ,
  rindex_from_opt ,
  contains ,
  contains_from ,
  rcontains_from ,
  uppercase_ascii ,
  lowercase_ascii ,
  capitalize_ascii ,
  uncapitalize_ascii ,
  compare ,
  equal ,
  starts_with ,
  ends_with ,
  unsafe_to_string ,
  unsafe_of_string ,
  split_on_char ,
  to_seq ,
  to_seqi ,
  of_seq ,
  unsafe_escape ,
}
/* No side effect */
`,$u=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Stdlib__Obj from "./obj.js";

function register(name, v) {
  Caml_external_polyfill.resolve("caml_register_named_value")(name, v);
}

function register_exception(name, exn) {
  var slot = (exn.TAG | 0) === Stdlib__Obj.object_tag ? exn : exn[0];
  Caml_external_polyfill.resolve("caml_register_named_value")(name, slot);
}

export {
  register ,
  register_exception ,
}
/* No side effect */
`,Eu=`// Generated by Melange


function make(v) {
  return {
          v: v
        };
}

function get(r) {
  return r.v;
}

function set(r, v) {
  r.v = v;
}

function exchange(r, v) {
  var cur = r.v;
  r.v = v;
  return cur;
}

function compare_and_set(r, seen, v) {
  var cur = r.v;
  if (cur === seen) {
    r.v = v;
    return true;
  } else {
    return false;
  }
}

function fetch_and_add(r, n) {
  var cur = r.v;
  r.v = cur + n | 0;
  return cur;
}

function incr(r) {
  fetch_and_add(r, 1);
}

function decr(r) {
  fetch_and_add(r, -1);
}

export {
  make ,
  get ,
  set ,
  exchange ,
  compare_and_set ,
  fetch_and_add ,
  incr ,
  decr ,
}
/* No side effect */
`,ku=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__String from "./string.js";

function create_char_set(param) {
  return Stdlib__Bytes.make(32, /* '\\000' */0);
}

function add_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  Caml_bytes.set(char_set, str_ind, Stdlib.char_of_int(Caml_bytes.get(char_set, str_ind) | mask));
}

var freeze_char_set = Stdlib__Bytes.to_string;

function rev_char_set(char_set) {
  var char_set$p = Stdlib__Bytes.make(32, /* '\\000' */0);
  for(var i = 0; i <= 31; ++i){
    Caml_bytes.set(char_set$p, i, Stdlib.char_of_int(Caml_string.get(char_set, i) ^ 255));
  }
  return Caml_bytes.bytes_to_string(char_set$p);
}

function is_in_char_set(char_set, c) {
  var str_ind = (c >>> 3);
  var mask = (1 << (c & 7));
  return (Caml_string.get(char_set, str_ind) & mask) !== 0;
}

function pad_of_pad_opt(pad_opt) {
  if (pad_opt !== undefined) {
    return {
            TAG: /* Lit_padding */0,
            _0: /* Right */1,
            _1: pad_opt
          };
  } else {
    return /* No_padding */0;
  }
}

function prec_of_prec_opt(prec_opt) {
  if (prec_opt !== undefined) {
    return /* Lit_precision */{
            _0: prec_opt
          };
  } else {
    return /* No_precision */0;
  }
}

function param_format_of_ignored_format(ign, fmt) {
  if (typeof ign === "number") {
    switch (ign) {
      case /* Ignored_char */0 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Char */0,
                    _0: fmt
                  }
                };
      case /* Ignored_caml_char */1 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: fmt
                  }
                };
      case /* Ignored_reader */2 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Reader */19,
                    _0: fmt
                  }
                };
      case /* Ignored_scan_next_char */3 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_next_char */22,
                    _0: fmt
                  }
                };
      
    }
  } else {
    switch (ign.TAG | 0) {
      case /* Ignored_string */0 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* String */2,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_caml_string */1 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_int */2 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int */4,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_int32 */3 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int32 */5,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_nativeint */4 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Nativeint */6,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_int64 */5 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Int64 */7,
                    _0: ign._0,
                    _1: pad_of_pad_opt(ign._1),
                    _2: /* No_precision */0,
                    _3: fmt
                  }
                };
      case /* Ignored_float */6 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Float */8,
                    _0: [
                      /* Float_flag_ */0,
                      /* Float_f */0
                    ],
                    _1: pad_of_pad_opt(ign._0),
                    _2: prec_of_prec_opt(ign._1),
                    _3: fmt
                  }
                };
      case /* Ignored_bool */7 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Bool */9,
                    _0: pad_of_pad_opt(ign._0),
                    _1: fmt
                  }
                };
      case /* Ignored_format_arg */8 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Format_arg */13,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_format_subst */9 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Format_subst */14,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_scan_char_set */10 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_char_set */20,
                    _0: ign._0,
                    _1: ign._1,
                    _2: fmt
                  }
                };
      case /* Ignored_scan_get_counter */11 :
          return /* Param_format_EBB */{
                  _0: {
                    TAG: /* Scan_get_counter */21,
                    _0: ign._0,
                    _1: fmt
                  }
                };
      
    }
  }
}

function default_float_precision(fconv) {
  var match = fconv[1];
  if (match !== 5) {
    return -6;
  } else {
    return 12;
  }
}

function buffer_check_size(buf, overhead) {
  var len = buf.bytes.length;
  var min_len = buf.ind + overhead | 0;
  if (min_len <= len) {
    return ;
  }
  var new_len = Stdlib__Int.max((len << 1), min_len);
  var new_str = Caml_bytes.caml_create_bytes(new_len);
  Stdlib__Bytes.blit(buf.bytes, 0, new_str, 0, len);
  buf.bytes = new_str;
}

function buffer_add_char(buf, c) {
  buffer_check_size(buf, 1);
  Caml_bytes.set(buf.bytes, buf.ind, c);
  buf.ind = buf.ind + 1 | 0;
}

function buffer_add_string(buf, s) {
  var str_len = s.length;
  buffer_check_size(buf, str_len);
  Stdlib__String.blit(s, 0, buf.bytes, buf.ind, str_len);
  buf.ind = buf.ind + str_len | 0;
}

function buffer_contents(buf) {
  return Stdlib__Bytes.sub_string(buf.bytes, 0, buf.ind);
}

function char_of_iconv(iconv) {
  switch (iconv) {
    case /* Int_x */6 :
    case /* Int_Cx */7 :
        return /* 'x' */120;
    case /* Int_X */8 :
    case /* Int_CX */9 :
        return /* 'X' */88;
    case /* Int_o */10 :
    case /* Int_Co */11 :
        return /* 'o' */111;
    case /* Int_d */0 :
    case /* Int_pd */1 :
    case /* Int_sd */2 :
    case /* Int_Cd */13 :
        return /* 'd' */100;
    case /* Int_i */3 :
    case /* Int_pi */4 :
    case /* Int_si */5 :
    case /* Int_Ci */14 :
        return /* 'i' */105;
    case /* Int_u */12 :
    case /* Int_Cu */15 :
        return /* 'u' */117;
    
  }
}

function char_of_fconv(cFOpt, fconv) {
  var cF = cFOpt !== undefined ? cFOpt : /* 'F' */70;
  var match = fconv[1];
  switch (match) {
    case /* Float_f */0 :
        return /* 'f' */102;
    case /* Float_e */1 :
        return /* 'e' */101;
    case /* Float_E */2 :
        return /* 'E' */69;
    case /* Float_g */3 :
        return /* 'g' */103;
    case /* Float_G */4 :
        return /* 'G' */71;
    case /* Float_F */5 :
        return cF;
    case /* Float_h */6 :
        return /* 'h' */104;
    case /* Float_H */7 :
        return /* 'H' */72;
    case /* Float_CF */8 :
        return /* 'F' */70;
    
  }
}

function char_of_counter(counter) {
  switch (counter) {
    case /* Line_counter */0 :
        return /* 'l' */108;
    case /* Char_counter */1 :
        return /* 'n' */110;
    case /* Token_counter */2 :
        return /* 'N' */78;
    
  }
}

function bprint_char_set(buf, char_set) {
  var print_out = function (set, _i) {
    while(true) {
      var i = _i;
      if (i >= 256) {
        return ;
      }
      if (is_in_char_set(set, Stdlib.char_of_int(i))) {
        var match = Stdlib.char_of_int(i);
        if (match > 93 || match < 45) {
          if (match >= 255) {
            return print_char(buf, 255);
          } else {
            return print_second(set, i + 1 | 0);
          }
        } else if (match > 92 || match < 46) {
          return print_out(set, i + 1 | 0);
        } else {
          return print_second(set, i + 1 | 0);
        }
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var print_char = function (buf, i) {
    var c = Stdlib.char_of_int(i);
    if (c !== 37) {
      if (c !== 64) {
        return buffer_add_char(buf, c);
      } else {
        buffer_add_char(buf, /* '%' */37);
        return buffer_add_char(buf, /* '@' */64);
      }
    } else {
      buffer_add_char(buf, /* '%' */37);
      return buffer_add_char(buf, /* '%' */37);
    }
  };
  var print_second = function (set, i) {
    if (is_in_char_set(set, Stdlib.char_of_int(i))) {
      var match = Stdlib.char_of_int(i);
      if (match > 93 || match < 45) {
        if (match >= 255) {
          print_char(buf, 254);
          return print_char(buf, 255);
        }
        
      } else if ((match > 92 || match < 46) && !is_in_char_set(set, Stdlib.char_of_int(i + 1 | 0))) {
        print_char(buf, i - 1 | 0);
        return print_out(set, i + 1 | 0);
      }
      if (is_in_char_set(set, Stdlib.char_of_int(i + 1 | 0))) {
        var i$1 = i - 1 | 0;
        var _j = i + 2 | 0;
        while(true) {
          var j = _j;
          if (j === 256 || !is_in_char_set(set, Stdlib.char_of_int(j))) {
            print_char(buf, i$1);
            print_char(buf, /* '-' */45);
            print_char(buf, j - 1 | 0);
            if (j < 256) {
              return print_out(set, j + 1 | 0);
            } else {
              return ;
            }
          }
          _j = j + 1 | 0;
          continue ;
        };
      } else {
        print_char(buf, i - 1 | 0);
        print_char(buf, i);
        return print_out(set, i + 2 | 0);
      }
    }
    print_char(buf, i - 1 | 0);
    print_out(set, i + 1 | 0);
  };
  var print_start = function (set) {
    var is_alone = function (c) {
      var before = Stdlib__Char.chr(c - 1 | 0);
      var after = Stdlib__Char.chr(c + 1 | 0);
      if (is_in_char_set(set, c)) {
        return !(is_in_char_set(set, before) && is_in_char_set(set, after));
      } else {
        return false;
      }
    };
    if (is_alone(/* ']' */93)) {
      buffer_add_char(buf, /* ']' */93);
    }
    print_out(set, 1);
    if (is_alone(/* '-' */45)) {
      return buffer_add_char(buf, /* '-' */45);
    }
    
  };
  buffer_add_char(buf, /* '[' */91);
  print_start(is_in_char_set(char_set, /* '\\000' */0) ? (buffer_add_char(buf, /* '^' */94), rev_char_set(char_set)) : char_set);
  buffer_add_char(buf, /* ']' */93);
}

function bprint_padty(buf, padty) {
  switch (padty) {
    case /* Left */0 :
        return buffer_add_char(buf, /* '-' */45);
    case /* Right */1 :
        return ;
    case /* Zeros */2 :
        return buffer_add_char(buf, /* '0' */48);
    
  }
}

function bprint_ignored_flag(buf, ign_flag) {
  if (ign_flag) {
    return buffer_add_char(buf, /* '_' */95);
  }
  
}

function bprint_pad_opt(buf, pad_opt) {
  if (pad_opt !== undefined) {
    return buffer_add_string(buf, Caml_format.caml_format_int("%d", pad_opt));
  }
  
}

function bprint_padding(buf, pad) {
  if (typeof pad === "number") {
    return ;
  }
  if (pad.TAG === /* Lit_padding */0) {
    bprint_padty(buf, pad._0);
    return buffer_add_string(buf, Caml_format.caml_format_int("%d", pad._1));
  }
  bprint_padty(buf, pad._0);
  buffer_add_char(buf, /* '*' */42);
}

function bprint_precision(buf, prec) {
  if (typeof prec === "number") {
    if (prec) {
      return buffer_add_string(buf, ".*");
    } else {
      return ;
    }
  } else {
    buffer_add_char(buf, /* '.' */46);
    return buffer_add_string(buf, Caml_format.caml_format_int("%d", prec._0));
  }
}

function bprint_iconv_flag(buf, iconv) {
  switch (iconv) {
    case /* Int_pd */1 :
    case /* Int_pi */4 :
        return buffer_add_char(buf, /* '+' */43);
    case /* Int_sd */2 :
    case /* Int_si */5 :
        return buffer_add_char(buf, /* ' ' */32);
    case /* Int_d */0 :
    case /* Int_i */3 :
    case /* Int_x */6 :
    case /* Int_X */8 :
    case /* Int_o */10 :
    case /* Int_u */12 :
        return ;
    case /* Int_Cx */7 :
    case /* Int_CX */9 :
    case /* Int_Co */11 :
    case /* Int_Cd */13 :
    case /* Int_Ci */14 :
    case /* Int_Cu */15 :
        return buffer_add_char(buf, /* '#' */35);
    
  }
}

function bprint_int_fmt(buf, ign_flag, iconv, pad, prec) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_iconv_flag(buf, iconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, c);
  buffer_add_char(buf, char_of_iconv(iconv));
}

function bprint_fconv_flag(buf, fconv) {
  var match = fconv[0];
  switch (match) {
    case /* Float_flag_ */0 :
        break;
    case /* Float_flag_p */1 :
        buffer_add_char(buf, /* '+' */43);
        break;
    case /* Float_flag_s */2 :
        buffer_add_char(buf, /* ' ' */32);
        break;
    
  }
  var match$1 = fconv[1];
  if (match$1 >= 8) {
    return buffer_add_char(buf, /* '#' */35);
  }
  
}

function bprint_float_fmt(buf, ign_flag, fconv, pad, prec) {
  buffer_add_char(buf, /* '%' */37);
  bprint_ignored_flag(buf, ign_flag);
  bprint_fconv_flag(buf, fconv);
  bprint_padding(buf, pad);
  bprint_precision(buf, prec);
  buffer_add_char(buf, char_of_fconv(undefined, fconv));
}

function string_of_formatting_lit(formatting_lit) {
  if (typeof formatting_lit === "number") {
    switch (formatting_lit) {
      case /* Close_box */0 :
          return "@]";
      case /* Close_tag */1 :
          return "@}";
      case /* FFlush */2 :
          return "@?";
      case /* Force_newline */3 :
          return "@\\n";
      case /* Flush_newline */4 :
          return "@.";
      case /* Escaped_at */5 :
          return "@@";
      case /* Escaped_percent */6 :
          return "@%";
      
    }
  } else {
    switch (formatting_lit.TAG | 0) {
      case /* Break */0 :
      case /* Magic_size */1 :
          return formatting_lit._0;
      case /* Scan_indic */2 :
          return "@" + Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, formatting_lit._0));
      
    }
  }
}

function bprint_char_literal(buf, chr) {
  if (chr !== 37) {
    return buffer_add_char(buf, chr);
  } else {
    return buffer_add_string(buf, "%%");
  }
}

function bprint_string_literal(buf, str) {
  for(var i = 0 ,i_finish = str.length; i < i_finish; ++i){
    bprint_char_literal(buf, Caml_string.get(str, i));
  }
}

function bprint_fmtty(buf, _fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return ;
    }
    switch (fmtty.TAG | 0) {
      case /* Char_ty */0 :
          buffer_add_string(buf, "%c");
          _fmtty = fmtty._0;
          continue ;
      case /* String_ty */1 :
          buffer_add_string(buf, "%s");
          _fmtty = fmtty._0;
          continue ;
      case /* Int_ty */2 :
          buffer_add_string(buf, "%i");
          _fmtty = fmtty._0;
          continue ;
      case /* Int32_ty */3 :
          buffer_add_string(buf, "%li");
          _fmtty = fmtty._0;
          continue ;
      case /* Nativeint_ty */4 :
          buffer_add_string(buf, "%ni");
          _fmtty = fmtty._0;
          continue ;
      case /* Int64_ty */5 :
          buffer_add_string(buf, "%Li");
          _fmtty = fmtty._0;
          continue ;
      case /* Float_ty */6 :
          buffer_add_string(buf, "%f");
          _fmtty = fmtty._0;
          continue ;
      case /* Bool_ty */7 :
          buffer_add_string(buf, "%B");
          _fmtty = fmtty._0;
          continue ;
      case /* Format_arg_ty */8 :
          buffer_add_string(buf, "%{");
          bprint_fmtty(buf, fmtty._0);
          buffer_add_string(buf, "%}");
          _fmtty = fmtty._1;
          continue ;
      case /* Format_subst_ty */9 :
          buffer_add_string(buf, "%(");
          bprint_fmtty(buf, fmtty._0);
          buffer_add_string(buf, "%)");
          _fmtty = fmtty._2;
          continue ;
      case /* Alpha_ty */10 :
          buffer_add_string(buf, "%a");
          _fmtty = fmtty._0;
          continue ;
      case /* Theta_ty */11 :
          buffer_add_string(buf, "%t");
          _fmtty = fmtty._0;
          continue ;
      case /* Any_ty */12 :
          buffer_add_string(buf, "%?");
          _fmtty = fmtty._0;
          continue ;
      case /* Reader_ty */13 :
          buffer_add_string(buf, "%r");
          _fmtty = fmtty._0;
          continue ;
      case /* Ignored_reader_ty */14 :
          buffer_add_string(buf, "%_r");
          _fmtty = fmtty._0;
          continue ;
      
    }
  };
}

function int_of_custom_arity(param) {
  if (param) {
    return 1 + int_of_custom_arity(param._0) | 0;
  } else {
    return 0;
  }
}

function bprint_fmt(buf, fmt) {
  var _fmt = fmt;
  var _ign_flag = false;
  while(true) {
    var ign_flag = _ign_flag;
    var fmt$1 = _fmt;
    if (typeof fmt$1 === "number") {
      return ;
    }
    switch (fmt$1.TAG | 0) {
      case /* Char */0 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* 'c' */99);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Caml_char */1 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* 'C' */67);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* String */2 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* 's' */115);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Caml_string */3 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* 'S' */83);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Int */4 :
          bprint_int_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Int32 */5 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'l' */108);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Nativeint */6 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'n' */110);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Int64 */7 :
          bprint_altint_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2, /* 'L' */76);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Float */8 :
          bprint_float_fmt(buf, ign_flag, fmt$1._0, fmt$1._1, fmt$1._2);
          _ign_flag = false;
          _fmt = fmt$1._3;
          continue ;
      case /* Bool */9 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_padding(buf, fmt$1._0);
          buffer_add_char(buf, /* 'B' */66);
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Flush */10 :
          buffer_add_string(buf, "%!");
          _fmt = fmt$1._0;
          continue ;
      case /* String_literal */11 :
          bprint_string_literal(buf, fmt$1._0);
          _fmt = fmt$1._1;
          continue ;
      case /* Char_literal */12 :
          bprint_char_literal(buf, fmt$1._0);
          _fmt = fmt$1._1;
          continue ;
      case /* Format_arg */13 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          buffer_add_char(buf, /* '{' */123);
          bprint_fmtty(buf, fmt$1._1);
          buffer_add_char(buf, /* '%' */37);
          buffer_add_char(buf, /* '}' */125);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Format_subst */14 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          buffer_add_char(buf, /* '(' */40);
          bprint_fmtty(buf, fmt$1._1);
          buffer_add_char(buf, /* '%' */37);
          buffer_add_char(buf, /* ')' */41);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Alpha */15 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* 'a' */97);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Theta */16 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* 't' */116);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Formatting_lit */17 :
          bprint_string_literal(buf, string_of_formatting_lit(fmt$1._0));
          _fmt = fmt$1._1;
          continue ;
      case /* Formatting_gen */18 :
          var fmting_gen = fmt$1._0;
          if (fmting_gen.TAG === /* Open_tag */0) {
            buffer_add_string(buf, "@{");
            buffer_add_string(buf, fmting_gen._0._1);
          } else {
            buffer_add_string(buf, "@[");
            buffer_add_string(buf, fmting_gen._0._1);
          }
          _fmt = fmt$1._1;
          continue ;
      case /* Reader */19 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, /* 'r' */114);
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Scan_char_set */20 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_pad_opt(buf, fmt$1._0);
          bprint_char_set(buf, fmt$1._1);
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      case /* Scan_get_counter */21 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          buffer_add_char(buf, char_of_counter(fmt$1._0));
          _ign_flag = false;
          _fmt = fmt$1._1;
          continue ;
      case /* Scan_next_char */22 :
          buffer_add_char(buf, /* '%' */37);
          bprint_ignored_flag(buf, ign_flag);
          bprint_string_literal(buf, "0c");
          _ign_flag = false;
          _fmt = fmt$1._0;
          continue ;
      case /* Ignored_param */23 :
          var fmt$p = param_format_of_ignored_format(fmt$1._0, fmt$1._1);
          _ign_flag = true;
          _fmt = fmt$p._0;
          continue ;
      case /* Custom */24 :
          for(var _i = 1 ,_i_finish = int_of_custom_arity(fmt$1._0); _i <= _i_finish; ++_i){
            buffer_add_char(buf, /* '%' */37);
            bprint_ignored_flag(buf, ign_flag);
            buffer_add_char(buf, /* '?' */63);
          }
          _ign_flag = false;
          _fmt = fmt$1._2;
          continue ;
      
    }
  };
}

function string_of_fmt(fmt) {
  var buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  bprint_fmt(buf, fmt);
  return buffer_contents(buf);
}

function symm(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  }
  switch (param.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: symm(param._0)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: symm(param._0)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: symm(param._0)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: symm(param._0)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: symm(param._0)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: symm(param._0)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: symm(param._0)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: symm(param._0)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: param._0,
                _1: symm(param._1)
              };
    case /* Format_subst_ty */9 :
        return {
                TAG: /* Format_subst_ty */9,
                _0: param._1,
                _1: param._0,
                _2: symm(param._2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: symm(param._0)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: symm(param._0)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: symm(param._0)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: symm(param._0)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: symm(param._0)
              };
    
  }
}

function fmtty_rel_det(param) {
  if (typeof param === "number") {
    return [
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              }),
            (function (param) {
                return /* Refl */0;
              })
          ];
  }
  switch (param.TAG | 0) {
    case /* Char_ty */0 :
        var match = fmtty_rel_det(param._0);
        var af = match[1];
        var fa = match[0];
        return [
                (function (param) {
                    Curry._1(fa, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af, /* Refl */0);
                    return /* Refl */0;
                  }),
                match[2],
                match[3]
              ];
    case /* String_ty */1 :
        var match$1 = fmtty_rel_det(param._0);
        var af$1 = match$1[1];
        var fa$1 = match$1[0];
        return [
                (function (param) {
                    Curry._1(fa$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$1[2],
                match$1[3]
              ];
    case /* Int_ty */2 :
        var match$2 = fmtty_rel_det(param._0);
        var af$2 = match$2[1];
        var fa$2 = match$2[0];
        return [
                (function (param) {
                    Curry._1(fa$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$2[2],
                match$2[3]
              ];
    case /* Int32_ty */3 :
        var match$3 = fmtty_rel_det(param._0);
        var af$3 = match$3[1];
        var fa$3 = match$3[0];
        return [
                (function (param) {
                    Curry._1(fa$3, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$3, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$3[2],
                match$3[3]
              ];
    case /* Nativeint_ty */4 :
        var match$4 = fmtty_rel_det(param._0);
        var af$4 = match$4[1];
        var fa$4 = match$4[0];
        return [
                (function (param) {
                    Curry._1(fa$4, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$4, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$4[2],
                match$4[3]
              ];
    case /* Int64_ty */5 :
        var match$5 = fmtty_rel_det(param._0);
        var af$5 = match$5[1];
        var fa$5 = match$5[0];
        return [
                (function (param) {
                    Curry._1(fa$5, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$5, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$5[2],
                match$5[3]
              ];
    case /* Float_ty */6 :
        var match$6 = fmtty_rel_det(param._0);
        var af$6 = match$6[1];
        var fa$6 = match$6[0];
        return [
                (function (param) {
                    Curry._1(fa$6, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$6, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$6[2],
                match$6[3]
              ];
    case /* Bool_ty */7 :
        var match$7 = fmtty_rel_det(param._0);
        var af$7 = match$7[1];
        var fa$7 = match$7[0];
        return [
                (function (param) {
                    Curry._1(fa$7, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$7, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$7[2],
                match$7[3]
              ];
    case /* Format_arg_ty */8 :
        var match$8 = fmtty_rel_det(param._1);
        var af$8 = match$8[1];
        var fa$8 = match$8[0];
        return [
                (function (param) {
                    Curry._1(fa$8, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$8, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$8[2],
                match$8[3]
              ];
    case /* Format_subst_ty */9 :
        var match$9 = fmtty_rel_det(param._2);
        var de = match$9[3];
        var ed = match$9[2];
        var af$9 = match$9[1];
        var fa$9 = match$9[0];
        var ty = trans(symm(param._0), param._1);
        var match$10 = fmtty_rel_det(ty);
        var jd = match$10[3];
        var dj = match$10[2];
        var ga = match$10[1];
        var ag = match$10[0];
        return [
                (function (param) {
                    Curry._1(fa$9, /* Refl */0);
                    Curry._1(ag, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(ga, /* Refl */0);
                    Curry._1(af$9, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(ed, /* Refl */0);
                    Curry._1(dj, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(jd, /* Refl */0);
                    Curry._1(de, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    case /* Alpha_ty */10 :
        var match$11 = fmtty_rel_det(param._0);
        var af$10 = match$11[1];
        var fa$10 = match$11[0];
        return [
                (function (param) {
                    Curry._1(fa$10, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$10, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$11[2],
                match$11[3]
              ];
    case /* Theta_ty */11 :
        var match$12 = fmtty_rel_det(param._0);
        var af$11 = match$12[1];
        var fa$11 = match$12[0];
        return [
                (function (param) {
                    Curry._1(fa$11, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$11, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$12[2],
                match$12[3]
              ];
    case /* Any_ty */12 :
        var match$13 = fmtty_rel_det(param._0);
        var af$12 = match$13[1];
        var fa$12 = match$13[0];
        return [
                (function (param) {
                    Curry._1(fa$12, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$12, /* Refl */0);
                    return /* Refl */0;
                  }),
                match$13[2],
                match$13[3]
              ];
    case /* Reader_ty */13 :
        var match$14 = fmtty_rel_det(param._0);
        var de$1 = match$14[3];
        var ed$1 = match$14[2];
        var af$13 = match$14[1];
        var fa$13 = match$14[0];
        return [
                (function (param) {
                    Curry._1(fa$13, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$13, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(ed$1, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(de$1, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    case /* Ignored_reader_ty */14 :
        var match$15 = fmtty_rel_det(param._0);
        var de$2 = match$15[3];
        var ed$2 = match$15[2];
        var af$14 = match$15[1];
        var fa$14 = match$15[0];
        return [
                (function (param) {
                    Curry._1(fa$14, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(af$14, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(ed$2, /* Refl */0);
                    return /* Refl */0;
                  }),
                (function (param) {
                    Curry._1(de$2, /* Refl */0);
                    return /* Refl */0;
                  })
              ];
    
  }
}

function trans(ty1, ty2) {
  var exit = 0;
  if (typeof ty1 === "number") {
    if (typeof ty2 === "number") {
      return /* End_of_fmtty */0;
    }
    switch (ty2.TAG | 0) {
      case /* Format_arg_ty */8 :
          exit = 6;
          break;
      case /* Format_subst_ty */9 :
          exit = 7;
          break;
      case /* Alpha_ty */10 :
          exit = 1;
          break;
      case /* Theta_ty */11 :
          exit = 2;
          break;
      case /* Any_ty */12 :
          exit = 3;
          break;
      case /* Reader_ty */13 :
          exit = 4;
          break;
      case /* Ignored_reader_ty */14 :
          exit = 5;
          break;
      default:
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                850,
                23
              ],
              Error: new Error()
            };
    }
  } else {
    switch (ty1.TAG | 0) {
      case /* Char_ty */0 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Char_ty */0 :
                  return {
                          TAG: /* Char_ty */0,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* String_ty */1 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* String_ty */1 :
                  return {
                          TAG: /* String_ty */1,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int_ty */2 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int_ty */2 :
                  return {
                          TAG: /* Int_ty */2,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int32_ty */3 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int32_ty */3 :
                  return {
                          TAG: /* Int32_ty */3,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Nativeint_ty */4 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Nativeint_ty */4 :
                  return {
                          TAG: /* Nativeint_ty */4,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Int64_ty */5 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Int64_ty */5 :
                  return {
                          TAG: /* Int64_ty */5,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Float_ty */6 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Float_ty */6 :
                  return {
                          TAG: /* Float_ty */6,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Bool_ty */7 :
          if (typeof ty2 === "number") {
            exit = 8;
          } else {
            switch (ty2.TAG | 0) {
              case /* Bool_ty */7 :
                  return {
                          TAG: /* Bool_ty */7,
                          _0: trans(ty1._0, ty2._0)
                        };
              case /* Format_arg_ty */8 :
                  exit = 6;
                  break;
              case /* Format_subst_ty */9 :
                  exit = 7;
                  break;
              case /* Alpha_ty */10 :
                  exit = 1;
                  break;
              case /* Theta_ty */11 :
                  exit = 2;
                  break;
              case /* Any_ty */12 :
                  exit = 3;
                  break;
              case /* Reader_ty */13 :
                  exit = 4;
                  break;
              case /* Ignored_reader_ty */14 :
                  exit = 5;
                  break;
              
            }
          }
          break;
      case /* Format_arg_ty */8 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    836,
                    26
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Format_arg_ty */8 :
                return {
                        TAG: /* Format_arg_ty */8,
                        _0: trans(ty1._0, ty2._0),
                        _1: trans(ty1._1, ty2._1)
                      };
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                exit = 5;
                break;
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      836,
                      26
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Format_subst_ty */9 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    846,
                    28
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Format_arg_ty */8 :
                exit = 6;
                break;
            case /* Format_subst_ty */9 :
                var ty = trans(symm(ty1._1), ty2._0);
                var match = fmtty_rel_det(ty);
                Curry._1(match[1], /* Refl */0);
                Curry._1(match[3], /* Refl */0);
                return {
                        TAG: /* Format_subst_ty */9,
                        _0: ty1._0,
                        _1: ty2._1,
                        _2: trans(ty1._2, ty2._2)
                      };
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                exit = 5;
                break;
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      846,
                      28
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Alpha_ty */10 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    814,
                    21
                  ],
                  Error: new Error()
                };
          }
          if (ty2.TAG === /* Alpha_ty */10) {
            return {
                    TAG: /* Alpha_ty */10,
                    _0: trans(ty1._0, ty2._0)
                  };
          }
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  814,
                  21
                ],
                Error: new Error()
              };
      case /* Theta_ty */11 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    818,
                    21
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                return {
                        TAG: /* Theta_ty */11,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      818,
                      21
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Any_ty */12 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    822,
                    19
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                return {
                        TAG: /* Any_ty */12,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      822,
                      19
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Reader_ty */13 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    826,
                    22
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                return {
                        TAG: /* Reader_ty */13,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      826,
                      22
                    ],
                    Error: new Error()
                  };
          }
          break;
      case /* Ignored_reader_ty */14 :
          if (typeof ty2 === "number") {
            throw {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "camlinternalFormat.cppo.ml",
                    831,
                    30
                  ],
                  Error: new Error()
                };
          }
          switch (ty2.TAG | 0) {
            case /* Alpha_ty */10 :
                exit = 1;
                break;
            case /* Theta_ty */11 :
                exit = 2;
                break;
            case /* Any_ty */12 :
                exit = 3;
                break;
            case /* Reader_ty */13 :
                exit = 4;
                break;
            case /* Ignored_reader_ty */14 :
                return {
                        TAG: /* Ignored_reader_ty */14,
                        _0: trans(ty1._0, ty2._0)
                      };
            default:
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "camlinternalFormat.cppo.ml",
                      831,
                      30
                    ],
                    Error: new Error()
                  };
          }
          break;
      
    }
  }
  switch (exit) {
    case 1 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                815,
                21
              ],
              Error: new Error()
            };
    case 2 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                819,
                21
              ],
              Error: new Error()
            };
    case 3 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                823,
                19
              ],
              Error: new Error()
            };
    case 4 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                827,
                22
              ],
              Error: new Error()
            };
    case 5 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                832,
                30
              ],
              Error: new Error()
            };
    case 6 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                837,
                26
              ],
              Error: new Error()
            };
    case 7 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                847,
                28
              ],
              Error: new Error()
            };
    case 8 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                851,
                23
              ],
              Error: new Error()
            };
    
  }
}

function fmtty_of_formatting_gen(formatting_gen) {
  return fmtty_of_fmt(formatting_gen._0._0);
}

function fmtty_of_fmt(_fmtty) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return /* End_of_fmtty */0;
    }
    switch (fmtty.TAG | 0) {
      case /* String */2 :
      case /* Caml_string */3 :
          break;
      case /* Int */4 :
          var ty_rest = fmtty_of_fmt(fmtty._3);
          var prec_ty = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int_ty */2,
                _0: ty_rest
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty);
      case /* Int32 */5 :
          var ty_rest$1 = fmtty_of_fmt(fmtty._3);
          var prec_ty$1 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int32_ty */3,
                _0: ty_rest$1
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$1);
      case /* Nativeint */6 :
          var ty_rest$2 = fmtty_of_fmt(fmtty._3);
          var prec_ty$2 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Nativeint_ty */4,
                _0: ty_rest$2
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$2);
      case /* Int64 */7 :
          var ty_rest$3 = fmtty_of_fmt(fmtty._3);
          var prec_ty$3 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Int64_ty */5,
                _0: ty_rest$3
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$3);
      case /* Float */8 :
          var ty_rest$4 = fmtty_of_fmt(fmtty._3);
          var prec_ty$4 = fmtty_of_precision_fmtty(fmtty._2, {
                TAG: /* Float_ty */6,
                _0: ty_rest$4
              });
          return fmtty_of_padding_fmtty(fmtty._1, prec_ty$4);
      case /* Bool */9 :
          return fmtty_of_padding_fmtty(fmtty._0, {
                      TAG: /* Bool_ty */7,
                      _0: fmtty_of_fmt(fmtty._1)
                    });
      case /* Flush */10 :
          _fmtty = fmtty._0;
          continue ;
      case /* Format_arg */13 :
          return {
                  TAG: /* Format_arg_ty */8,
                  _0: fmtty._1,
                  _1: fmtty_of_fmt(fmtty._2)
                };
      case /* Format_subst */14 :
          var ty = fmtty._1;
          return {
                  TAG: /* Format_subst_ty */9,
                  _0: ty,
                  _1: ty,
                  _2: fmtty_of_fmt(fmtty._2)
                };
      case /* Alpha */15 :
          return {
                  TAG: /* Alpha_ty */10,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Theta */16 :
          return {
                  TAG: /* Theta_ty */11,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Formatting_gen */18 :
          return CamlinternalFormatBasics.concat_fmtty(fmtty_of_formatting_gen(fmtty._0), fmtty_of_fmt(fmtty._1));
      case /* Reader */19 :
          return {
                  TAG: /* Reader_ty */13,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Scan_char_set */20 :
          return {
                  TAG: /* String_ty */1,
                  _0: fmtty_of_fmt(fmtty._2)
                };
      case /* Scan_get_counter */21 :
          return {
                  TAG: /* Int_ty */2,
                  _0: fmtty_of_fmt(fmtty._1)
                };
      case /* Char */0 :
      case /* Caml_char */1 :
      case /* Scan_next_char */22 :
          return {
                  TAG: /* Char_ty */0,
                  _0: fmtty_of_fmt(fmtty._0)
                };
      case /* Ignored_param */23 :
          var ign = fmtty._0;
          var fmt = fmtty._1;
          if (typeof ign === "number") {
            if (ign === /* Ignored_reader */2) {
              return {
                      TAG: /* Ignored_reader_ty */14,
                      _0: fmtty_of_fmt(fmt)
                    };
            } else {
              return fmtty_of_fmt(fmt);
            }
          } else if (ign.TAG === /* Ignored_format_subst */9) {
            return CamlinternalFormatBasics.concat_fmtty(ign._1, fmtty_of_fmt(fmt));
          } else {
            return fmtty_of_fmt(fmt);
          }
      case /* Custom */24 :
          return fmtty_of_custom(fmtty._0, fmtty_of_fmt(fmtty._2));
      default:
        _fmtty = fmtty._1;
        continue ;
    }
    return fmtty_of_padding_fmtty(fmtty._0, {
                TAG: /* String_ty */1,
                _0: fmtty_of_fmt(fmtty._1)
              });
  };
}

function fmtty_of_custom(arity, fmtty) {
  if (arity) {
    return {
            TAG: /* Any_ty */12,
            _0: fmtty_of_custom(arity._0, fmtty)
          };
  } else {
    return fmtty;
  }
}

function fmtty_of_padding_fmtty(pad, fmtty) {
  if (typeof pad === "number" || pad.TAG === /* Lit_padding */0) {
    return fmtty;
  } else {
    return {
            TAG: /* Int_ty */2,
            _0: fmtty
          };
  }
}

function fmtty_of_precision_fmtty(prec, fmtty) {
  if (typeof prec === "number" && prec) {
    return {
            TAG: /* Int_ty */2,
            _0: fmtty
          };
  } else {
    return fmtty;
  }
}

var Type_mismatch = /* @__PURE__ */Caml_exceptions.create("CamlinternalFormat.Type_mismatch");

function type_padding(pad, fmtty) {
  if (typeof pad === "number") {
    return /* Padding_fmtty_EBB */{
            _0: /* No_padding */0,
            _1: fmtty
          };
  }
  if (pad.TAG === /* Lit_padding */0) {
    return /* Padding_fmtty_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: fmtty
          };
  }
  if (typeof fmtty === "number") {
    throw {
          MEL_EXN_ID: Type_mismatch,
          Error: new Error()
        };
  }
  if (fmtty.TAG === /* Int_ty */2) {
    return /* Padding_fmtty_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: fmtty._0
          };
  }
  throw {
        MEL_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function type_padprec(pad, prec, fmtty) {
  var match = type_padding(pad, fmtty);
  if (typeof prec !== "number") {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* Lit_precision */{
              _0: prec._0
            },
            _2: match._1
          };
  }
  if (!prec) {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* No_precision */0,
            _2: match._1
          };
  }
  var rest = match._1;
  if (typeof rest === "number") {
    throw {
          MEL_EXN_ID: Type_mismatch,
          Error: new Error()
        };
  }
  if (rest.TAG === /* Int_ty */2) {
    return /* Padprec_fmtty_EBB */{
            _0: match._0,
            _1: /* Arg_precision */1,
            _2: rest._0
          };
  }
  throw {
        MEL_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function type_format_gen(fmt, fmtty) {
  if (typeof fmt === "number") {
    return /* Fmt_fmtty_EBB */{
            _0: /* End_of_format */0,
            _1: fmtty
          };
  }
  switch (fmt.TAG | 0) {
    case /* Char */0 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Char */0,
                    _0: match._0
                  },
                  _1: match._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Caml_char */1 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match$1 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: match$1._0
                  },
                  _1: match$1._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* String */2 :
        var match$2 = type_padding(fmt._0, fmtty);
        var fmtty_rest = match$2._1;
        if (typeof fmtty_rest === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest.TAG === /* String_ty */1) {
          var match$3 = type_format_gen(fmt._1, fmtty_rest._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* String */2,
                    _0: match$2._0,
                    _1: match$3._0
                  },
                  _1: match$3._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Caml_string */3 :
        var match$4 = type_padding(fmt._0, fmtty);
        var fmtty_rest$1 = match$4._1;
        if (typeof fmtty_rest$1 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$1.TAG === /* String_ty */1) {
          var match$5 = type_format_gen(fmt._1, fmtty_rest$1._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: match$4._0,
                    _1: match$5._0
                  },
                  _1: match$5._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int */4 :
        var match$6 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$2 = match$6._2;
        if (typeof fmtty_rest$2 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$2.TAG === /* Int_ty */2) {
          var match$7 = type_format_gen(fmt._3, fmtty_rest$2._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int */4,
                    _0: fmt._0,
                    _1: match$6._0,
                    _2: match$6._1,
                    _3: match$7._0
                  },
                  _1: match$7._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int32 */5 :
        var match$8 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$3 = match$8._2;
        if (typeof fmtty_rest$3 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$3.TAG === /* Int32_ty */3) {
          var match$9 = type_format_gen(fmt._3, fmtty_rest$3._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int32 */5,
                    _0: fmt._0,
                    _1: match$8._0,
                    _2: match$8._1,
                    _3: match$9._0
                  },
                  _1: match$9._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Nativeint */6 :
        var match$10 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$4 = match$10._2;
        if (typeof fmtty_rest$4 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$4.TAG === /* Nativeint_ty */4) {
          var match$11 = type_format_gen(fmt._3, fmtty_rest$4._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Nativeint */6,
                    _0: fmt._0,
                    _1: match$10._0,
                    _2: match$10._1,
                    _3: match$11._0
                  },
                  _1: match$11._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int64 */7 :
        var match$12 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$5 = match$12._2;
        if (typeof fmtty_rest$5 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$5.TAG === /* Int64_ty */5) {
          var match$13 = type_format_gen(fmt._3, fmtty_rest$5._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Int64 */7,
                    _0: fmt._0,
                    _1: match$12._0,
                    _2: match$12._1,
                    _3: match$13._0
                  },
                  _1: match$13._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Float */8 :
        var match$14 = type_padprec(fmt._1, fmt._2, fmtty);
        var fmtty_rest$6 = match$14._2;
        if (typeof fmtty_rest$6 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$6.TAG === /* Float_ty */6) {
          var match$15 = type_format_gen(fmt._3, fmtty_rest$6._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Float */8,
                    _0: fmt._0,
                    _1: match$14._0,
                    _2: match$14._1,
                    _3: match$15._0
                  },
                  _1: match$15._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Bool */9 :
        var match$16 = type_padding(fmt._0, fmtty);
        var fmtty_rest$7 = match$16._1;
        if (typeof fmtty_rest$7 === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty_rest$7.TAG === /* Bool_ty */7) {
          var match$17 = type_format_gen(fmt._1, fmtty_rest$7._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Bool */9,
                    _0: match$16._0,
                    _1: match$17._0
                  },
                  _1: match$17._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Flush */10 :
        var match$18 = type_format_gen(fmt._0, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Flush */10,
                  _0: match$18._0
                },
                _1: match$18._1
              };
    case /* String_literal */11 :
        var match$19 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: fmt._0,
                  _1: match$19._0
                },
                _1: match$19._1
              };
    case /* Char_literal */12 :
        var match$20 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: fmt._0,
                  _1: match$20._0
                },
                _1: match$20._1
              };
    case /* Format_arg */13 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_arg_ty */8) {
          var sub_fmtty$p = fmtty._0;
          if (Caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: fmt._1
                }, /* Fmtty_EBB */{
                  _0: sub_fmtty$p
                })) {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$21 = type_format_gen(fmt._2, fmtty._1);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Format_arg */13,
                    _0: fmt._0,
                    _1: sub_fmtty$p,
                    _2: match$21._0
                  },
                  _1: match$21._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_subst */14 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_subst_ty */9) {
          var sub_fmtty1 = fmtty._0;
          if (Caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(fmt._1)
                }, /* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(sub_fmtty1)
                })) {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$22 = type_format_gen(fmt._2, CamlinternalFormatBasics.erase_rel(fmtty._2));
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Format_subst */14,
                    _0: fmt._0,
                    _1: sub_fmtty1,
                    _2: match$22._0
                  },
                  _1: match$22._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Alpha */15 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Alpha_ty */10) {
          var match$23 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: match$23._0
                  },
                  _1: match$23._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Theta */16 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Theta_ty */11) {
          var match$24 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Theta */16,
                    _0: match$24._0
                  },
                  _1: match$24._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Formatting_lit */17 :
        var match$25 = type_format_gen(fmt._1, fmtty);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Formatting_lit */17,
                  _0: fmt._0,
                  _1: match$25._0
                },
                _1: match$25._1
              };
    case /* Formatting_gen */18 :
        var formatting_gen = fmt._0;
        var fmt0 = fmt._1;
        if (formatting_gen.TAG === /* Open_tag */0) {
          var match$26 = formatting_gen._0;
          var match$27 = type_format_gen(match$26._0, fmtty);
          var match$28 = type_format_gen(fmt0, match$27._1);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_tag */0,
                      _0: /* Format */{
                        _0: match$27._0,
                        _1: match$26._1
                      }
                    },
                    _1: match$28._0
                  },
                  _1: match$28._1
                };
        }
        var match$29 = formatting_gen._0;
        var match$30 = type_format_gen(match$29._0, fmtty);
        var match$31 = type_format_gen(fmt0, match$30._1);
        return /* Fmt_fmtty_EBB */{
                _0: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_box */1,
                    _0: /* Format */{
                      _0: match$30._0,
                      _1: match$29._1
                    }
                  },
                  _1: match$31._0
                },
                _1: match$31._1
              };
    case /* Reader */19 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Reader_ty */13) {
          var match$32 = type_format_gen(fmt._0, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Reader */19,
                    _0: match$32._0
                  },
                  _1: match$32._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Scan_char_set */20 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* String_ty */1) {
          var match$33 = type_format_gen(fmt._2, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Scan_char_set */20,
                    _0: fmt._0,
                    _1: fmt._1,
                    _2: match$33._0
                  },
                  _1: match$33._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Scan_get_counter */21 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int_ty */2) {
          var match$34 = type_format_gen(fmt._1, fmtty._0);
          return /* Fmt_fmtty_EBB */{
                  _0: {
                    TAG: /* Scan_get_counter */21,
                    _0: fmt._0,
                    _1: match$34._0
                  },
                  _1: match$34._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Ignored_param */23 :
        var ign = fmt._0;
        var fmt$1 = fmt._1;
        if (typeof ign === "number") {
          if (ign !== /* Ignored_reader */2) {
            return type_ignored_param_one(ign, fmt$1, fmtty);
          }
          if (typeof fmtty === "number") {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          if (fmtty.TAG === /* Ignored_reader_ty */14) {
            var match$35 = type_format_gen(fmt$1, fmtty._0);
            return /* Fmt_fmtty_EBB */{
                    _0: {
                      TAG: /* Ignored_param */23,
                      _0: /* Ignored_reader */2,
                      _1: match$35._0
                    },
                    _1: match$35._1
                  };
          }
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        } else {
          switch (ign.TAG | 0) {
            case /* Ignored_format_arg */8 :
                return type_ignored_param_one({
                            TAG: /* Ignored_format_arg */8,
                            _0: ign._0,
                            _1: ign._1
                          }, fmt$1, fmtty);
            case /* Ignored_format_subst */9 :
                var match$36 = type_ignored_format_substitution(ign._1, fmt$1, fmtty);
                var match$37 = match$36._1;
                return /* Fmt_fmtty_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: {
                            TAG: /* Ignored_format_subst */9,
                            _0: ign._0,
                            _1: match$36._0
                          },
                          _1: match$37._0
                        },
                        _1: match$37._1
                      };
            default:
              return type_ignored_param_one(ign, fmt$1, fmtty);
          }
        }
    case /* Scan_next_char */22 :
    case /* Custom */24 :
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    
  }
}

function type_ignored_format_substitution(sub_fmtty, fmt, fmtty) {
  if (typeof sub_fmtty === "number") {
    return /* Fmtty_fmt_EBB */{
            _0: /* End_of_fmtty */0,
            _1: type_format_gen(fmt, fmtty)
          };
  }
  switch (sub_fmtty.TAG | 0) {
    case /* Char_ty */0 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Char_ty */0) {
          var match = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Char_ty */0,
                    _0: match._0
                  },
                  _1: match._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* String_ty */1 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* String_ty */1) {
          var match$1 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* String_ty */1,
                    _0: match$1._0
                  },
                  _1: match$1._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int_ty */2 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int_ty */2) {
          var match$2 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int_ty */2,
                    _0: match$2._0
                  },
                  _1: match$2._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int32_ty */3 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int32_ty */3) {
          var match$3 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int32_ty */3,
                    _0: match$3._0
                  },
                  _1: match$3._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Nativeint_ty */4 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Nativeint_ty */4) {
          var match$4 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Nativeint_ty */4,
                    _0: match$4._0
                  },
                  _1: match$4._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Int64_ty */5 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Int64_ty */5) {
          var match$5 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Int64_ty */5,
                    _0: match$5._0
                  },
                  _1: match$5._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Float_ty */6 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Float_ty */6) {
          var match$6 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Float_ty */6,
                    _0: match$6._0
                  },
                  _1: match$6._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Bool_ty */7 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Bool_ty */7) {
          var match$7 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Bool_ty */7,
                    _0: match$7._0
                  },
                  _1: match$7._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_arg_ty */8 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_arg_ty */8) {
          var sub2_fmtty$p = fmtty._0;
          if (Caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: sub_fmtty._0
                }, /* Fmtty_EBB */{
                  _0: sub2_fmtty$p
                })) {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var match$8 = type_ignored_format_substitution(sub_fmtty._1, fmt, fmtty._1);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Format_arg_ty */8,
                    _0: sub2_fmtty$p,
                    _1: match$8._0
                  },
                  _1: match$8._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Format_subst_ty */9 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Format_subst_ty */9) {
          var sub2_fmtty$p$1 = fmtty._1;
          var sub1_fmtty$p = fmtty._0;
          if (Caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(sub_fmtty._0)
                }, /* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(sub1_fmtty$p)
                })) {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          if (Caml_obj.caml_notequal(/* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(sub_fmtty._1)
                }, /* Fmtty_EBB */{
                  _0: CamlinternalFormatBasics.erase_rel(sub2_fmtty$p$1)
                })) {
            throw {
                  MEL_EXN_ID: Type_mismatch,
                  Error: new Error()
                };
          }
          var sub_fmtty$p = trans(symm(sub1_fmtty$p), sub2_fmtty$p$1);
          var match$9 = fmtty_rel_det(sub_fmtty$p);
          Curry._1(match$9[1], /* Refl */0);
          Curry._1(match$9[3], /* Refl */0);
          var match$10 = type_ignored_format_substitution(CamlinternalFormatBasics.erase_rel(sub_fmtty._2), fmt, fmtty._2);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Format_subst_ty */9,
                    _0: sub1_fmtty$p,
                    _1: sub2_fmtty$p$1,
                    _2: symm(match$10._0)
                  },
                  _1: match$10._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Alpha_ty */10 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Alpha_ty */10) {
          var match$11 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Alpha_ty */10,
                    _0: match$11._0
                  },
                  _1: match$11._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Theta_ty */11 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Theta_ty */11) {
          var match$12 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Theta_ty */11,
                    _0: match$12._0
                  },
                  _1: match$12._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Any_ty */12 :
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Reader_ty */13 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Reader_ty */13) {
          var match$13 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Reader_ty */13,
                    _0: match$13._0
                  },
                  _1: match$13._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    case /* Ignored_reader_ty */14 :
        if (typeof fmtty === "number") {
          throw {
                MEL_EXN_ID: Type_mismatch,
                Error: new Error()
              };
        }
        if (fmtty.TAG === /* Ignored_reader_ty */14) {
          var match$14 = type_ignored_format_substitution(sub_fmtty._0, fmt, fmtty._0);
          return /* Fmtty_fmt_EBB */{
                  _0: {
                    TAG: /* Ignored_reader_ty */14,
                    _0: match$14._0
                  },
                  _1: match$14._1
                };
        }
        throw {
              MEL_EXN_ID: Type_mismatch,
              Error: new Error()
            };
    
  }
}

function type_ignored_param_one(ign, fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  return /* Fmt_fmtty_EBB */{
          _0: {
            TAG: /* Ignored_param */23,
            _0: ign,
            _1: match._0
          },
          _1: match._1
        };
}

function type_format(fmt, fmtty) {
  var match = type_format_gen(fmt, fmtty);
  if (typeof match._1 === "number") {
    return match._0;
  }
  throw {
        MEL_EXN_ID: Type_mismatch,
        Error: new Error()
      };
}

function recast(fmt, fmtty) {
  return type_format(fmt, CamlinternalFormatBasics.erase_rel(symm(fmtty)));
}

function fix_padding(padty, width, str) {
  var len = str.length;
  var width$1 = Stdlib.abs(width);
  var padty$1 = width < 0 ? /* Left */0 : padty;
  if (width$1 <= len) {
    return str;
  }
  var res = Stdlib__Bytes.make(width$1, padty$1 === /* Zeros */2 ? /* '0' */48 : /* ' ' */32);
  switch (padty$1) {
    case /* Left */0 :
        Stdlib__String.blit(str, 0, res, 0, len);
        break;
    case /* Right */1 :
        Stdlib__String.blit(str, 0, res, width$1 - len | 0, len);
        break;
    case /* Zeros */2 :
        if (len > 0 && (Caml_string.get(str, 0) === /* '+' */43 || Caml_string.get(str, 0) === /* '-' */45 || Caml_string.get(str, 0) === /* ' ' */32)) {
          Caml_bytes.set(res, 0, Caml_string.get(str, 0));
          Stdlib__String.blit(str, 1, res, (width$1 - len | 0) + 1 | 0, len - 1 | 0);
        } else if (len > 1 && Caml_string.get(str, 0) === /* '0' */48 && (Caml_string.get(str, 1) === /* 'x' */120 || Caml_string.get(str, 1) === /* 'X' */88)) {
          Caml_bytes.set(res, 1, Caml_string.get(str, 1));
          Stdlib__String.blit(str, 2, res, (width$1 - len | 0) + 2 | 0, len - 2 | 0);
        } else {
          Stdlib__String.blit(str, 0, res, width$1 - len | 0, len);
        }
        break;
    
  }
  return Caml_bytes.bytes_to_string(res);
}

function fix_int_precision(prec, str) {
  var prec$1 = Stdlib.abs(prec);
  var len = str.length;
  var c = Caml_string.get(str, 0);
  var exit = 0;
  if (c >= 58) {
    if (c >= 71) {
      if (c > 102 || c < 97) {
        return str;
      }
      exit = 2;
    } else {
      if (c < 65) {
        return str;
      }
      exit = 2;
    }
  } else if (c !== 32) {
    if (c < 43) {
      return str;
    }
    switch (c) {
      case 43 :
      case 45 :
          exit = 1;
          break;
      case 44 :
      case 46 :
      case 47 :
          return str;
      case 48 :
          if ((prec$1 + 2 | 0) > len && len > 1 && (Caml_string.get(str, 1) === /* 'x' */120 || Caml_string.get(str, 1) === /* 'X' */88)) {
            var res = Stdlib__Bytes.make(prec$1 + 2 | 0, /* '0' */48);
            Caml_bytes.set(res, 1, Caml_string.get(str, 1));
            Stdlib__String.blit(str, 2, res, (prec$1 - len | 0) + 4 | 0, len - 2 | 0);
            return Caml_bytes.bytes_to_string(res);
          }
          exit = 2;
          break;
      case 49 :
      case 50 :
      case 51 :
      case 52 :
      case 53 :
      case 54 :
      case 55 :
      case 56 :
      case 57 :
          exit = 2;
          break;
      
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 :
        if ((prec$1 + 1 | 0) <= len) {
          return str;
        }
        var res$1 = Stdlib__Bytes.make(prec$1 + 1 | 0, /* '0' */48);
        Caml_bytes.set(res$1, 0, c);
        Stdlib__String.blit(str, 1, res$1, (prec$1 - len | 0) + 2 | 0, len - 1 | 0);
        return Caml_bytes.bytes_to_string(res$1);
    case 2 :
        if (prec$1 <= len) {
          return str;
        }
        var res$2 = Stdlib__Bytes.make(prec$1, /* '0' */48);
        Stdlib__String.blit(str, 0, res$2, prec$1 - len | 0, len);
        return Caml_bytes.bytes_to_string(res$2);
    
  }
}

function string_to_caml_string(str) {
  var str$1 = Stdlib__String.escaped(str);
  var l = str$1.length;
  var res = Stdlib__Bytes.make(l + 2 | 0, /* '"' */34);
  Caml_bytes.caml_blit_string(str$1, 0, res, 1, l);
  return Caml_bytes.bytes_to_string(res);
}

function format_of_iconv(param) {
  switch (param) {
    case /* Int_pd */1 :
        return "%+d";
    case /* Int_sd */2 :
        return "% d";
    case /* Int_pi */4 :
        return "%+i";
    case /* Int_si */5 :
        return "% i";
    case /* Int_x */6 :
        return "%x";
    case /* Int_Cx */7 :
        return "%#x";
    case /* Int_X */8 :
        return "%X";
    case /* Int_CX */9 :
        return "%#X";
    case /* Int_o */10 :
        return "%o";
    case /* Int_Co */11 :
        return "%#o";
    case /* Int_d */0 :
    case /* Int_Cd */13 :
        return "%d";
    case /* Int_i */3 :
    case /* Int_Ci */14 :
        return "%i";
    case /* Int_u */12 :
    case /* Int_Cu */15 :
        return "%u";
    
  }
}

function format_of_iconvL(param) {
  switch (param) {
    case /* Int_pd */1 :
        return "%+Ld";
    case /* Int_sd */2 :
        return "% Ld";
    case /* Int_pi */4 :
        return "%+Li";
    case /* Int_si */5 :
        return "% Li";
    case /* Int_x */6 :
        return "%Lx";
    case /* Int_Cx */7 :
        return "%#Lx";
    case /* Int_X */8 :
        return "%LX";
    case /* Int_CX */9 :
        return "%#LX";
    case /* Int_o */10 :
        return "%Lo";
    case /* Int_Co */11 :
        return "%#Lo";
    case /* Int_d */0 :
    case /* Int_Cd */13 :
        return "%Ld";
    case /* Int_i */3 :
    case /* Int_Ci */14 :
        return "%Li";
    case /* Int_u */12 :
    case /* Int_Cu */15 :
        return "%Lu";
    
  }
}

function format_of_iconvl(param) {
  switch (param) {
    case /* Int_pd */1 :
        return "%+ld";
    case /* Int_sd */2 :
        return "% ld";
    case /* Int_pi */4 :
        return "%+li";
    case /* Int_si */5 :
        return "% li";
    case /* Int_x */6 :
        return "%lx";
    case /* Int_Cx */7 :
        return "%#lx";
    case /* Int_X */8 :
        return "%lX";
    case /* Int_CX */9 :
        return "%#lX";
    case /* Int_o */10 :
        return "%lo";
    case /* Int_Co */11 :
        return "%#lo";
    case /* Int_d */0 :
    case /* Int_Cd */13 :
        return "%ld";
    case /* Int_i */3 :
    case /* Int_Ci */14 :
        return "%li";
    case /* Int_u */12 :
    case /* Int_Cu */15 :
        return "%lu";
    
  }
}

function format_of_iconvn(param) {
  switch (param) {
    case /* Int_pd */1 :
        return "%+nd";
    case /* Int_sd */2 :
        return "% nd";
    case /* Int_pi */4 :
        return "%+ni";
    case /* Int_si */5 :
        return "% ni";
    case /* Int_x */6 :
        return "%nx";
    case /* Int_Cx */7 :
        return "%#nx";
    case /* Int_X */8 :
        return "%nX";
    case /* Int_CX */9 :
        return "%#nX";
    case /* Int_o */10 :
        return "%no";
    case /* Int_Co */11 :
        return "%#no";
    case /* Int_d */0 :
    case /* Int_Cd */13 :
        return "%nd";
    case /* Int_i */3 :
    case /* Int_Ci */14 :
        return "%ni";
    case /* Int_u */12 :
    case /* Int_Cu */15 :
        return "%nu";
    
  }
}

function format_of_fconv(fconv, prec) {
  var prec$1 = Stdlib.abs(prec);
  var symb = char_of_fconv(/* 'g' */103, fconv);
  var buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  buffer_add_char(buf, /* '%' */37);
  bprint_fconv_flag(buf, fconv);
  buffer_add_char(buf, /* '.' */46);
  buffer_add_string(buf, Caml_format.caml_format_int("%d", prec$1));
  buffer_add_char(buf, symb);
  return buffer_contents(buf);
}

function transform_int_alt(iconv, s) {
  if (iconv < 13) {
    return s;
  }
  var n = 0;
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    var match = s.charCodeAt(i);
    if (!(match > 57 || match < 48)) {
      n = n + 1 | 0;
    }
    
  }
  var digits = n;
  var buf = Caml_bytes.caml_create_bytes(s.length + ((digits - 1 | 0) / 3 | 0) | 0);
  var pos = {
    contents: 0
  };
  var put = function (c) {
    Caml_bytes.set(buf, pos.contents, c);
    pos.contents = pos.contents + 1 | 0;
  };
  var left = (digits - 1 | 0) % 3 + 1 | 0;
  for(var i$1 = 0 ,i_finish$1 = s.length; i$1 < i_finish$1; ++i$1){
    var c = s.charCodeAt(i$1);
    if (c > 57 || c < 48) {
      put(c);
    } else {
      if (left === 0) {
        put(/* '_' */95);
        left = 3;
      }
      left = left - 1 | 0;
      put(c);
    }
  }
  return Caml_bytes.bytes_to_string(buf);
}

function convert_int(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_format_int(format_of_iconv(iconv), n));
}

function convert_int32(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_int32_format(format_of_iconvl(iconv), n));
}

function convert_nativeint(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_nativeint_format(format_of_iconvn(iconv), n));
}

function convert_int64(iconv, n) {
  return transform_int_alt(iconv, Caml_format.caml_int64_format(format_of_iconvL(iconv), n));
}

function convert_float(fconv, prec, x) {
  var hex = function (param) {
    var match = fconv[0];
    var sign;
    switch (match) {
      case /* Float_flag_ */0 :
          sign = /* '-' */45;
          break;
      case /* Float_flag_p */1 :
          sign = /* '+' */43;
          break;
      case /* Float_flag_s */2 :
          sign = /* ' ' */32;
          break;
      
    }
    return Caml_format.caml_hexstring_of_float(x, prec, sign);
  };
  var add_dot_if_needed = function (str) {
    var len = str.length;
    var is_valid = function (_i) {
      while(true) {
        var i = _i;
        if (i === len) {
          return false;
        }
        var match = Caml_string.get(str, i);
        if (match > 69 || match < 46) {
          if (match === 101) {
            return true;
          }
          _i = i + 1 | 0;
          continue ;
        }
        if (match > 68 || match < 47) {
          return true;
        }
        _i = i + 1 | 0;
        continue ;
      };
    };
    if (is_valid(0)) {
      return str;
    } else {
      return str + ".";
    }
  };
  var caml_special_val = function (str) {
    var match = Stdlib.classify_float(x);
    if (match !== 3) {
      if (match >= 4) {
        return "nan";
      } else {
        return str;
      }
    } else if (x < 0.0) {
      return "neg_infinity";
    } else {
      return "infinity";
    }
  };
  var match = fconv[1];
  switch (match) {
    case /* Float_f */0 :
    case /* Float_e */1 :
    case /* Float_E */2 :
    case /* Float_g */3 :
    case /* Float_G */4 :
        break;
    case /* Float_F */5 :
        var str = Caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
        return caml_special_val(add_dot_if_needed(str));
    case /* Float_h */6 :
        return hex(undefined);
    case /* Float_H */7 :
        var s = hex(undefined);
        return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
    case /* Float_CF */8 :
        return caml_special_val(hex(undefined));
    
  }
  return Caml_format.caml_format_float(format_of_fconv(fconv, prec), x);
}

function format_caml_char(c) {
  var str = Stdlib__Char.escaped(c);
  var l = str.length;
  var res = Stdlib__Bytes.make(l + 2 | 0, /* '\\'' */39);
  Caml_bytes.caml_blit_string(str, 0, res, 1, l);
  return Caml_bytes.bytes_to_string(res);
}

function string_of_fmtty(fmtty) {
  var buf = {
    ind: 0,
    bytes: Caml_bytes.caml_create_bytes(16)
  };
  bprint_fmtty(buf, fmtty);
  return buffer_contents(buf);
}

function make_printf(_k, _acc, _fmt) {
  while(true) {
    var fmt = _fmt;
    var acc = _acc;
    var k = _k;
    if (typeof fmt === "number") {
      return Curry._1(k, acc);
    }
    switch (fmt.TAG | 0) {
      case /* Char */0 :
          var rest = fmt._0;
          return (function(k,acc,rest){
          return function (c) {
            var new_acc = {
              TAG: /* Acc_data_char */5,
              _0: acc,
              _1: c
            };
            return make_printf(k, new_acc, rest);
          }
          }(k,acc,rest));
      case /* Caml_char */1 :
          var rest$1 = fmt._0;
          return (function(k,acc,rest$1){
          return function (c) {
            var new_acc_1 = format_caml_char(c);
            var new_acc = {
              TAG: /* Acc_data_string */4,
              _0: acc,
              _1: new_acc_1
            };
            return make_printf(k, new_acc, rest$1);
          }
          }(k,acc,rest$1));
      case /* String */2 :
          return make_padding(k, acc, fmt._1, fmt._0, (function (str) {
                        return str;
                      }));
      case /* Caml_string */3 :
          return make_padding(k, acc, fmt._1, fmt._0, string_to_caml_string);
      case /* Int */4 :
          return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int, fmt._0);
      case /* Int32 */5 :
          return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int32, fmt._0);
      case /* Nativeint */6 :
          return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_nativeint, fmt._0);
      case /* Int64 */7 :
          return make_int_padding_precision(k, acc, fmt._3, fmt._1, fmt._2, convert_int64, fmt._0);
      case /* Float */8 :
          var fmt$1 = fmt._3;
          var pad = fmt._1;
          var prec = fmt._2;
          var fconv = fmt._0;
          if (typeof pad === "number") {
            if (typeof prec === "number") {
              if (prec) {
                return (function(k,acc,fmt$1,fconv){
                return function (p, x) {
                  var str = convert_float(fconv, p, x);
                  return make_printf(k, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv));
              } else {
                return (function(k,acc,fmt$1,fconv){
                return function (x) {
                  var str = convert_float(fconv, default_float_precision(fconv), x);
                  return make_printf(k, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv));
              }
            }
            var p = prec._0;
            return (function(k,acc,fmt$1,fconv,p){
            return function (x) {
              var str = convert_float(fconv, p, x);
              return make_printf(k, {
                          TAG: /* Acc_data_string */4,
                          _0: acc,
                          _1: str
                        }, fmt$1);
            }
            }(k,acc,fmt$1,fconv,p));
          }
          if (pad.TAG === /* Lit_padding */0) {
            var w = pad._1;
            var padty = pad._0;
            if (typeof prec === "number") {
              if (prec) {
                return (function(k,acc,fmt$1,fconv,padty,w){
                return function (p, x) {
                  var str = fix_padding(padty, w, convert_float(fconv, p, x));
                  return make_printf(k, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv,padty,w));
              } else {
                return (function(k,acc,fmt$1,fconv,padty,w){
                return function (x) {
                  var str = convert_float(fconv, default_float_precision(fconv), x);
                  var str$p = fix_padding(padty, w, str);
                  return make_printf(k, {
                              TAG: /* Acc_data_string */4,
                              _0: acc,
                              _1: str$p
                            }, fmt$1);
                }
                }(k,acc,fmt$1,fconv,padty,w));
              }
            }
            var p$1 = prec._0;
            return (function(k,acc,fmt$1,fconv,padty,w,p$1){
            return function (x) {
              var str = fix_padding(padty, w, convert_float(fconv, p$1, x));
              return make_printf(k, {
                          TAG: /* Acc_data_string */4,
                          _0: acc,
                          _1: str
                        }, fmt$1);
            }
            }(k,acc,fmt$1,fconv,padty,w,p$1));
          }
          var padty$1 = pad._0;
          if (typeof prec === "number") {
            if (prec) {
              return (function(k,acc,fmt$1,fconv,padty$1){
              return function (w, p, x) {
                var str = fix_padding(padty$1, w, convert_float(fconv, p, x));
                return make_printf(k, {
                            TAG: /* Acc_data_string */4,
                            _0: acc,
                            _1: str
                          }, fmt$1);
              }
              }(k,acc,fmt$1,fconv,padty$1));
            } else {
              return (function(k,acc,fmt$1,fconv,padty$1){
              return function (w, x) {
                var str = convert_float(fconv, default_float_precision(fconv), x);
                var str$p = fix_padding(padty$1, w, str);
                return make_printf(k, {
                            TAG: /* Acc_data_string */4,
                            _0: acc,
                            _1: str$p
                          }, fmt$1);
              }
              }(k,acc,fmt$1,fconv,padty$1));
            }
          }
          var p$2 = prec._0;
          return (function(k,acc,fmt$1,fconv,padty$1,p$2){
          return function (w, x) {
            var str = fix_padding(padty$1, w, convert_float(fconv, p$2, x));
            return make_printf(k, {
                        TAG: /* Acc_data_string */4,
                        _0: acc,
                        _1: str
                      }, fmt$1);
          }
          }(k,acc,fmt$1,fconv,padty$1,p$2));
      case /* Bool */9 :
          return make_padding(k, acc, fmt._1, fmt._0, Stdlib.string_of_bool);
      case /* Flush */10 :
          _fmt = fmt._0;
          _acc = {
            TAG: /* Acc_flush */7,
            _0: acc
          };
          continue ;
      case /* String_literal */11 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_string_literal */2,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Char_literal */12 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_char_literal */3,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Format_arg */13 :
          var rest$2 = fmt._2;
          var ty = string_of_fmtty(fmt._1);
          return (function(k,acc,rest$2,ty){
          return function (str) {
            return make_printf(k, {
                        TAG: /* Acc_data_string */4,
                        _0: acc,
                        _1: ty
                      }, rest$2);
          }
          }(k,acc,rest$2,ty));
      case /* Format_subst */14 :
          var rest$3 = fmt._2;
          var fmtty = fmt._1;
          return (function(k,acc,fmtty,rest$3){
          return function (param) {
            return make_printf(k, acc, CamlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest$3));
          }
          }(k,acc,fmtty,rest$3));
      case /* Alpha */15 :
          var rest$4 = fmt._0;
          return (function(k,acc,rest$4){
          return function (f, x) {
            return make_printf(k, {
                        TAG: /* Acc_delay */6,
                        _0: acc,
                        _1: (function (o) {
                            return Curry._2(f, o, x);
                          })
                      }, rest$4);
          }
          }(k,acc,rest$4));
      case /* Theta */16 :
          var rest$5 = fmt._0;
          return (function(k,acc,rest$5){
          return function (f) {
            return make_printf(k, {
                        TAG: /* Acc_delay */6,
                        _0: acc,
                        _1: f
                      }, rest$5);
          }
          }(k,acc,rest$5));
      case /* Formatting_lit */17 :
          _fmt = fmt._1;
          _acc = {
            TAG: /* Acc_formatting_lit */0,
            _0: acc,
            _1: fmt._0
          };
          continue ;
      case /* Formatting_gen */18 :
          var match = fmt._0;
          if (match.TAG === /* Open_tag */0) {
            var rest$6 = fmt._1;
            var k$p = (function(k,acc,rest$6){
            return function k$p(kacc) {
              return make_printf(k, {
                          TAG: /* Acc_formatting_gen */1,
                          _0: acc,
                          _1: {
                            TAG: /* Acc_open_tag */0,
                            _0: kacc
                          }
                        }, rest$6);
            }
            }(k,acc,rest$6));
            _fmt = match._0._0;
            _acc = /* End_of_acc */0;
            _k = k$p;
            continue ;
          }
          var rest$7 = fmt._1;
          var k$p$1 = (function(k,acc,rest$7){
          return function k$p$1(kacc) {
            return make_printf(k, {
                        TAG: /* Acc_formatting_gen */1,
                        _0: acc,
                        _1: {
                          TAG: /* Acc_open_box */1,
                          _0: kacc
                        }
                      }, rest$7);
          }
          }(k,acc,rest$7));
          _fmt = match._0._0;
          _acc = /* End_of_acc */0;
          _k = k$p$1;
          continue ;
      case /* Reader */19 :
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  1558,
                  4
                ],
                Error: new Error()
              };
      case /* Scan_char_set */20 :
          var rest$8 = fmt._2;
          var new_acc = {
            TAG: /* Acc_invalid_arg */8,
            _0: acc,
            _1: "Printf: bad conversion %["
          };
          return (function(k,rest$8,new_acc){
          return function (param) {
            return make_printf(k, new_acc, rest$8);
          }
          }(k,rest$8,new_acc));
      case /* Scan_get_counter */21 :
          var rest$9 = fmt._1;
          return (function(k,acc,rest$9){
          return function (n) {
            var new_acc_1 = Caml_format.caml_format_int("%u", n);
            var new_acc = {
              TAG: /* Acc_data_string */4,
              _0: acc,
              _1: new_acc_1
            };
            return make_printf(k, new_acc, rest$9);
          }
          }(k,acc,rest$9));
      case /* Scan_next_char */22 :
          var rest$10 = fmt._0;
          return (function(k,acc,rest$10){
          return function (c) {
            var new_acc = {
              TAG: /* Acc_data_char */5,
              _0: acc,
              _1: c
            };
            return make_printf(k, new_acc, rest$10);
          }
          }(k,acc,rest$10));
      case /* Ignored_param */23 :
          return make_ignored_param(k, acc, fmt._0, fmt._1);
      case /* Custom */24 :
          return make_custom(k, acc, fmt._2, fmt._0, Curry._1(fmt._1, undefined));
      
    }
  };
}

function make_ignored_param(k, acc, ign, fmt) {
  if (typeof ign !== "number") {
    if (ign.TAG === /* Ignored_format_subst */9) {
      return make_from_fmtty(k, acc, ign._1, fmt);
    } else {
      return make_invalid_arg(k, acc, fmt);
    }
  }
  if (ign !== /* Ignored_reader */2) {
    return make_invalid_arg(k, acc, fmt);
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalFormat.cppo.ml",
          1626,
          39
        ],
        Error: new Error()
      };
}

function make_from_fmtty(k, acc, fmtty, fmt) {
  if (typeof fmtty === "number") {
    return make_invalid_arg(k, acc, fmt);
  }
  switch (fmtty.TAG | 0) {
    case /* Char_ty */0 :
        var rest = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest, fmt);
        };
    case /* String_ty */1 :
        var rest$1 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$1, fmt);
        };
    case /* Int_ty */2 :
        var rest$2 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$2, fmt);
        };
    case /* Int32_ty */3 :
        var rest$3 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$3, fmt);
        };
    case /* Nativeint_ty */4 :
        var rest$4 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$4, fmt);
        };
    case /* Int64_ty */5 :
        var rest$5 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$5, fmt);
        };
    case /* Float_ty */6 :
        var rest$6 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$6, fmt);
        };
    case /* Bool_ty */7 :
        var rest$7 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$7, fmt);
        };
    case /* Format_arg_ty */8 :
        var rest$8 = fmtty._1;
        return function (param) {
          return make_from_fmtty(k, acc, rest$8, fmt);
        };
    case /* Format_subst_ty */9 :
        var rest$9 = fmtty._2;
        var ty = trans(symm(fmtty._0), fmtty._1);
        return function (param) {
          return make_from_fmtty(k, acc, CamlinternalFormatBasics.concat_fmtty(ty, rest$9), fmt);
        };
    case /* Alpha_ty */10 :
        var rest$10 = fmtty._0;
        return function (param, param$1) {
          return make_from_fmtty(k, acc, rest$10, fmt);
        };
    case /* Theta_ty */11 :
        var rest$11 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$11, fmt);
        };
    case /* Any_ty */12 :
        var rest$12 = fmtty._0;
        return function (param) {
          return make_from_fmtty(k, acc, rest$12, fmt);
        };
    case /* Reader_ty */13 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                1649,
                31
              ],
              Error: new Error()
            };
    case /* Ignored_reader_ty */14 :
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                1650,
                31
              ],
              Error: new Error()
            };
    
  }
}

function make_invalid_arg(k, acc, fmt) {
  return make_printf(k, {
              TAG: /* Acc_invalid_arg */8,
              _0: acc,
              _1: "Printf: bad conversion %_"
            }, fmt);
}

function make_padding(k, acc, fmt, pad, trans) {
  if (typeof pad === "number") {
    return function (x) {
      var new_acc_1 = Curry._1(trans, x);
      var new_acc = {
        TAG: /* Acc_data_string */4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, new_acc, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */0) {
    var width = pad._1;
    var padty = pad._0;
    return function (x) {
      var new_acc_1 = fix_padding(padty, width, Curry._1(trans, x));
      var new_acc = {
        TAG: /* Acc_data_string */4,
        _0: acc,
        _1: new_acc_1
      };
      return make_printf(k, new_acc, fmt);
    };
  }
  var padty$1 = pad._0;
  return function (w, x) {
    var new_acc_1 = fix_padding(padty$1, w, Curry._1(trans, x));
    var new_acc = {
      TAG: /* Acc_data_string */4,
      _0: acc,
      _1: new_acc_1
    };
    return make_printf(k, new_acc, fmt);
  };
}

function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv) {
  if (typeof pad === "number") {
    if (typeof prec === "number") {
      if (prec) {
        return function (p, x) {
          var str = fix_int_precision(p, Curry._2(trans, iconv, x));
          return make_printf(k, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      } else {
        return function (x) {
          var str = Curry._2(trans, iconv, x);
          return make_printf(k, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      }
    }
    var p = prec._0;
    return function (x) {
      var str = fix_int_precision(p, Curry._2(trans, iconv, x));
      return make_printf(k, {
                  TAG: /* Acc_data_string */4,
                  _0: acc,
                  _1: str
                }, fmt);
    };
  }
  if (pad.TAG === /* Lit_padding */0) {
    var w = pad._1;
    var padty = pad._0;
    if (typeof prec === "number") {
      if (prec) {
        return function (p, x) {
          var str = fix_padding(padty, w, fix_int_precision(p, Curry._2(trans, iconv, x)));
          return make_printf(k, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      } else {
        return function (x) {
          var str = fix_padding(padty, w, Curry._2(trans, iconv, x));
          return make_printf(k, {
                      TAG: /* Acc_data_string */4,
                      _0: acc,
                      _1: str
                    }, fmt);
        };
      }
    }
    var p$1 = prec._0;
    return function (x) {
      var str = fix_padding(padty, w, fix_int_precision(p$1, Curry._2(trans, iconv, x)));
      return make_printf(k, {
                  TAG: /* Acc_data_string */4,
                  _0: acc,
                  _1: str
                }, fmt);
    };
  }
  var padty$1 = pad._0;
  if (typeof prec === "number") {
    if (prec) {
      return function (w, p, x) {
        var str = fix_padding(padty$1, w, fix_int_precision(p, Curry._2(trans, iconv, x)));
        return make_printf(k, {
                    TAG: /* Acc_data_string */4,
                    _0: acc,
                    _1: str
                  }, fmt);
      };
    } else {
      return function (w, x) {
        var str = fix_padding(padty$1, w, Curry._2(trans, iconv, x));
        return make_printf(k, {
                    TAG: /* Acc_data_string */4,
                    _0: acc,
                    _1: str
                  }, fmt);
      };
    }
  }
  var p$2 = prec._0;
  return function (w, x) {
    var str = fix_padding(padty$1, w, fix_int_precision(p$2, Curry._2(trans, iconv, x)));
    return make_printf(k, {
                TAG: /* Acc_data_string */4,
                _0: acc,
                _1: str
              }, fmt);
  };
}

function make_custom(k, acc, rest, arity, f) {
  if (!arity) {
    return make_printf(k, {
                TAG: /* Acc_data_string */4,
                _0: acc,
                _1: f
              }, rest);
  }
  var arity$1 = arity._0;
  return function (x) {
    return make_custom(k, acc, rest, arity$1, Curry._1(f, x));
  };
}

function make_iprintf(_k, o, _fmt) {
  while(true) {
    var fmt = _fmt;
    var k = _k;
    var exit = 0;
    if (typeof fmt === "number") {
      return Curry._1(k, o);
    }
    switch (fmt.TAG | 0) {
      case /* String */2 :
          var exit$1 = 0;
          var tmp = fmt._0;
          if (typeof tmp === "number" || tmp.TAG === /* Lit_padding */0) {
            exit$1 = 4;
          } else {
            var partial_arg = make_iprintf(k, o, fmt._1);
            var partial_arg$1 = (function(partial_arg){
            return function partial_arg$1(param) {
              return partial_arg;
            }
            }(partial_arg));
            return function (param) {
              return partial_arg$1;
            };
          }
          if (exit$1 === 4) {
            var partial_arg$2 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$2){
            return function (param) {
              return partial_arg$2;
            }
            }(partial_arg$2));
          }
          break;
      case /* Caml_string */3 :
          var exit$2 = 0;
          var tmp$1 = fmt._0;
          if (typeof tmp$1 === "number" || tmp$1.TAG === /* Lit_padding */0) {
            exit$2 = 4;
          } else {
            var partial_arg$3 = make_iprintf(k, o, fmt._1);
            var partial_arg$4 = (function(partial_arg$3){
            return function partial_arg$4(param) {
              return partial_arg$3;
            }
            }(partial_arg$3));
            return function (param) {
              return partial_arg$4;
            };
          }
          if (exit$2 === 4) {
            var partial_arg$5 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$5){
            return function (param) {
              return partial_arg$5;
            }
            }(partial_arg$5));
          }
          break;
      case /* Bool */9 :
          var exit$3 = 0;
          var tmp$2 = fmt._0;
          if (typeof tmp$2 === "number" || tmp$2.TAG === /* Lit_padding */0) {
            exit$3 = 4;
          } else {
            var partial_arg$6 = make_iprintf(k, o, fmt._1);
            var partial_arg$7 = (function(partial_arg$6){
            return function partial_arg$7(param) {
              return partial_arg$6;
            }
            }(partial_arg$6));
            return function (param) {
              return partial_arg$7;
            };
          }
          if (exit$3 === 4) {
            var partial_arg$8 = make_iprintf(k, o, fmt._1);
            return (function(partial_arg$8){
            return function (param) {
              return partial_arg$8;
            }
            }(partial_arg$8));
          }
          break;
      case /* Flush */10 :
          _fmt = fmt._0;
          continue ;
      case /* Format_subst */14 :
          var rest = fmt._2;
          var fmtty = fmt._1;
          return (function(k,fmtty,rest){
          return function (param) {
            return make_iprintf(k, o, CamlinternalFormatBasics.concat_fmt(recast(param._0, fmtty), rest));
          }
          }(k,fmtty,rest));
      case /* Alpha */15 :
          var partial_arg$9 = make_iprintf(k, o, fmt._0);
          var partial_arg$10 = (function(partial_arg$9){
          return function partial_arg$10(param) {
            return partial_arg$9;
          }
          }(partial_arg$9));
          return function (param) {
            return partial_arg$10;
          };
      case /* String_literal */11 :
      case /* Char_literal */12 :
      case /* Formatting_lit */17 :
          exit = 2;
          break;
      case /* Formatting_gen */18 :
          var match = fmt._0;
          if (match.TAG === /* Open_tag */0) {
            var rest$1 = fmt._1;
            _fmt = match._0._0;
            _k = (function(k,rest$1){
            return function (koc) {
              return make_iprintf(k, koc, rest$1);
            }
            }(k,rest$1));
            continue ;
          }
          var rest$2 = fmt._1;
          _fmt = match._0._0;
          _k = (function(k,rest$2){
          return function (koc) {
            return make_iprintf(k, koc, rest$2);
          }
          }(k,rest$2));
          continue ;
      case /* Reader */19 :
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  1830,
                  8
                ],
                Error: new Error()
              };
      case /* Format_arg */13 :
      case /* Scan_char_set */20 :
          exit = 3;
          break;
      case /* Scan_get_counter */21 :
          var partial_arg$11 = make_iprintf(k, o, fmt._1);
          return (function(partial_arg$11){
          return function (param) {
            return partial_arg$11;
          }
          }(partial_arg$11));
      case /* Char */0 :
      case /* Caml_char */1 :
      case /* Theta */16 :
      case /* Scan_next_char */22 :
          exit = 1;
          break;
      case /* Ignored_param */23 :
          return make_ignored_param((function(k){
                    return function (param) {
                      return Curry._1(k, o);
                    }
                    }(k)), /* End_of_acc */0, fmt._0, fmt._1);
      case /* Custom */24 :
          return fn_of_custom_arity(k, o, fmt._2, fmt._0);
      default:
        var fmt$1 = fmt._3;
        var pad = fmt._1;
        var prec = fmt._2;
        if (typeof pad === "number") {
          if (typeof prec === "number") {
            if (prec) {
              var partial_arg$12 = make_iprintf(k, o, fmt$1);
              var partial_arg$13 = (function(partial_arg$12){
              return function partial_arg$13(param) {
                return partial_arg$12;
              }
              }(partial_arg$12));
              return function (param) {
                return partial_arg$13;
              };
            }
            var partial_arg$14 = make_iprintf(k, o, fmt$1);
            return (function(partial_arg$14){
            return function (param) {
              return partial_arg$14;
            }
            }(partial_arg$14));
          }
          var partial_arg$15 = make_iprintf(k, o, fmt$1);
          return (function(partial_arg$15){
          return function (param) {
            return partial_arg$15;
          }
          }(partial_arg$15));
        }
        if (pad.TAG === /* Lit_padding */0) {
          if (typeof prec === "number") {
            if (prec) {
              var partial_arg$16 = make_iprintf(k, o, fmt$1);
              var partial_arg$17 = (function(partial_arg$16){
              return function partial_arg$17(param) {
                return partial_arg$16;
              }
              }(partial_arg$16));
              return function (param) {
                return partial_arg$17;
              };
            }
            var partial_arg$18 = make_iprintf(k, o, fmt$1);
            return (function(partial_arg$18){
            return function (param) {
              return partial_arg$18;
            }
            }(partial_arg$18));
          }
          var partial_arg$19 = make_iprintf(k, o, fmt$1);
          return (function(partial_arg$19){
          return function (param) {
            return partial_arg$19;
          }
          }(partial_arg$19));
        }
        if (typeof prec === "number") {
          if (prec) {
            var partial_arg$20 = make_iprintf(k, o, fmt$1);
            var partial_arg$21 = (function(partial_arg$20){
            return function partial_arg$21(param) {
              return partial_arg$20;
            }
            }(partial_arg$20));
            var partial_arg$22 = function (param) {
              return partial_arg$21;
            };
            return function (param) {
              return partial_arg$22;
            };
          }
          var partial_arg$23 = make_iprintf(k, o, fmt$1);
          var partial_arg$24 = (function(partial_arg$23){
          return function partial_arg$24(param) {
            return partial_arg$23;
          }
          }(partial_arg$23));
          return function (param) {
            return partial_arg$24;
          };
        }
        var partial_arg$25 = make_iprintf(k, o, fmt$1);
        var partial_arg$26 = (function(partial_arg$25){
        return function partial_arg$26(param) {
          return partial_arg$25;
        }
        }(partial_arg$25));
        return function (param) {
          return partial_arg$26;
        };
    }
    switch (exit) {
      case 1 :
          var partial_arg$27 = make_iprintf(k, o, fmt._0);
          return (function(partial_arg$27){
          return function (param) {
            return partial_arg$27;
          }
          }(partial_arg$27));
      case 2 :
          _fmt = fmt._1;
          continue ;
      case 3 :
          var partial_arg$28 = make_iprintf(k, o, fmt._2);
          return (function(partial_arg$28){
          return function (param) {
            return partial_arg$28;
          }
          }(partial_arg$28));
      
    }
  };
}

function fn_of_custom_arity(k, o, fmt, param) {
  if (!param) {
    return make_iprintf(k, o, fmt);
  }
  var partial_arg = fn_of_custom_arity(k, o, fmt, param._0);
  return function (param) {
    return partial_arg;
  };
}

function output_acc(o, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          output_acc(o, acc._0);
          return Stdlib.output_string(o, s);
      case /* Acc_formatting_gen */1 :
          var acc$p = acc._1;
          var p = acc._0;
          if (acc$p.TAG === /* Acc_open_tag */0) {
            output_acc(o, p);
            Stdlib.output_string(o, "@{");
            _acc = acc$p._0;
            continue ;
          }
          output_acc(o, p);
          Stdlib.output_string(o, "@[");
          _acc = acc$p._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          output_acc(o, acc._0);
          return Curry._1(acc._1, o);
      case /* Acc_flush */7 :
          output_acc(o, acc._0);
          return Caml_io.caml_ml_flush(o);
      case /* Acc_invalid_arg */8 :
          output_acc(o, acc._0);
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          output_acc(o, acc._0);
          return Stdlib.output_string(o, acc._1);
      case 2 :
          output_acc(o, acc._0);
          return Caml_io.caml_ml_output_char(o, acc._1);
      
    }
  };
}

function bufput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          bufput_acc(b, acc._0);
          return Stdlib__Buffer.add_string(b, s);
      case /* Acc_formatting_gen */1 :
          var acc$p = acc._1;
          var p = acc._0;
          if (acc$p.TAG === /* Acc_open_tag */0) {
            bufput_acc(b, p);
            Stdlib__Buffer.add_string(b, "@{");
            _acc = acc$p._0;
            continue ;
          }
          bufput_acc(b, p);
          Stdlib__Buffer.add_string(b, "@[");
          _acc = acc$p._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          bufput_acc(b, acc._0);
          return Curry._1(acc._1, b);
      case /* Acc_flush */7 :
          _acc = acc._0;
          continue ;
      case /* Acc_invalid_arg */8 :
          bufput_acc(b, acc._0);
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          bufput_acc(b, acc._0);
          return Stdlib__Buffer.add_string(b, acc._1);
      case 2 :
          bufput_acc(b, acc._0);
          return Stdlib__Buffer.add_char(b, acc._1);
      
    }
  };
}

function strput_acc(b, _acc) {
  while(true) {
    var acc = _acc;
    var exit = 0;
    if (typeof acc === "number") {
      return ;
    }
    switch (acc.TAG | 0) {
      case /* Acc_formatting_lit */0 :
          var s = string_of_formatting_lit(acc._1);
          strput_acc(b, acc._0);
          return Stdlib__Buffer.add_string(b, s);
      case /* Acc_formatting_gen */1 :
          var acc$p = acc._1;
          var p = acc._0;
          if (acc$p.TAG === /* Acc_open_tag */0) {
            strput_acc(b, p);
            Stdlib__Buffer.add_string(b, "@{");
            _acc = acc$p._0;
            continue ;
          }
          strput_acc(b, p);
          Stdlib__Buffer.add_string(b, "@[");
          _acc = acc$p._0;
          continue ;
      case /* Acc_string_literal */2 :
      case /* Acc_data_string */4 :
          exit = 1;
          break;
      case /* Acc_char_literal */3 :
      case /* Acc_data_char */5 :
          exit = 2;
          break;
      case /* Acc_delay */6 :
          strput_acc(b, acc._0);
          return Stdlib__Buffer.add_string(b, Curry._1(acc._1, undefined));
      case /* Acc_flush */7 :
          _acc = acc._0;
          continue ;
      case /* Acc_invalid_arg */8 :
          strput_acc(b, acc._0);
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: acc._1,
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          strput_acc(b, acc._0);
          return Stdlib__Buffer.add_string(b, acc._1);
      case 2 :
          strput_acc(b, acc._0);
          return Stdlib__Buffer.add_char(b, acc._1);
      
    }
  };
}

function failwith_message(param) {
  var buf = Stdlib__Buffer.create(256);
  var k = function (acc) {
    strput_acc(buf, acc);
    var s = Stdlib__Buffer.contents(buf);
    throw {
          MEL_EXN_ID: "Failure",
          _1: s,
          Error: new Error()
        };
  };
  return make_printf(k, /* End_of_acc */0, param._0);
}

function open_box_of_string(str) {
  if (str === "") {
    return [
            0,
            /* Pp_box */4
          ];
  }
  var len = str.length;
  var invalid_box = function (param) {
    return Curry._1(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid box description ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "invalid box description %S"
                  }), str);
  };
  var parse_spaces = function (_i) {
    while(true) {
      var i = _i;
      if (i === len) {
        return i;
      }
      var match = Caml_string.get(str, i);
      if (match !== 9) {
        if (match !== 32) {
          return i;
        }
        _i = i + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var parse_lword = function (i, _j) {
    while(true) {
      var j = _j;
      if (j === len) {
        return j;
      }
      var match = Caml_string.get(str, j);
      if (match > 122 || match < 97) {
        return j;
      }
      _j = j + 1 | 0;
      continue ;
    };
  };
  var parse_int = function (i, _j) {
    while(true) {
      var j = _j;
      if (j === len) {
        return j;
      }
      var match = Caml_string.get(str, j);
      if (match >= 48) {
        if (match >= 58) {
          return j;
        }
        _j = j + 1 | 0;
        continue ;
      }
      if (match !== 45) {
        return j;
      }
      _j = j + 1 | 0;
      continue ;
    };
  };
  var wstart = parse_spaces(0);
  var wend = parse_lword(wstart, wstart);
  var box_name = Stdlib__String.sub(str, wstart, wend - wstart | 0);
  var nstart = parse_spaces(wend);
  var nend = parse_int(nstart, nstart);
  var indent;
  if (nstart === nend) {
    indent = 0;
  } else {
    try {
      indent = Caml_format.caml_int_of_string(Stdlib__String.sub(str, nstart, nend - nstart | 0));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Failure) {
        indent = invalid_box(undefined);
      } else {
        throw exn;
      }
    }
  }
  var exp_end = parse_spaces(nend);
  if (exp_end !== len) {
    invalid_box(undefined);
  }
  var box_type;
  switch (box_name) {
    case "" :
    case "b" :
        box_type = /* Pp_box */4;
        break;
    case "h" :
        box_type = /* Pp_hbox */0;
        break;
    case "hov" :
        box_type = /* Pp_hovbox */3;
        break;
    case "hv" :
        box_type = /* Pp_hvbox */2;
        break;
    case "v" :
        box_type = /* Pp_vbox */1;
        break;
    default:
      box_type = invalid_box(undefined);
  }
  return [
          indent,
          box_type
        ];
}

function make_padding_fmt_ebb(pad, fmt) {
  if (typeof pad === "number") {
    return /* Padding_fmt_EBB */{
            _0: /* No_padding */0,
            _1: fmt
          };
  } else if (pad.TAG === /* Lit_padding */0) {
    return /* Padding_fmt_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: fmt
          };
  } else {
    return /* Padding_fmt_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: fmt
          };
  }
}

function make_precision_fmt_ebb(prec, fmt) {
  if (typeof prec === "number") {
    if (prec) {
      return /* Precision_fmt_EBB */{
              _0: /* Arg_precision */1,
              _1: fmt
            };
    } else {
      return /* Precision_fmt_EBB */{
              _0: /* No_precision */0,
              _1: fmt
            };
    }
  } else {
    return /* Precision_fmt_EBB */{
            _0: /* Lit_precision */{
              _0: prec._0
            },
            _1: fmt
          };
  }
}

function make_padprec_fmt_ebb(pad, prec, fmt) {
  var match = make_precision_fmt_ebb(prec, fmt);
  var fmt$p = match._1;
  var prec$1 = match._0;
  if (typeof pad === "number") {
    return /* Padprec_fmt_EBB */{
            _0: /* No_padding */0,
            _1: prec$1,
            _2: fmt$p
          };
  } else if (pad.TAG === /* Lit_padding */0) {
    return /* Padprec_fmt_EBB */{
            _0: {
              TAG: /* Lit_padding */0,
              _0: pad._0,
              _1: pad._1
            },
            _1: prec$1,
            _2: fmt$p
          };
  } else {
    return /* Padprec_fmt_EBB */{
            _0: {
              TAG: /* Arg_padding */1,
              _0: pad._0
            },
            _1: prec$1,
            _2: fmt$p
          };
  }
}

function fmt_ebb_of_string(legacy_behavior, str) {
  var legacy_behavior$1 = legacy_behavior !== undefined ? legacy_behavior : true;
  var invalid_format_message = function (str_ind, msg) {
    return Curry._3(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s"
                  }), str, str_ind, msg);
  };
  var invalid_format_without = function (str_ind, c, s) {
    return Curry._4(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", '",
                              _1: {
                                TAG: /* Char */0,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "' without ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, '%c' without %s"
                  }), str, str_ind, c, s);
  };
  var expected_character = function (str_ind, expected, read) {
    return Curry._4(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " expected, read ",
                                  _1: {
                                    TAG: /* Caml_char */1,
                                    _0: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s expected, read %C"
                  }), str, str_ind, expected, read);
  };
  var parse_flags = function (pct_ind, str_ind, end_ind, ign) {
    var zero = {
      contents: false
    };
    var minus = {
      contents: false
    };
    var plus = {
      contents: false
    };
    var space = {
      contents: false
    };
    var hash = {
      contents: false
    };
    var set_flag = function (str_ind, flag) {
      if (flag.contents && !legacy_behavior$1) {
        Curry._3(failwith_message(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "invalid format ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": at character number ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: ", duplicate flag ",
                            _1: {
                              TAG: /* Caml_char */1,
                              _0: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "invalid format %S: at character number %d, duplicate flag %C"
                }), str, str_ind, Caml_string.get(str, str_ind));
      }
      flag.contents = true;
    };
    var _str_ind = str_ind;
    while(true) {
      var str_ind$1 = _str_ind;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var match = Caml_string.get(str, str_ind$1);
      switch (match) {
        case 32 :
            set_flag(str_ind$1, space);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 35 :
            set_flag(str_ind$1, hash);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 43 :
            set_flag(str_ind$1, plus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 45 :
            set_flag(str_ind$1, minus);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        case 33 :
        case 34 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 42 :
        case 44 :
        case 46 :
        case 47 :
            break;
        case 48 :
            set_flag(str_ind$1, zero);
            _str_ind = str_ind$1 + 1 | 0;
            continue ;
        default:
          
      }
      var zero$1 = zero.contents;
      var minus$1 = minus.contents;
      var plus$1 = plus.contents;
      var hash$1 = hash.contents;
      var space$1 = space.contents;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var padty = zero$1 ? (
          minus$1 ? (
              legacy_behavior$1 ? /* Left */0 : incompatible_flag(pct_ind, str_ind$1, /* '-' */45, "0")
            ) : /* Zeros */2
        ) : (
          minus$1 ? /* Left */0 : /* Right */1
        );
      var match$1 = Caml_string.get(str, str_ind$1);
      if (match$1 >= 48) {
        if (match$1 < 58) {
          var match$2 = parse_positive(str_ind$1, end_ind, 0);
          return parse_after_padding(pct_ind, match$2[0], end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                      TAG: /* Lit_padding */0,
                      _0: padty,
                      _1: match$2[1]
                    });
        }
        
      } else if (match$1 === 42) {
        return parse_after_padding(pct_ind, str_ind$1 + 1 | 0, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                    TAG: /* Arg_padding */1,
                    _0: padty
                  });
      }
      switch (padty) {
        case /* Left */0 :
            if (!legacy_behavior$1) {
              invalid_format_without(str_ind$1 - 1 | 0, /* '-' */45, "padding");
            }
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */0);
        case /* Right */1 :
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, /* No_padding */0);
        case /* Zeros */2 :
            return parse_after_padding(pct_ind, str_ind$1, end_ind, minus$1, plus$1, hash$1, space$1, ign, {
                        TAG: /* Lit_padding */0,
                        _0: /* Right */1,
                        _1: 0
                      });
        
      }
    };
  };
  var parse_literal = function (lit_start, _str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        return add_literal(lit_start, str_ind, /* End_of_format */0);
      }
      var match = Caml_string.get(str, str_ind);
      if (match !== 37) {
        if (match !== 64) {
          _str_ind = str_ind + 1 | 0;
          continue ;
        }
        var fmt_rest = parse_after_at(str_ind + 1 | 0, end_ind);
        return add_literal(lit_start, str_ind, fmt_rest._0);
      }
      var fmt_rest$1 = parse_format(str_ind, end_ind);
      return add_literal(lit_start, str_ind, fmt_rest$1._0);
    };
  };
  var parse_tag = function (is_open_tag, str_ind, end_ind) {
    try {
      if (str_ind === end_ind) {
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      }
      var match = Caml_string.get(str, str_ind);
      if (match !== 60) {
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      }
      var ind = Stdlib__String.index_from(str, str_ind + 1 | 0, /* '>' */62);
      if (ind >= end_ind) {
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      }
      var sub_str = Stdlib__String.sub(str, str_ind, (ind - str_ind | 0) + 1 | 0);
      var beg_ind = ind + 1 | 0;
      var fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
      var sub_fmt = parse_literal(str_ind, str_ind, ind + 1 | 0);
      var sub_format_0 = sub_fmt._0;
      var sub_format = /* Format */{
        _0: sub_format_0,
        _1: sub_str
      };
      var formatting = is_open_tag ? ({
            TAG: /* Open_tag */0,
            _0: sub_format
          }) : ({
            TAG: /* Open_box */1,
            _0: sub_format
          });
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Formatting_gen */18,
                _0: formatting,
                _1: fmt_rest._0
              }
            };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var fmt_rest$1 = parse_literal(str_ind, str_ind, end_ind);
        var sub_format$1 = /* Format */{
          _0: /* End_of_format */0,
          _1: ""
        };
        var formatting$1 = is_open_tag ? ({
              TAG: /* Open_tag */0,
              _0: sub_format$1
            }) : ({
              TAG: /* Open_box */1,
              _0: sub_format$1
            });
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* Formatting_gen */18,
                  _0: formatting$1,
                  _1: fmt_rest$1._0
                }
              };
      }
      throw exn;
    }
  };
  var compute_int_conv = function (pct_ind, str_ind, _plus, _hash, _space, symb) {
    while(true) {
      var space = _space;
      var hash = _hash;
      var plus = _plus;
      var exit = 0;
      if (plus) {
        if (hash) {
          exit = 2;
        } else if (!space) {
          if (symb === 100) {
            return /* Int_pd */1;
          }
          if (symb === 105) {
            return /* Int_pi */4;
          }
          
        }
        
      } else if (hash) {
        if (space) {
          exit = 2;
        } else {
          switch (symb) {
            case 88 :
                return /* Int_CX */9;
            case 100 :
                return /* Int_Cd */13;
            case 105 :
                return /* Int_Ci */14;
            case 111 :
                return /* Int_Co */11;
            case 117 :
                return /* Int_Cu */15;
            case 89 :
            case 90 :
            case 91 :
            case 92 :
            case 93 :
            case 94 :
            case 95 :
            case 96 :
            case 97 :
            case 98 :
            case 99 :
            case 101 :
            case 102 :
            case 103 :
            case 104 :
            case 106 :
            case 107 :
            case 108 :
            case 109 :
            case 110 :
            case 112 :
            case 113 :
            case 114 :
            case 115 :
            case 116 :
            case 118 :
            case 119 :
                exit = 2;
                break;
            case 120 :
                return /* Int_Cx */7;
            default:
              exit = 2;
          }
        }
      } else if (space) {
        if (symb === 100) {
          return /* Int_sd */2;
        }
        if (symb === 105) {
          return /* Int_si */5;
        }
        
      } else {
        switch (symb) {
          case 88 :
              return /* Int_X */8;
          case 100 :
              return /* Int_d */0;
          case 105 :
              return /* Int_i */3;
          case 111 :
              return /* Int_o */10;
          case 117 :
              return /* Int_u */12;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              return /* Int_x */6;
          default:
            
        }
      }
      if (exit === 2) {
        var exit$1 = 0;
        switch (symb) {
          case 88 :
              if (legacy_behavior$1) {
                return /* Int_CX */9;
              }
              break;
          case 111 :
              if (legacy_behavior$1) {
                return /* Int_Co */11;
              }
              break;
          case 100 :
          case 105 :
          case 117 :
              exit$1 = 3;
              break;
          case 89 :
          case 90 :
          case 91 :
          case 92 :
          case 93 :
          case 94 :
          case 95 :
          case 96 :
          case 97 :
          case 98 :
          case 99 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 112 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
          case 118 :
          case 119 :
              break;
          case 120 :
              if (legacy_behavior$1) {
                return /* Int_Cx */7;
              }
              break;
          default:
            
        }
        if (exit$1 === 3) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, symb, "'#'");
          }
          _hash = false;
          continue ;
        }
        
      }
      if (plus) {
        if (space) {
          if (!legacy_behavior$1) {
            return incompatible_flag(pct_ind, str_ind, /* ' ' */32, "'+'");
          }
          _space = false;
          continue ;
        }
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "'+'");
        }
        _plus = false;
        continue ;
      }
      if (space) {
        if (!legacy_behavior$1) {
          return incompatible_flag(pct_ind, str_ind, symb, "' '");
        }
        _space = false;
        continue ;
      }
      throw {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              2938,
              28
            ],
            Error: new Error()
          };
    };
  };
  var incompatible_flag = function (pct_ind, str_ind, symb, option) {
    var subfmt = Stdlib__String.sub(str, pct_ind, str_ind - pct_ind | 0);
    return Curry._5(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* String_literal */11,
                                  _0: " is incompatible with '",
                                  _1: {
                                    TAG: /* Char */0,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "' in sub-format ",
                                      _1: {
                                        TAG: /* Caml_string */3,
                                        _0: /* No_padding */0,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"
                  }), str, pct_ind, option, symb, subfmt);
  };
  var parse_positive = function (_str_ind, end_ind, _acc) {
    while(true) {
      var acc = _acc;
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = Caml_string.get(str, str_ind);
      if (c > 57 || c < 48) {
        return [
                str_ind,
                acc
              ];
      }
      var new_acc = Math.imul(acc, 10) + (c - /* '0' */48 | 0) | 0;
      _acc = new_acc;
      _str_ind = str_ind + 1 | 0;
      continue ;
    };
  };
  var parse_char_set = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var char_set = Stdlib__Bytes.make(32, /* '\\000' */0);
    var add_range = function (c, c$p) {
      for(var i = c; i <= c$p; ++i){
        add_in_char_set(char_set, Stdlib.char_of_int(i));
      }
    };
    var fail_single_percent = function (str_ind) {
      return Curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "invalid format ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ": '",
                            _1: {
                              TAG: /* Char_literal */12,
                              _0: /* '%' */37,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "' alone is not accepted in character sets, use ",
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* '%' */37,
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '%' */37,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: " instead at position ",
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: /* No_padding */0,
                                        _2: /* No_precision */0,
                                        _3: {
                                          TAG: /* Char_literal */12,
                                          _0: /* '.' */46,
                                          _1: /* End_of_format */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      _1: "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."
                    }), str, str_ind);
    };
    var parse_char_set_after_char = function (_str_ind, end_ind, _c) {
      while(true) {
        var c = _c;
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c$p = Caml_string.get(str, str_ind);
        var exit = 0;
        if (c$p >= 46) {
          if (c$p !== 64) {
            if (c$p === 93) {
              add_in_char_set(char_set, c);
              return str_ind + 1 | 0;
            }
            
          } else {
            exit = 2;
          }
        } else if (c$p !== 37) {
          if (c$p >= 45) {
            var str_ind$1 = str_ind + 1 | 0;
            if (str_ind$1 === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            var c$p$1 = Caml_string.get(str, str_ind$1);
            if (c$p$1 !== 37) {
              if (c$p$1 !== 93) {
                add_range(c, c$p$1);
                return parse_char_set_content(str_ind$1 + 1 | 0, end_ind);
              } else {
                add_in_char_set(char_set, c);
                add_in_char_set(char_set, /* '-' */45);
                return str_ind$1 + 1 | 0;
              }
            }
            if ((str_ind$1 + 1 | 0) === end_ind) {
              invalid_format_message(end_ind, "unexpected end of format");
            }
            var c$p$2 = Caml_string.get(str, str_ind$1 + 1 | 0);
            if (c$p$2 !== 37 && c$p$2 !== 64) {
              return fail_single_percent(str_ind$1);
            }
            add_range(c, c$p$2);
            return parse_char_set_content(str_ind$1 + 2 | 0, end_ind);
          }
          
        } else {
          exit = 2;
        }
        if (exit === 2 && c === /* '%' */37) {
          add_in_char_set(char_set, c$p);
          return parse_char_set_content(str_ind + 1 | 0, end_ind);
        }
        if (c === /* '%' */37) {
          fail_single_percent(str_ind);
        }
        add_in_char_set(char_set, c);
        _c = c$p;
        _str_ind = str_ind + 1 | 0;
        continue ;
      };
    };
    var parse_char_set_content = function (_str_ind, end_ind) {
      while(true) {
        var str_ind = _str_ind;
        if (str_ind === end_ind) {
          invalid_format_message(end_ind, "unexpected end of format");
        }
        var c = Caml_string.get(str, str_ind);
        if (c !== 45) {
          if (c !== 93) {
            return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
          } else {
            return str_ind + 1 | 0;
          }
        }
        add_in_char_set(char_set, /* '-' */45);
        _str_ind = str_ind + 1 | 0;
        continue ;
      };
    };
    var parse_char_set_start = function (str_ind, end_ind) {
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var c = Caml_string.get(str, str_ind);
      return parse_char_set_after_char(str_ind + 1 | 0, end_ind, c);
    };
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = Caml_string.get(str, str_ind);
    var match$1 = match !== 94 ? [
        str_ind,
        false
      ] : [
        str_ind + 1 | 0,
        true
      ];
    var next_ind = parse_char_set_start(match$1[0], end_ind);
    var char_set$1 = Stdlib__Bytes.to_string(char_set);
    return [
            next_ind,
            match$1[1] ? rev_char_set(char_set$1) : char_set$1
          ];
  };
  var is_int_base = function (symb) {
    switch (symb) {
      case 89 :
      case 90 :
      case 91 :
      case 92 :
      case 93 :
      case 94 :
      case 95 :
      case 96 :
      case 97 :
      case 98 :
      case 99 :
      case 101 :
      case 102 :
      case 103 :
      case 104 :
      case 106 :
      case 107 :
      case 108 :
      case 109 :
      case 110 :
      case 112 :
      case 113 :
      case 114 :
      case 115 :
      case 116 :
      case 118 :
      case 119 :
          return false;
      case 88 :
      case 100 :
      case 105 :
      case 111 :
      case 117 :
      case 120 :
          return true;
      default:
        return false;
    }
  };
  var compute_float_conv = function (pct_ind, str_ind, plus, hash, space, symb) {
    var flag = plus ? (
        space && !legacy_behavior$1 ? incompatible_flag(pct_ind, str_ind, /* ' ' */32, "'+'") : /* Float_flag_p */1
      ) : (
        space ? /* Float_flag_s */2 : /* Float_flag_ */0
      );
    var kind;
    var exit = 0;
    if (symb >= 73) {
      switch (symb) {
        case 101 :
            kind = /* Float_e */1;
            break;
        case 102 :
            kind = /* Float_f */0;
            break;
        case 103 :
            kind = /* Float_g */3;
            break;
        case 104 :
            kind = /* Float_h */6;
            break;
        default:
          exit = 1;
      }
    } else if (symb >= 69) {
      switch (symb) {
        case 69 :
            kind = /* Float_E */2;
            break;
        case 70 :
            exit = 1;
            break;
        case 71 :
            kind = /* Float_G */4;
            break;
        case 72 :
            kind = /* Float_H */7;
            break;
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (hash) {
        if (symb !== 70) {
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  2960,
                  11
                ],
                Error: new Error()
              };
        }
        kind = /* Float_CF */8;
      } else {
        if (symb !== 70) {
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalFormat.cppo.ml",
                  2960,
                  11
                ],
                Error: new Error()
              };
        }
        kind = /* Float_F */5;
      }
    }
    return [
            flag,
            kind
          ];
  };
  var counter_of_char = function (symb) {
    if (symb >= 108) {
      if (symb < 111) {
        switch (symb) {
          case 108 :
              return /* Line_counter */0;
          case 109 :
              break;
          case 110 :
              return /* Char_counter */1;
          
        }
      }
      
    } else if (symb === 76) {
      return /* Token_counter */2;
    }
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "camlinternalFormat.cppo.ml",
            2902,
            34
          ],
          Error: new Error()
        };
  };
  var search_subformat_end = function (_str_ind, end_ind, c) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        Curry._3(failwith_message(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "invalid format ",
                    _1: {
                      TAG: /* Caml_string */3,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": unclosed sub-format, expected \\"",
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* '%' */37,
                          _1: {
                            TAG: /* Char */0,
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "\\" at character number ",
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "invalid format %S: unclosed sub-format, expected \\"%%%c\\" at character number %d"
                }), str, c, end_ind);
      }
      var match = Caml_string.get(str, str_ind);
      if (match !== 37) {
        _str_ind = str_ind + 1 | 0;
        continue ;
      }
      if ((str_ind + 1 | 0) === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (Caml_string.get(str, str_ind + 1 | 0) === c) {
        return str_ind;
      }
      var match$1 = Caml_string.get(str, str_ind + 1 | 0);
      if (match$1 >= 95) {
        if (match$1 >= 123) {
          if (match$1 < 126) {
            switch (match$1) {
              case 123 :
                  var sub_end = search_subformat_end(str_ind + 2 | 0, end_ind, /* '}' */125);
                  _str_ind = sub_end + 2 | 0;
                  continue ;
              case 124 :
                  break;
              case 125 :
                  return expected_character(str_ind + 1 | 0, "character ')'", /* '}' */125);
              
            }
          }
          
        } else if (match$1 < 96) {
          if ((str_ind + 2 | 0) === end_ind) {
            invalid_format_message(end_ind, "unexpected end of format");
          }
          var match$2 = Caml_string.get(str, str_ind + 2 | 0);
          if (match$2 !== 40) {
            if (match$2 !== 123) {
              _str_ind = str_ind + 3 | 0;
              continue ;
            }
            var sub_end$1 = search_subformat_end(str_ind + 3 | 0, end_ind, /* '}' */125);
            _str_ind = sub_end$1 + 2 | 0;
            continue ;
          }
          var sub_end$2 = search_subformat_end(str_ind + 3 | 0, end_ind, /* ')' */41);
          _str_ind = sub_end$2 + 2 | 0;
          continue ;
        }
        
      } else if (match$1 !== 40) {
        if (match$1 === 41) {
          return expected_character(str_ind + 1 | 0, "character '}'", /* ')' */41);
        }
        
      } else {
        var sub_end$3 = search_subformat_end(str_ind + 2 | 0, end_ind, /* ')' */41);
        _str_ind = sub_end$3 + 2 | 0;
        continue ;
      }
      _str_ind = str_ind + 2 | 0;
      continue ;
    };
  };
  var parse_spaces = function (_str_ind, end_ind) {
    while(true) {
      var str_ind = _str_ind;
      if (str_ind === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      if (Caml_string.get(str, str_ind) !== /* ' ' */32) {
        return str_ind;
      }
      _str_ind = str_ind + 1 | 0;
      continue ;
    };
  };
  var parse_integer = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = Caml_string.get(str, str_ind);
    if (match >= 48) {
      if (match >= 58) {
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "camlinternalFormat.cppo.ml",
                2840,
                11
              ],
              Error: new Error()
            };
      }
      return parse_positive(str_ind, end_ind, 0);
    }
    if (match !== 45) {
      throw {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalFormat.cppo.ml",
              2840,
              11
            ],
            Error: new Error()
          };
    }
    if ((str_ind + 1 | 0) === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var c = Caml_string.get(str, str_ind + 1 | 0);
    if (c > 57 || c < 48) {
      return expected_character(str_ind + 1 | 0, "digit", c);
    }
    var match$1 = parse_positive(str_ind + 1 | 0, end_ind, 0);
    return [
            match$1[0],
            -match$1[1] | 0
          ];
  };
  var parse_conversion = function (pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
    var plus_used = false;
    var hash_used = false;
    var space_used = false;
    var ign_used = {
      contents: false
    };
    var pad_used = {
      contents: false
    };
    var prec_used = {
      contents: false
    };
    var get_int_pad = function (param) {
      pad_used.contents = true;
      prec_used.contents = true;
      if (typeof prec === "number" && !prec) {
        return pad;
      }
      if (typeof pad === "number") {
        return /* No_padding */0;
      } else if (pad.TAG === /* Lit_padding */0) {
        if (pad._0 >= 2) {
          if (legacy_behavior$1) {
            return {
                    TAG: /* Lit_padding */0,
                    _0: /* Right */1,
                    _1: pad._1
                  };
          } else {
            return incompatible_flag(pct_ind, str_ind, /* '0' */48, "precision");
          }
        } else {
          return pad;
        }
      } else if (pad._0 >= 2) {
        if (legacy_behavior$1) {
          return {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                };
        } else {
          return incompatible_flag(pct_ind, str_ind, /* '0' */48, "precision");
        }
      } else {
        return pad;
      }
    };
    var check_no_0 = function (symb, pad) {
      if (typeof pad === "number") {
        return pad;
      } else if (pad.TAG === /* Lit_padding */0) {
        if (pad._0 >= 2) {
          if (legacy_behavior$1) {
            return {
                    TAG: /* Lit_padding */0,
                    _0: /* Right */1,
                    _1: pad._1
                  };
          } else {
            return incompatible_flag(pct_ind, str_ind, symb, "0");
          }
        } else {
          return pad;
        }
      } else if (pad._0 >= 2) {
        if (legacy_behavior$1) {
          return {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                };
        } else {
          return incompatible_flag(pct_ind, str_ind, symb, "0");
        }
      } else {
        return pad;
      }
    };
    var opt_of_pad = function (c, pad) {
      if (typeof pad === "number") {
        return ;
      }
      if (pad.TAG !== /* Lit_padding */0) {
        return incompatible_flag(pct_ind, str_ind, c, "'*'");
      }
      switch (pad._0) {
        case /* Left */0 :
            if (legacy_behavior$1) {
              return pad._1;
            } else {
              return incompatible_flag(pct_ind, str_ind, c, "'-'");
            }
        case /* Right */1 :
            return pad._1;
        case /* Zeros */2 :
            if (legacy_behavior$1) {
              return pad._1;
            } else {
              return incompatible_flag(pct_ind, str_ind, c, "'0'");
            }
        
      }
    };
    var get_prec_opt = function (param) {
      prec_used.contents = true;
      if (typeof prec === "number") {
        if (prec) {
          return incompatible_flag(pct_ind, str_ind, /* '_' */95, "'*'");
        } else {
          return ;
        }
      } else {
        return prec._0;
      }
    };
    var fmt_result;
    var exit = 0;
    var exit$1 = 0;
    var exit$2 = 0;
    if (symb >= 124) {
      exit$1 = 6;
    } else {
      switch (symb) {
        case 33 :
            var fmt_rest = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Flush */10,
                _0: fmt_rest._0
              }
            };
            break;
        case 40 :
            var sub_end = search_subformat_end(str_ind, end_ind, /* ')' */41);
            var beg_ind = sub_end + 2 | 0;
            var fmt_rest$1 = parse_literal(beg_ind, beg_ind, end_ind);
            var fmt_rest$2 = fmt_rest$1._0;
            var sub_fmt = parse_literal(str_ind, str_ind, sub_end);
            var sub_fmtty = fmtty_of_fmt(sub_fmt._0);
            if (ign_used.contents = true, ign) {
              var ignored_0 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
              var ignored = {
                TAG: /* Ignored_format_subst */9,
                _0: ignored_0,
                _1: sub_fmtty
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored,
                  _1: fmt_rest$2
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Format_subst */14,
                  _0: opt_of_pad(/* '(' */40, (pad_used.contents = true, pad)),
                  _1: sub_fmtty,
                  _2: fmt_rest$2
                }
              };
            }
            break;
        case 44 :
            fmt_result = parse_literal(str_ind, str_ind, end_ind);
            break;
        case 37 :
        case 64 :
            exit$1 = 4;
            break;
        case 67 :
            var fmt_rest$3 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$4 = fmt_rest$3._0;
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */({
                  _0: {
                    TAG: /* Ignored_param */23,
                    _0: /* Ignored_caml_char */1,
                    _1: fmt_rest$4
                  }
                }) : /* Fmt_EBB */({
                  _0: {
                    TAG: /* Caml_char */1,
                    _0: fmt_rest$4
                  }
                });
            break;
        case 78 :
            var fmt_rest$5 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$6 = fmt_rest$5._0;
            if (ign_used.contents = true, ign) {
              var ignored$1 = {
                TAG: /* Ignored_scan_get_counter */11,
                _0: /* Token_counter */2
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$1,
                  _1: fmt_rest$6
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_get_counter */21,
                  _0: /* Token_counter */2,
                  _1: fmt_rest$6
                }
              };
            }
            break;
        case 83 :
            var pad$1 = check_no_0(symb, (pad_used.contents = true, padprec));
            var fmt_rest$7 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$8 = fmt_rest$7._0;
            if (ign_used.contents = true, ign) {
              var ignored$2 = {
                TAG: /* Ignored_caml_string */1,
                _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$2,
                  _1: fmt_rest$8
                }
              };
            } else {
              var match = make_padding_fmt_ebb(pad$1, fmt_rest$8);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Caml_string */3,
                  _0: match._0,
                  _1: match._1
                }
              };
            }
            break;
        case 91 :
            var match$1 = parse_char_set(str_ind, end_ind);
            var char_set = match$1[1];
            var next_ind = match$1[0];
            var fmt_rest$9 = parse_literal(next_ind, next_ind, end_ind);
            var fmt_rest$10 = fmt_rest$9._0;
            if (ign_used.contents = true, ign) {
              var ignored_0$1 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
              var ignored$3 = {
                TAG: /* Ignored_scan_char_set */10,
                _0: ignored_0$1,
                _1: char_set
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$3,
                  _1: fmt_rest$10
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_char_set */20,
                  _0: opt_of_pad(/* '[' */91, (pad_used.contents = true, pad)),
                  _1: char_set,
                  _2: fmt_rest$10
                }
              };
            }
            break;
        case 32 :
        case 35 :
        case 43 :
        case 45 :
        case 95 :
            exit$1 = 5;
            break;
        case 97 :
            var fmt_rest$11 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Alpha */15,
                _0: fmt_rest$11._0
              }
            };
            break;
        case 66 :
        case 98 :
            exit$1 = 3;
            break;
        case 99 :
            var char_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: /* Ignored_char */0,
                          _1: fmt_rest
                        }
                      };
              } else {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Char */0,
                          _0: fmt_rest
                        }
                      };
              }
            };
            var scan_format = function (fmt_rest) {
              if (ign_used.contents = true, ign) {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: /* Ignored_scan_next_char */3,
                          _1: fmt_rest
                        }
                      };
              } else {
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Scan_next_char */22,
                          _0: fmt_rest
                        }
                      };
              }
            };
            var fmt_rest$12 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$13 = fmt_rest$12._0;
            var _n = opt_of_pad(/* 'c' */99, (pad_used.contents = true, pad));
            fmt_result = _n !== undefined ? (
                _n !== 0 ? (
                    legacy_behavior$1 ? char_format(fmt_rest$13) : invalid_format_message(str_ind, "non-zero widths are unsupported for %c conversions")
                  ) : scan_format(fmt_rest$13)
              ) : char_format(fmt_rest$13);
            break;
        case 69 :
        case 70 :
        case 71 :
        case 72 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
            exit$1 = 2;
            break;
        case 76 :
        case 108 :
        case 110 :
            exit$2 = 8;
            break;
        case 114 :
            var fmt_rest$14 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$15 = fmt_rest$14._0;
            fmt_result = (ign_used.contents = true, ign) ? /* Fmt_EBB */({
                  _0: {
                    TAG: /* Ignored_param */23,
                    _0: /* Ignored_reader */2,
                    _1: fmt_rest$15
                  }
                }) : /* Fmt_EBB */({
                  _0: {
                    TAG: /* Reader */19,
                    _0: fmt_rest$15
                  }
                });
            break;
        case 115 :
            var pad$2 = check_no_0(symb, (pad_used.contents = true, padprec));
            var fmt_rest$16 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$17 = fmt_rest$16._0;
            if (ign_used.contents = true, ign) {
              var ignored$4 = {
                TAG: /* Ignored_string */0,
                _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$4,
                  _1: fmt_rest$17
                }
              };
            } else {
              var match$2 = make_padding_fmt_ebb(pad$2, fmt_rest$17);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* String */2,
                  _0: match$2._0,
                  _1: match$2._1
                }
              };
            }
            break;
        case 116 :
            var fmt_rest$18 = parse_literal(str_ind, str_ind, end_ind);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Theta */16,
                _0: fmt_rest$18._0
              }
            };
            break;
        case 88 :
        case 100 :
        case 105 :
        case 111 :
        case 117 :
        case 120 :
            exit$2 = 7;
            break;
        case 0 :
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        case 10 :
        case 11 :
        case 12 :
        case 13 :
        case 14 :
        case 15 :
        case 16 :
        case 17 :
        case 18 :
        case 19 :
        case 20 :
        case 21 :
        case 22 :
        case 23 :
        case 24 :
        case 25 :
        case 26 :
        case 27 :
        case 28 :
        case 29 :
        case 30 :
        case 31 :
        case 34 :
        case 36 :
        case 38 :
        case 39 :
        case 41 :
        case 42 :
        case 46 :
        case 47 :
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
        case 58 :
        case 59 :
        case 60 :
        case 61 :
        case 62 :
        case 63 :
        case 65 :
        case 68 :
        case 73 :
        case 74 :
        case 75 :
        case 77 :
        case 79 :
        case 80 :
        case 81 :
        case 82 :
        case 84 :
        case 85 :
        case 86 :
        case 87 :
        case 89 :
        case 90 :
        case 92 :
        case 93 :
        case 94 :
        case 96 :
        case 106 :
        case 107 :
        case 109 :
        case 112 :
        case 113 :
        case 118 :
        case 119 :
        case 121 :
        case 122 :
            exit$1 = 6;
            break;
        case 123 :
            var sub_end$1 = search_subformat_end(str_ind, end_ind, /* '}' */125);
            var sub_fmt$1 = parse_literal(str_ind, str_ind, sub_end$1);
            var beg_ind$1 = sub_end$1 + 2 | 0;
            var fmt_rest$19 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
            var fmt_rest$20 = fmt_rest$19._0;
            var sub_fmtty$1 = fmtty_of_fmt(sub_fmt$1._0);
            if (ign_used.contents = true, ign) {
              var ignored_0$2 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
              var ignored$5 = {
                TAG: /* Ignored_format_arg */8,
                _0: ignored_0$2,
                _1: sub_fmtty$1
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$5,
                  _1: fmt_rest$20
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Format_arg */13,
                  _0: opt_of_pad(/* '{' */123, (pad_used.contents = true, pad)),
                  _1: sub_fmtty$1,
                  _2: fmt_rest$20
                }
              };
            }
            break;
        
      }
    }
    switch (exit$2) {
      case 7 :
          plus_used = true;
          hash_used = true;
          space_used = true;
          var iconv = compute_int_conv(pct_ind, str_ind, plus, hash, space, symb);
          var fmt_rest$21 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$22 = fmt_rest$21._0;
          if (ign_used.contents = true, ign) {
            var ignored_1 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            var ignored$6 = {
              TAG: /* Ignored_int */2,
              _0: iconv,
              _1: ignored_1
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$6,
                _1: fmt_rest$22
              }
            };
          } else {
            var match$3 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$22);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Int */4,
                _0: iconv,
                _1: match$3._0,
                _2: match$3._1,
                _3: match$3._2
              }
            };
          }
          break;
      case 8 :
          if (str_ind === end_ind || !is_int_base(Caml_string.get(str, str_ind))) {
            var fmt_rest$23 = parse_literal(str_ind, str_ind, end_ind);
            var fmt_rest$24 = fmt_rest$23._0;
            var counter = counter_of_char(symb);
            if (ign_used.contents = true, ign) {
              var ignored$7 = {
                TAG: /* Ignored_scan_get_counter */11,
                _0: counter
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$7,
                  _1: fmt_rest$24
                }
              };
            } else {
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Scan_get_counter */21,
                  _0: counter,
                  _1: fmt_rest$24
                }
              };
            }
          } else {
            exit$1 = 6;
          }
          break;
      
    }
    switch (exit$1) {
      case 2 :
          plus_used = true;
          hash_used = true;
          space_used = true;
          var fconv = compute_float_conv(pct_ind, str_ind, plus, hash, space, symb);
          var fmt_rest$25 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$26 = fmt_rest$25._0;
          if (ign_used.contents = true, ign) {
            var ignored_0$3 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
            var ignored_1$1 = get_prec_opt(undefined);
            var ignored$8 = {
              TAG: /* Ignored_float */6,
              _0: ignored_0$3,
              _1: ignored_1$1
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$8,
                _1: fmt_rest$26
              }
            };
          } else {
            var match$4 = make_padprec_fmt_ebb((pad_used.contents = true, pad), (prec_used.contents = true, prec), fmt_rest$26);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Float */8,
                _0: fconv,
                _1: match$4._0,
                _2: match$4._1,
                _3: match$4._2
              }
            };
          }
          break;
      case 3 :
          var pad$3 = check_no_0(symb, (pad_used.contents = true, padprec));
          var fmt_rest$27 = parse_literal(str_ind, str_ind, end_ind);
          var fmt_rest$28 = fmt_rest$27._0;
          if (ign_used.contents = true, ign) {
            var ignored$9 = {
              TAG: /* Ignored_bool */7,
              _0: opt_of_pad(/* '_' */95, (pad_used.contents = true, padprec))
            };
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Ignored_param */23,
                _0: ignored$9,
                _1: fmt_rest$28
              }
            };
          } else {
            var match$5 = make_padding_fmt_ebb(pad$3, fmt_rest$28);
            fmt_result = /* Fmt_EBB */{
              _0: {
                TAG: /* Bool */9,
                _0: match$5._0,
                _1: match$5._1
              }
            };
          }
          break;
      case 4 :
          var fmt_rest$29 = parse_literal(str_ind, str_ind, end_ind);
          fmt_result = /* Fmt_EBB */{
            _0: {
              TAG: /* Char_literal */12,
              _0: symb,
              _1: fmt_rest$29._0
            }
          };
          break;
      case 5 :
          fmt_result = Curry._3(failwith_message(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid format ",
                      _1: {
                        TAG: /* Caml_string */3,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": at character number ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: ", flag ",
                              _1: {
                                TAG: /* Caml_char */1,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: " is only allowed after the '",
                                  _1: {
                                    TAG: /* Char_literal */12,
                                    _0: /* '%' */37,
                                    _1: {
                                      TAG: /* String_literal */11,
                                      _0: "', before padding and precision",
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"
                  }), str, pct_ind, symb);
          break;
      case 6 :
          if (symb >= 108) {
            if (symb >= 111) {
              exit = 1;
            } else {
              switch (symb) {
                case 108 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$1 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
                    var beg_ind$2 = str_ind + 1 | 0;
                    var fmt_rest$30 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
                    var fmt_rest$31 = fmt_rest$30._0;
                    if (ign_used.contents = true, ign) {
                      var ignored_1$2 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
                      var ignored$10 = {
                        TAG: /* Ignored_int32 */3,
                        _0: iconv$1,
                        _1: ignored_1$2
                      };
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: ignored$10,
                          _1: fmt_rest$31
                        }
                      };
                    } else {
                      var match$6 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$31);
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Int32 */5,
                          _0: iconv$1,
                          _1: match$6._0,
                          _2: match$6._1,
                          _3: match$6._2
                        }
                      };
                    }
                    break;
                case 109 :
                    exit = 1;
                    break;
                case 110 :
                    plus_used = true;
                    hash_used = true;
                    space_used = true;
                    var iconv$2 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
                    var beg_ind$3 = str_ind + 1 | 0;
                    var fmt_rest$32 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                    var fmt_rest$33 = fmt_rest$32._0;
                    if (ign_used.contents = true, ign) {
                      var ignored_1$3 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
                      var ignored$11 = {
                        TAG: /* Ignored_nativeint */4,
                        _0: iconv$2,
                        _1: ignored_1$3
                      };
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Ignored_param */23,
                          _0: ignored$11,
                          _1: fmt_rest$33
                        }
                      };
                    } else {
                      var match$7 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$33);
                      fmt_result = /* Fmt_EBB */{
                        _0: {
                          TAG: /* Nativeint */6,
                          _0: iconv$2,
                          _1: match$7._0,
                          _2: match$7._1,
                          _3: match$7._2
                        }
                      };
                    }
                    break;
                
              }
            }
          } else if (symb !== 76) {
            exit = 1;
          } else {
            plus_used = true;
            hash_used = true;
            space_used = true;
            var iconv$3 = compute_int_conv(pct_ind, str_ind + 1 | 0, plus, hash, space, Caml_string.get(str, str_ind));
            var beg_ind$4 = str_ind + 1 | 0;
            var fmt_rest$34 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
            var fmt_rest$35 = fmt_rest$34._0;
            if (ign_used.contents = true, ign) {
              var ignored_1$4 = opt_of_pad(/* '_' */95, (pad_used.contents = true, pad));
              var ignored$12 = {
                TAG: /* Ignored_int64 */5,
                _0: iconv$3,
                _1: ignored_1$4
              };
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Ignored_param */23,
                  _0: ignored$12,
                  _1: fmt_rest$35
                }
              };
            } else {
              var match$8 = make_padprec_fmt_ebb(get_int_pad(undefined), (prec_used.contents = true, prec), fmt_rest$35);
              fmt_result = /* Fmt_EBB */{
                _0: {
                  TAG: /* Int64 */7,
                  _0: iconv$3,
                  _1: match$8._0,
                  _2: match$8._1,
                  _3: match$8._2
                }
              };
            }
          }
          break;
      
    }
    if (exit === 1) {
      fmt_result = Curry._3(failwith_message(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "invalid format ",
                  _1: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ": at character number ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ", invalid conversion \\"",
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '%' */37,
                            _1: {
                              TAG: /* Char */0,
                              _0: {
                                TAG: /* Char_literal */12,
                                _0: /* '"' */34,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                _1: "invalid format %S: at character number %d, invalid conversion \\"%%%c\\""
              }), str, str_ind - 1 | 0, symb);
    }
    if (!legacy_behavior$1) {
      if (!plus_used && plus) {
        incompatible_flag(pct_ind, str_ind, symb, "'+'");
      }
      if (!hash_used && hash) {
        incompatible_flag(pct_ind, str_ind, symb, "'#'");
      }
      if (!space_used && space) {
        incompatible_flag(pct_ind, str_ind, symb, "' '");
      }
      if (!pad_used.contents && Caml_obj.caml_notequal(/* Padding_EBB */{
              _0: pad
            }, /* Padding_EBB */{
              _0: /* No_padding */0
            })) {
        incompatible_flag(pct_ind, str_ind, symb, "\`padding'");
      }
      if (!prec_used.contents && Caml_obj.caml_notequal(/* Precision_EBB */{
              _0: prec
            }, /* Precision_EBB */{
              _0: /* No_precision */0
            })) {
        incompatible_flag(pct_ind, str_ind, ign ? /* '_' */95 : symb, "\`precision'");
      }
      if (ign && plus) {
        incompatible_flag(pct_ind, str_ind, /* '_' */95, "'+'");
      }
      
    }
    if (!ign_used.contents && ign) {
      var exit$3 = 0;
      if (symb >= 38) {
        if (symb !== 44) {
          if (symb !== 64 || !legacy_behavior$1) {
            exit$3 = 1;
          }
          
        } else if (!legacy_behavior$1) {
          exit$3 = 1;
        }
        
      } else if (symb !== 33) {
        if (!(symb >= 37 && legacy_behavior$1)) {
          exit$3 = 1;
        }
        
      } else if (!legacy_behavior$1) {
        exit$3 = 1;
      }
      if (exit$3 === 1) {
        incompatible_flag(pct_ind, str_ind, symb, "'_'");
      }
      
    }
    return fmt_result;
  };
  var parse_after_precision = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var parse_conv = function (padprec) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, prec, padprec, Caml_string.get(str, str_ind));
    };
    if (typeof pad !== "number") {
      return parse_conv(pad);
    }
    if (typeof prec === "number" && !prec) {
      return parse_conv(/* No_padding */0);
    }
    if (minus) {
      if (typeof prec === "number") {
        return parse_conv({
                    TAG: /* Arg_padding */1,
                    _0: /* Left */0
                  });
      } else {
        return parse_conv({
                    TAG: /* Lit_padding */0,
                    _0: /* Left */0,
                    _1: prec._0
                  });
      }
    } else if (typeof prec === "number") {
      return parse_conv({
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                });
    } else {
      return parse_conv({
                  TAG: /* Lit_padding */0,
                  _0: /* Right */1,
                  _1: prec._0
                });
    }
  };
  var parse_after_at = function (str_ind, end_ind) {
    if (str_ind === end_ind) {
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* '@' */64,
                _1: /* End_of_format */0
              }
            };
    }
    var c = Caml_string.get(str, str_ind);
    if (c >= 65) {
      if (c >= 94) {
        switch (c) {
          case 123 :
              return parse_tag(true, str_ind + 1 | 0, end_ind);
          case 124 :
              break;
          case 125 :
              var beg_ind = str_ind + 1 | 0;
              var fmt_rest = parse_literal(beg_ind, beg_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_tag */1,
                        _1: fmt_rest._0
                      }
                    };
          default:
            
        }
      } else if (c >= 91) {
        switch (c) {
          case 91 :
              return parse_tag(false, str_ind + 1 | 0, end_ind);
          case 92 :
              break;
          case 93 :
              var beg_ind$1 = str_ind + 1 | 0;
              var fmt_rest$1 = parse_literal(beg_ind$1, beg_ind$1, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Close_box */0,
                        _1: fmt_rest$1._0
                      }
                    };
          
        }
      }
      
    } else if (c !== 10) {
      if (c >= 32) {
        switch (c) {
          case 32 :
              var beg_ind$2 = str_ind + 1 | 0;
              var fmt_rest$2 = parse_literal(beg_ind$2, beg_ind$2, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@ ",
                          _1: 1,
                          _2: 0
                        },
                        _1: fmt_rest$2._0
                      }
                    };
          case 37 :
              if ((str_ind + 1 | 0) < end_ind && Caml_string.get(str, str_ind + 1 | 0) === /* '%' */37) {
                var beg_ind$3 = str_ind + 2 | 0;
                var fmt_rest$3 = parse_literal(beg_ind$3, beg_ind$3, end_ind);
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Escaped_percent */6,
                          _1: fmt_rest$3._0
                        }
                      };
              }
              var fmt_rest$4 = parse_literal(str_ind, str_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Char_literal */12,
                        _0: /* '@' */64,
                        _1: fmt_rest$4._0
                      }
                    };
          case 44 :
              var beg_ind$4 = str_ind + 1 | 0;
              var fmt_rest$5 = parse_literal(beg_ind$4, beg_ind$4, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Break */0,
                          _0: "@,",
                          _1: 0,
                          _2: 0
                        },
                        _1: fmt_rest$5._0
                      }
                    };
          case 46 :
              var beg_ind$5 = str_ind + 1 | 0;
              var fmt_rest$6 = parse_literal(beg_ind$5, beg_ind$5, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Flush_newline */4,
                        _1: fmt_rest$6._0
                      }
                    };
          case 59 :
              var str_ind$1 = str_ind + 1 | 0;
              var match;
              try {
                if (str_ind$1 === end_ind || Caml_string.get(str, str_ind$1) !== /* '<' */60) {
                  throw {
                        MEL_EXN_ID: Stdlib.Not_found,
                        Error: new Error()
                      };
                }
                var str_ind_1 = parse_spaces(str_ind$1 + 1 | 0, end_ind);
                var match$1 = Caml_string.get(str, str_ind_1);
                var exit = 0;
                if (match$1 >= 48) {
                  if (match$1 >= 58) {
                    throw {
                          MEL_EXN_ID: Stdlib.Not_found,
                          Error: new Error()
                        };
                  }
                  exit = 1;
                } else {
                  if (match$1 !== 45) {
                    throw {
                          MEL_EXN_ID: Stdlib.Not_found,
                          Error: new Error()
                        };
                  }
                  exit = 1;
                }
                if (exit === 1) {
                  var match$2 = parse_integer(str_ind_1, end_ind);
                  var width = match$2[1];
                  var str_ind_3 = parse_spaces(match$2[0], end_ind);
                  var match$3 = Caml_string.get(str, str_ind_3);
                  if (match$3 > 57 || match$3 < 45) {
                    if (match$3 !== 62) {
                      throw {
                            MEL_EXN_ID: Stdlib.Not_found,
                            Error: new Error()
                          };
                    }
                    var s = Stdlib__String.sub(str, str_ind$1 - 2 | 0, (str_ind_3 - str_ind$1 | 0) + 3 | 0);
                    match = [
                      str_ind_3 + 1 | 0,
                      {
                        TAG: /* Break */0,
                        _0: s,
                        _1: width,
                        _2: 0
                      }
                    ];
                  } else {
                    if (match$3 === 47 || match$3 === 46) {
                      throw {
                            MEL_EXN_ID: Stdlib.Not_found,
                            Error: new Error()
                          };
                    }
                    var match$4 = parse_integer(str_ind_3, end_ind);
                    var str_ind_5 = parse_spaces(match$4[0], end_ind);
                    if (Caml_string.get(str, str_ind_5) !== /* '>' */62) {
                      throw {
                            MEL_EXN_ID: Stdlib.Not_found,
                            Error: new Error()
                          };
                    }
                    var s$1 = Stdlib__String.sub(str, str_ind$1 - 2 | 0, (str_ind_5 - str_ind$1 | 0) + 3 | 0);
                    match = [
                      str_ind_5 + 1 | 0,
                      {
                        TAG: /* Break */0,
                        _0: s$1,
                        _1: width,
                        _2: match$4[1]
                      }
                    ];
                  }
                }
                
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.MEL_EXN_ID === Stdlib.Not_found || exn.MEL_EXN_ID === Stdlib.Failure) {
                  match = [
                    str_ind$1,
                    {
                      TAG: /* Break */0,
                      _0: "@;",
                      _1: 1,
                      _2: 0
                    }
                  ];
                } else {
                  throw exn;
                }
              }
              var next_ind = match[0];
              var fmt_rest$7 = parse_literal(next_ind, next_ind, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: match[1],
                        _1: fmt_rest$7._0
                      }
                    };
          case 60 :
              var str_ind$2 = str_ind + 1 | 0;
              var match$5;
              try {
                var str_ind_1$1 = parse_spaces(str_ind$2, end_ind);
                var match$6 = Caml_string.get(str, str_ind_1$1);
                var exit$1 = 0;
                if (match$6 >= 48) {
                  if (match$6 >= 58) {
                    match$5 = undefined;
                  } else {
                    exit$1 = 1;
                  }
                } else if (match$6 !== 45) {
                  match$5 = undefined;
                } else {
                  exit$1 = 1;
                }
                if (exit$1 === 1) {
                  var match$7 = parse_integer(str_ind_1$1, end_ind);
                  var str_ind_3$1 = parse_spaces(match$7[0], end_ind);
                  if (Caml_string.get(str, str_ind_3$1) !== /* '>' */62) {
                    throw {
                          MEL_EXN_ID: Stdlib.Not_found,
                          Error: new Error()
                        };
                  }
                  var s$2 = Stdlib__String.sub(str, str_ind$2 - 2 | 0, (str_ind_3$1 - str_ind$2 | 0) + 3 | 0);
                  match$5 = [
                    str_ind_3$1 + 1 | 0,
                    {
                      TAG: /* Magic_size */1,
                      _0: s$2,
                      _1: match$7[1]
                    }
                  ];
                }
                
              }
              catch (raw_exn$1){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.MEL_EXN_ID === Stdlib.Not_found || exn$1.MEL_EXN_ID === Stdlib.Failure) {
                  match$5 = undefined;
                } else {
                  throw exn$1;
                }
              }
              if (match$5 !== undefined) {
                var next_ind$1 = match$5[0];
                var fmt_rest$8 = parse_literal(next_ind$1, next_ind$1, end_ind);
                return /* Fmt_EBB */{
                        _0: {
                          TAG: /* Formatting_lit */17,
                          _0: match$5[1],
                          _1: fmt_rest$8._0
                        }
                      };
              }
              var fmt_rest$9 = parse_literal(str_ind$2, str_ind$2, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: {
                          TAG: /* Scan_indic */2,
                          _0: /* '<' */60
                        },
                        _1: fmt_rest$9._0
                      }
                    };
          case 33 :
          case 34 :
          case 35 :
          case 36 :
          case 38 :
          case 39 :
          case 40 :
          case 41 :
          case 42 :
          case 43 :
          case 45 :
          case 47 :
          case 48 :
          case 49 :
          case 50 :
          case 51 :
          case 52 :
          case 53 :
          case 54 :
          case 55 :
          case 56 :
          case 57 :
          case 58 :
          case 61 :
          case 62 :
              break;
          case 63 :
              var beg_ind$6 = str_ind + 1 | 0;
              var fmt_rest$10 = parse_literal(beg_ind$6, beg_ind$6, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* FFlush */2,
                        _1: fmt_rest$10._0
                      }
                    };
          case 64 :
              var beg_ind$7 = str_ind + 1 | 0;
              var fmt_rest$11 = parse_literal(beg_ind$7, beg_ind$7, end_ind);
              return /* Fmt_EBB */{
                      _0: {
                        TAG: /* Formatting_lit */17,
                        _0: /* Escaped_at */5,
                        _1: fmt_rest$11._0
                      }
                    };
          
        }
      }
      
    } else {
      var beg_ind$8 = str_ind + 1 | 0;
      var fmt_rest$12 = parse_literal(beg_ind$8, beg_ind$8, end_ind);
      return /* Fmt_EBB */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* Force_newline */3,
                _1: fmt_rest$12._0
              }
            };
    }
    var beg_ind$9 = str_ind + 1 | 0;
    var fmt_rest$13 = parse_literal(beg_ind$9, beg_ind$9, end_ind);
    return /* Fmt_EBB */{
            _0: {
              TAG: /* Formatting_lit */17,
              _0: {
                TAG: /* Scan_indic */2,
                _0: c
              },
              _1: fmt_rest$13._0
            }
          };
  };
  var add_literal = function (lit_start, str_ind, fmt) {
    var size = str_ind - lit_start | 0;
    if (size !== 0) {
      if (size !== 1) {
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: Stdlib__String.sub(str, lit_start, size),
                  _1: fmt
                }
              };
      } else {
        return /* Fmt_EBB */{
                _0: {
                  TAG: /* Char_literal */12,
                  _0: Caml_string.get(str, lit_start),
                  _1: fmt
                }
              };
      }
    } else {
      return /* Fmt_EBB */{
              _0: fmt
            };
    }
  };
  var parse_format = function (pct_ind, end_ind) {
    var str_ind = pct_ind + 1 | 0;
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var match = Caml_string.get(str, str_ind);
    if (match !== 95) {
      return parse_flags(pct_ind, str_ind, end_ind, false);
    } else {
      return parse_flags(pct_ind, str_ind + 1 | 0, end_ind, true);
    }
  };
  var parse_after_padding = function (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
    if (str_ind === end_ind) {
      invalid_format_message(end_ind, "unexpected end of format");
    }
    var symb = Caml_string.get(str, str_ind);
    if (symb !== 46) {
      return parse_conversion(pct_ind, str_ind + 1 | 0, end_ind, plus, hash, space, ign, pad, /* No_precision */0, pad, symb);
    } else {
      var str_ind$1 = str_ind + 1 | 0;
      if (str_ind$1 === end_ind) {
        invalid_format_message(end_ind, "unexpected end of format");
      }
      var parse_literal = function (minus, str_ind) {
        var match = parse_positive(str_ind, end_ind, 0);
        return parse_after_precision(pct_ind, match[0], end_ind, minus, plus, hash, space, ign, pad, /* Lit_precision */{
                    _0: match[1]
                  });
      };
      var symb$1 = Caml_string.get(str, str_ind$1);
      var exit = 0;
      if (symb$1 >= 48) {
        if (symb$1 < 58) {
          return parse_literal(minus, str_ind$1);
        }
        
      } else if (symb$1 >= 42) {
        switch (symb$1) {
          case 42 :
              return parse_after_precision(pct_ind, str_ind$1 + 1 | 0, end_ind, minus, plus, hash, space, ign, pad, /* Arg_precision */1);
          case 43 :
          case 45 :
              exit = 2;
              break;
          case 44 :
          case 46 :
          case 47 :
              break;
          
        }
      }
      if (exit === 2 && legacy_behavior$1) {
        return parse_literal(minus || symb$1 === /* '-' */45, str_ind$1 + 1 | 0);
      }
      if (legacy_behavior$1) {
        return parse_after_precision(pct_ind, str_ind$1, end_ind, minus, plus, hash, space, ign, pad, /* Lit_precision */{
                    _0: 0
                  });
      } else {
        return invalid_format_without(str_ind$1 - 1 | 0, /* '.' */46, "precision");
      }
    }
  };
  return parse_literal(0, 0, str.length);
}

function format_of_string_fmtty(str, fmtty) {
  var fmt = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */{
            _0: type_format(fmt._0, fmtty),
            _1: str
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Type_mismatch) {
      return Curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "bad input: format type mismatch between ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " and ",
                            _1: {
                              TAG: /* Caml_string */3,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "bad input: format type mismatch between %S and %S"
                    }), str, string_of_fmtty(fmtty));
    }
    throw exn;
  }
}

function format_of_string_format(str, param) {
  var fmt = fmt_ebb_of_string(undefined, str);
  try {
    return /* Format */{
            _0: type_format(fmt._0, fmtty_of_fmt(param._0)),
            _1: str
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Type_mismatch) {
      return Curry._2(failwith_message(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "bad input: format type mismatch between ",
                        _1: {
                          TAG: /* Caml_string */3,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " and ",
                            _1: {
                              TAG: /* Caml_string */3,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      },
                      _1: "bad input: format type mismatch between %S and %S"
                    }), str, param._1);
    }
    throw exn;
  }
}

export {
  is_in_char_set ,
  rev_char_set ,
  create_char_set ,
  add_in_char_set ,
  freeze_char_set ,
  param_format_of_ignored_format ,
  make_printf ,
  make_iprintf ,
  output_acc ,
  bufput_acc ,
  strput_acc ,
  type_format ,
  fmt_ebb_of_string ,
  format_of_string_fmtty ,
  format_of_string_format ,
  char_of_iconv ,
  string_of_formatting_lit ,
  string_of_fmtty ,
  string_of_fmt ,
  open_box_of_string ,
  symm ,
  trans ,
  recast ,
}
/* No side effect */
`,wu=`// Generated by Melange


function erase_rel(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  }
  switch (param.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: erase_rel(param._0)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: erase_rel(param._0)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: erase_rel(param._0)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: erase_rel(param._0)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: erase_rel(param._0)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: erase_rel(param._0)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: erase_rel(param._0)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: erase_rel(param._0)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: param._0,
                _1: erase_rel(param._1)
              };
    case /* Format_subst_ty */9 :
        var ty1 = param._0;
        return {
                TAG: /* Format_subst_ty */9,
                _0: ty1,
                _1: ty1,
                _2: erase_rel(param._2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: erase_rel(param._0)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: erase_rel(param._0)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: erase_rel(param._0)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: erase_rel(param._0)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: erase_rel(param._0)
              };
    
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (typeof fmtty1 === "number") {
    return fmtty2;
  }
  switch (fmtty1.TAG | 0) {
    case /* Char_ty */0 :
        return {
                TAG: /* Char_ty */0,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* String_ty */1 :
        return {
                TAG: /* String_ty */1,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int_ty */2 :
        return {
                TAG: /* Int_ty */2,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int32_ty */3 :
        return {
                TAG: /* Int32_ty */3,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Nativeint_ty */4 :
        return {
                TAG: /* Nativeint_ty */4,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Int64_ty */5 :
        return {
                TAG: /* Int64_ty */5,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Float_ty */6 :
        return {
                TAG: /* Float_ty */6,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Bool_ty */7 :
        return {
                TAG: /* Bool_ty */7,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Format_arg_ty */8 :
        return {
                TAG: /* Format_arg_ty */8,
                _0: fmtty1._0,
                _1: concat_fmtty(fmtty1._1, fmtty2)
              };
    case /* Format_subst_ty */9 :
        return {
                TAG: /* Format_subst_ty */9,
                _0: fmtty1._0,
                _1: fmtty1._1,
                _2: concat_fmtty(fmtty1._2, fmtty2)
              };
    case /* Alpha_ty */10 :
        return {
                TAG: /* Alpha_ty */10,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Theta_ty */11 :
        return {
                TAG: /* Theta_ty */11,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Any_ty */12 :
        return {
                TAG: /* Any_ty */12,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Reader_ty */13 :
        return {
                TAG: /* Reader_ty */13,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    case /* Ignored_reader_ty */14 :
        return {
                TAG: /* Ignored_reader_ty */14,
                _0: concat_fmtty(fmtty1._0, fmtty2)
              };
    
  }
}

function concat_fmt(fmt1, fmt2) {
  if (typeof fmt1 === "number") {
    return fmt2;
  }
  switch (fmt1.TAG | 0) {
    case /* Char */0 :
        return {
                TAG: /* Char */0,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Caml_char */1 :
        return {
                TAG: /* Caml_char */1,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* String */2 :
        return {
                TAG: /* String */2,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Caml_string */3 :
        return {
                TAG: /* Caml_string */3,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Int */4 :
        return {
                TAG: /* Int */4,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Int32 */5 :
        return {
                TAG: /* Int32 */5,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Nativeint */6 :
        return {
                TAG: /* Nativeint */6,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Int64 */7 :
        return {
                TAG: /* Int64 */7,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Float */8 :
        return {
                TAG: /* Float */8,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: fmt1._2,
                _3: concat_fmt(fmt1._3, fmt2)
              };
    case /* Bool */9 :
        return {
                TAG: /* Bool */9,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Flush */10 :
        return {
                TAG: /* Flush */10,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* String_literal */11 :
        return {
                TAG: /* String_literal */11,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Char_literal */12 :
        return {
                TAG: /* Char_literal */12,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Format_arg */13 :
        return {
                TAG: /* Format_arg */13,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Format_subst */14 :
        return {
                TAG: /* Format_subst */14,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Alpha */15 :
        return {
                TAG: /* Alpha */15,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Theta */16 :
        return {
                TAG: /* Theta */16,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Formatting_lit */17 :
        return {
                TAG: /* Formatting_lit */17,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Formatting_gen */18 :
        return {
                TAG: /* Formatting_gen */18,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Reader */19 :
        return {
                TAG: /* Reader */19,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Scan_char_set */20 :
        return {
                TAG: /* Scan_char_set */20,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    case /* Scan_get_counter */21 :
        return {
                TAG: /* Scan_get_counter */21,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Scan_next_char */22 :
        return {
                TAG: /* Scan_next_char */22,
                _0: concat_fmt(fmt1._0, fmt2)
              };
    case /* Ignored_param */23 :
        return {
                TAG: /* Ignored_param */23,
                _0: fmt1._0,
                _1: concat_fmt(fmt1._1, fmt2)
              };
    case /* Custom */24 :
        return {
                TAG: /* Custom */24,
                _0: fmt1._0,
                _1: fmt1._1,
                _2: concat_fmt(fmt1._2, fmt2)
              };
    
  }
}

export {
  concat_fmtty ,
  erase_rel ,
  concat_fmt ,
}
/* No side effect */
`,Cu=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";

var Undefined = /* @__PURE__ */Caml_exceptions.create("CamlinternalLazy.Undefined");

function is_val(l) {
  return l.LAZY_DONE;
}

function forward_with_closure(blk, closure) {
  var result = closure();
  blk.VAL = result;
  blk.LAZY_DONE = true;
  return result;
}

function raise_undefined() {
  throw {
        MEL_EXN_ID: Undefined,
        Error: new Error()
      };
}

function force_lazy_block(blk) {
  var closure = blk.VAL;
  blk.VAL = raise_undefined;
  try {
    return forward_with_closure(blk, closure);
  }
  catch (e){
    blk.VAL = (function () {
        throw e;
      });
    throw e;
  }
}

function force_val_lazy_block(blk) {
  var closure = blk.VAL;
  blk.VAL = raise_undefined;
  return forward_with_closure(blk, closure);
}

function force(lzv) {
  if (lzv.LAZY_DONE) {
    return lzv.VAL;
  } else {
    return force_lazy_block(lzv);
  }
}

function force_val(lzv) {
  if (lzv.LAZY_DONE) {
    return lzv.VAL;
  } else {
    return force_val_lazy_block(lzv);
  }
}

export {
  Undefined ,
  force_lazy_block ,
  force_val_lazy_block ,
  force ,
  force_val ,
  is_val ,
}
/* No side effect */
`,Su=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,Au=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_oo from "melange.js/caml_oo.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__List from "./list.js";

var new_object_tag_block = (function(size){
  var v = new Array(size)
  v.TAG = 248 // tag
  return v
});

function copy(o) {
  return Caml_oo.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

var params = {
  compact_table: true,
  copy_parent: true,
  clean_when_copying: true,
  retry_count: 3,
  bucket_small_size: 16
};

function public_method_label(s) {
  var accu = 0;
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

var compare = Caml.caml_string_compare;

var funarg = {
  compare: compare
};

function height(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal(l, x, d, r) {
  var hl = l ? l.h : 0;
  var hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l.r;
      var ld = l.d;
      var lv = l.v;
      var ll = l.l;
      if (height(ll) >= height(lr)) {
        return create(ll, lv, ld, create(lr, x, d, r));
      }
      if (lr) {
        return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    var rr = r.r;
    var rd = r.d;
    var rv = r.v;
    var rl = r.l;
    if (height(rr) >= height(rl)) {
      return create(create(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal",
        Error: new Error()
      };
}

function add(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    var ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  var rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

function fold(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

var compare$1 = Caml.caml_string_compare;

var funarg$1 = {
  compare: compare$1
};

function height$1(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  var hl = height$1(l);
  var hr = height$1(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$1(l, x, d, r) {
  var hl = l ? l.h : 0;
  var hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l.r;
      var ld = l.d;
      var lv = l.v;
      var ll = l.l;
      if (height$1(ll) >= height$1(lr)) {
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      }
      if (lr) {
        return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    var rr = r.r;
    var rd = r.d;
    var rv = r.v;
    var rl = r.l;
    if (height$1(rr) >= height$1(rl)) {
      return create$1(create$1(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal",
        Error: new Error()
      };
}

function add$1(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    var ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  var rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Curry._2(funarg$1.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

var compare$2 = Caml.caml_int_compare;

var funarg$2 = {
  compare: compare$2
};

function height$2(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$2(l, x, d, r) {
  var hl = height$2(l);
  var hr = height$2(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$2(l, x, d, r) {
  var hl = l ? l.h : 0;
  var hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      var lr = l.r;
      var ld = l.d;
      var lv = l.v;
      var ll = l.l;
      if (height$2(ll) >= height$2(lr)) {
        return create$2(ll, lv, ld, create$2(lr, x, d, r));
      }
      if (lr) {
        return create$2(create$2(ll, lv, ld, lr.l), lr.v, lr.d, create$2(lr.r, x, d, r));
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    var rr = r.r;
    var rd = r.d;
    var rv = r.v;
    var rl = r.l;
    if (height$2(rr) >= height$2(rl)) {
      return create$2(create$2(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$2(create$2(l, x, d, rl.l), rl.v, rl.d, create$2(rl.r, rv, rd, rr));
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Map.bal",
        Error: new Error()
      };
}

function add$2(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  var r = m.r;
  var d = m.d;
  var v = m.v;
  var l = m.l;
  var c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    var ll = add$2(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  var rr = add$2(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function find$2(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var c = Curry._2(funarg$2.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

var dummy_table = {
  size: 0,
  methods: [undefined],
  methods_by_name: /* Empty */0,
  methods_by_label: /* Empty */0,
  previous_states: /* [] */0,
  hidden_meths: /* [] */0,
  vars: /* Empty */0,
  initializers: /* [] */0
};

var table_count = {
  contents: 0
};

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  table_count.contents = table_count.contents + 1 | 0;
  var len = pub_labels.length;
  var methods = Caml_array.make((len << 1) + 2 | 0, /* DummyA */0);
  Caml_array.set(methods, 0, len);
  Caml_array.set(methods, 1, ((fit_size(len) << 5) / 8 | 0) - 1 | 0);
  for(var i = 0; i < len; ++i){
    Caml_array.set(methods, (i << 1) + 3 | 0, Caml_array.get(pub_labels, i));
  }
  return {
          size: 2,
          methods: methods,
          methods_by_name: /* Empty */0,
          methods_by_label: /* Empty */0,
          previous_states: /* [] */0,
          hidden_meths: /* [] */0,
          vars: /* Empty */0,
          initializers: /* [] */0
        };
}

function resize(array, new_size) {
  var old_size = array.methods.length;
  if (new_size <= old_size) {
    return ;
  }
  var new_buck = Caml_array.make(new_size, /* DummyA */0);
  Stdlib__Array.blit(array.methods, 0, new_buck, 0, old_size);
  array.methods = new_buck;
}

var method_count = {
  contents: 0
};

var inst_var_count = {
  contents: 0
};

function new_method(table) {
  var index = table.methods.length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    return Curry._2(find$1, name, table.methods_by_name);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      var label = new_method(table);
      table.methods_by_name = Curry._3(add$1, name, label, table.methods_by_name);
      table.methods_by_label = Curry._3(add$2, label, true, table.methods_by_label);
      return label;
    }
    throw exn;
  }
}

function get_method_labels(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_method_label(table, param);
              }), names);
}

function set_method(table, label, element) {
  method_count.contents = method_count.contents + 1 | 0;
  if (Curry._2(find$2, label, table.methods_by_label)) {
    resize(table, label + 1 | 0);
    return Caml_array.set(table.methods, label, element);
  } else {
    table.hidden_meths = {
      hd: [
        label,
        element
      ],
      tl: table.hidden_meths
    };
    return ;
  }
}

function get_method(table, label) {
  try {
    return Stdlib__List.assoc(label, table.hidden_meths);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Caml_array.get(table.methods, label);
    }
    throw exn;
  }
}

function to_list(arr) {
  if (arr === 0) {
    return /* [] */0;
  } else {
    return Stdlib__Array.to_list(arr);
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  var vars$1 = to_list(vars);
  var virt_meths$1 = to_list(virt_meths);
  var concr_meths$1 = to_list(concr_meths);
  var virt_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), virt_meths$1);
  var concr_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), concr_meths$1);
  table.previous_states = {
    hd: [
      table.methods_by_name,
      table.methods_by_label,
      table.hidden_meths,
      table.vars,
      virt_meth_labs,
      vars$1
    ],
    tl: table.previous_states
  };
  table.vars = Curry._3(fold, (function (lab, info, tvars) {
          if (Stdlib__List.mem(lab, vars$1)) {
            return Curry._3(add, lab, info, tvars);
          } else {
            return tvars;
          }
        }), table.vars, /* Empty */0);
  var by_name = {
    contents: /* Empty */0
  };
  var by_label = {
    contents: /* Empty */0
  };
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          var tmp;
          try {
            tmp = Curry._2(find$2, label, table.methods_by_label);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              tmp = true;
            } else {
              throw exn;
            }
          }
          by_label.contents = Curry._3(add$2, label, tmp, by_label.contents);
        }), concr_meths$1, concr_meth_labs);
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          by_label.contents = Curry._3(add$2, label, false, by_label.contents);
        }), virt_meths$1, virt_meth_labs);
  table.methods_by_name = by_name.contents;
  table.methods_by_label = by_label.contents;
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meth_labs)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, /* [] */0);
}

function widen(table) {
  var match = Stdlib__List.hd(table.previous_states);
  var virt_meths = match[4];
  table.previous_states = Stdlib__List.tl(table.previous_states);
  table.vars = Stdlib__List.fold_left((function (s, v) {
          return Curry._3(add, v, Curry._2(find, v, table.vars), s);
        }), match[3], match[5]);
  table.methods_by_name = match[0];
  table.methods_by_label = match[1];
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meths)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, match[2]);
}

function new_slot(table) {
  var index = table.size;
  table.size = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      var index = new_slot(table);
      if (name !== "") {
        table.vars = Curry._3(add, name, index, table.vars);
      }
      return index;
    }
    throw exn;
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return [];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  var meths$1 = to_array(meths);
  var nmeths = meths$1.length;
  var nvals = vals.length;
  var res = Caml_array.make(nmeths + nvals | 0, 0);
  for(var i = 0; i < nmeths; ++i){
    Caml_array.set(res, i, get_method_label(table, Caml_array.get(meths$1, i)));
  }
  for(var i$1 = 0; i$1 < nvals; ++i$1){
    Caml_array.set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              301,
              20
            ],
            Error: new Error()
          };
    }
    throw exn;
  }
}

function get_variables(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_variable(table, param);
              }), names);
}

function add_initializer(table, f) {
  table.initializers = {
    hd: f,
    tl: table.initializers
  };
}

function create_table(public_methods) {
  if (public_methods === 0) {
    return new_table([]);
  }
  var tags = Stdlib__Array.map(public_method_label, public_methods);
  var table = new_table(tags);
  Stdlib__Array.iteri((function (i, met) {
          var lab = (i << 1) + 2 | 0;
          table.methods_by_name = Curry._3(add$1, met, lab, table.methods_by_name);
          table.methods_by_label = Curry._3(add$2, lab, true, table.methods_by_label);
        }), public_methods);
  return table;
}

function init_class(table) {
  inst_var_count.contents = (inst_var_count.contents + table.size | 0) - 1 | 0;
  table.initializers = Stdlib__List.rev(table.initializers);
  resize(table, 3 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  var $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  var init = top ? Curry._2($$super, cla, param[3]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.concat({
              hd: [init],
              tl: {
                hd: Stdlib__Array.map((function (param) {
                        return get_variable(cla, param);
                      }), to_array(vals)),
                tl: {
                  hd: Stdlib__Array.map((function (nm) {
                          return get_method(cla, get_method_label(cla, nm));
                        }), to_array(concr_meths)),
                  tl: /* [] */0
                }
              }
            });
}

function make_class(pub_meths, class_init) {
  var table = create_table(pub_meths);
  var env_init = Curry._1(class_init, table);
  init_class(table);
  return [
          Curry._1(env_init, 0),
          class_init,
          env_init,
          0
        ];
}

function make_class_store(pub_meths, class_init, init_table) {
  var table = create_table(pub_meths);
  var env_init = Curry._1(class_init, table);
  init_class(table);
  init_table.class_init = class_init;
  init_table.env_init = env_init;
}

function create_object(table) {
  var obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function create_object_opt(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  var obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function iter_f(obj, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    Curry._1(param.hd, obj);
    _param = param.tl;
    continue ;
  };
}

function run_initializers(obj, table) {
  var inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    return iter_f(obj, inits);
  }
  
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  }
  var inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    iter_f(obj, inits);
  }
  return obj;
}

function create_object_and_run_initializers(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  var obj = create_object(table);
  run_initializers(obj, table);
  return obj;
}

function set_data(tables, v) {
  if (tables) {
    tables.data = v;
    return ;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          436,
          13
        ],
        Error: new Error()
      };
}

function set_next(tables, v) {
  if (tables) {
    tables.next = v;
    return ;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          439,
          13
        ],
        Error: new Error()
      };
}

function get_key(param) {
  if (param) {
    return param.key;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          442,
          13
        ],
        Error: new Error()
      };
}

function get_data(param) {
  if (param) {
    return param.data;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          445,
          13
        ],
        Error: new Error()
      };
}

function get_next(param) {
  if (param) {
    return param.next;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "camlinternalOO.cppo.ml",
          448,
          13
        ],
        Error: new Error()
      };
}

function build_path(n, keys, tables) {
  var res = /* Cons */{
    key: 0,
    data: /* Empty */0,
    next: /* Empty */0
  };
  var r = res;
  for(var i = 0; i <= n; ++i){
    r = /* Cons */{
      key: Caml_array.get(keys, i),
      data: r,
      next: /* Empty */0
    };
  }
  set_data(tables, r);
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  }
  var key = Caml_array.get(keys, i);
  var _tables = tables;
  while(true) {
    var tables$1 = _tables;
    if (get_key(tables$1) === key) {
      var tables_data = get_data(tables$1);
      if (tables_data) {
        return lookup_keys(i - 1 | 0, keys, tables_data);
      }
      throw {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              466,
              17
            ],
            Error: new Error()
          };
    }
    var next = get_next(tables$1);
    if (next) {
      _tables = next;
      continue ;
    }
    var next$1 = /* Cons */{
      key: key,
      data: /* Empty */0,
      next: /* Empty */0
    };
    set_next(tables$1, next$1);
    return build_path(i - 1 | 0, keys, next$1);
  };
}

function lookup_tables(root, keys) {
  var root_data = get_data(root);
  if (root_data) {
    return lookup_keys(keys.length - 1 | 0, keys, root_data);
  } else {
    return build_path(keys.length - 1 | 0, keys, root);
  }
}

function new_cache(table) {
  var n = new_method(table);
  var n$1 = n % 2 === 0 || n > (2 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0) ? n : new_method(table);
  Caml_array.set(table.methods, n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  var next = function (param) {
    i.contents = i.contents + 1 | 0;
    return Caml_array.get(arr, i.contents);
  };
  var clo = next(undefined);
  if (typeof clo !== "number") {
    return clo;
  }
  switch (clo) {
    case /* GetConst */0 :
        var x = next(undefined);
        return function (_obj) {
          return x;
        };
    case /* GetVar */1 :
        var n = next(undefined);
        return function (obj) {
          return obj[n];
        };
    case /* GetEnv */2 :
        var e = next(undefined);
        var n$1 = next(undefined);
        return function (obj) {
          return obj[e][n$1];
        };
    case /* GetMeth */3 :
        var n$2 = next(undefined);
        return function (obj) {
          return Curry._1(obj[0][n$2], obj);
        };
    case /* SetVar */4 :
        var n$3 = next(undefined);
        return function (obj, x) {
          obj[n$3] = x;
        };
    case /* AppConst */5 :
        var f = next(undefined);
        var x$1 = next(undefined);
        return function (_obj) {
          return Curry._1(f, x$1);
        };
    case /* AppVar */6 :
        var f$1 = next(undefined);
        var n$4 = next(undefined);
        return function (obj) {
          return Curry._1(f$1, obj[n$4]);
        };
    case /* AppEnv */7 :
        var f$2 = next(undefined);
        var e$1 = next(undefined);
        var n$5 = next(undefined);
        return function (obj) {
          return Curry._1(f$2, obj[e$1][n$5]);
        };
    case /* AppMeth */8 :
        var f$3 = next(undefined);
        var n$6 = next(undefined);
        return function (obj) {
          return Curry._1(f$3, Curry._1(obj[0][n$6], obj));
        };
    case /* AppConstConst */9 :
        var f$4 = next(undefined);
        var x$2 = next(undefined);
        var y = next(undefined);
        return function (_obj) {
          return Curry._2(f$4, x$2, y);
        };
    case /* AppConstVar */10 :
        var f$5 = next(undefined);
        var x$3 = next(undefined);
        var n$7 = next(undefined);
        return function (obj) {
          return Curry._2(f$5, x$3, obj[n$7]);
        };
    case /* AppConstEnv */11 :
        var f$6 = next(undefined);
        var x$4 = next(undefined);
        var e$2 = next(undefined);
        var n$8 = next(undefined);
        return function (obj) {
          return Curry._2(f$6, x$4, obj[e$2][n$8]);
        };
    case /* AppConstMeth */12 :
        var f$7 = next(undefined);
        var x$5 = next(undefined);
        var n$9 = next(undefined);
        return function (obj) {
          return Curry._2(f$7, x$5, Curry._1(obj[0][n$9], obj));
        };
    case /* AppVarConst */13 :
        var f$8 = next(undefined);
        var n$10 = next(undefined);
        var x$6 = next(undefined);
        return function (obj) {
          return Curry._2(f$8, obj[n$10], x$6);
        };
    case /* AppEnvConst */14 :
        var f$9 = next(undefined);
        var e$3 = next(undefined);
        var n$11 = next(undefined);
        var x$7 = next(undefined);
        return function (obj) {
          return Curry._2(f$9, obj[e$3][n$11], x$7);
        };
    case /* AppMethConst */15 :
        var f$10 = next(undefined);
        var n$12 = next(undefined);
        var x$8 = next(undefined);
        return function (obj) {
          return Curry._2(f$10, Curry._1(obj[0][n$12], obj), x$8);
        };
    case /* MethAppConst */16 :
        var n$13 = next(undefined);
        var x$9 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$13], obj, x$9);
        };
    case /* MethAppVar */17 :
        var n$14 = next(undefined);
        var m = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$14], obj, obj[m]);
        };
    case /* MethAppEnv */18 :
        var n$15 = next(undefined);
        var e$4 = next(undefined);
        var m$1 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$15], obj, obj[e$4][m$1]);
        };
    case /* MethAppMeth */19 :
        var n$16 = next(undefined);
        var m$2 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$16], obj, Curry._1(obj[0][m$2], obj));
        };
    case /* SendConst */20 :
        var m$3 = next(undefined);
        var x$10 = next(undefined);
        var c = new_cache(table);
        return function (obj) {
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, x$10, m$3, 1), x$10, obj[0], c);
        };
    case /* SendVar */21 :
        var m$4 = next(undefined);
        var n$17 = next(undefined);
        var c$1 = new_cache(table);
        return function (obj) {
          var tmp = obj[n$17];
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$4, 2), tmp, obj[0], c$1);
        };
    case /* SendEnv */22 :
        var m$5 = next(undefined);
        var e$5 = next(undefined);
        var n$18 = next(undefined);
        var c$2 = new_cache(table);
        return function (obj) {
          var tmp = obj[e$5][n$18];
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$5, 3), tmp, obj[0], c$2);
        };
    case /* SendMeth */23 :
        var m$6 = next(undefined);
        var n$19 = next(undefined);
        var c$3 = new_cache(table);
        return function (obj) {
          var tmp = Curry._1(obj[0][n$19], obj);
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$6, 4), tmp, obj[0], c$3);
        };
    
  }
}

function set_methods(table, methods) {
  var len = methods.length;
  var i = {
    contents: 0
  };
  while(i.contents < len) {
    var label = Caml_array.get(methods, i.contents);
    var clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i.contents = i.contents + 1 | 0;
  };
}

function stats(param) {
  return {
          classes: table_count.contents,
          methods: method_count.contents,
          inst_vars: inst_var_count.contents
        };
}

export {
  public_method_label ,
  new_method ,
  new_variable ,
  new_methods_variables ,
  get_variable ,
  get_variables ,
  get_method_label ,
  get_method_labels ,
  get_method ,
  set_method ,
  set_methods ,
  narrow ,
  widen ,
  add_initializer ,
  dummy_table ,
  create_table ,
  init_class ,
  inherits ,
  make_class ,
  make_class_store ,
  copy ,
  create_object ,
  create_object_opt ,
  run_initializers ,
  run_initializers_opt ,
  create_object_and_run_initializers ,
  lookup_tables ,
  params ,
  stats ,
}
/* Vars Not a pure module */
`,Iu=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_hash from "melange.js/caml_hash.js";

function chr(n) {
  if (n < 0 || n > 255) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Char.chr",
          Error: new Error()
        };
  }
  return n;
}

function escaped(c) {
  var exit = 0;
  if (c >= 40) {
    if (c === 92) {
      return "\\\\\\\\";
    }
    exit = c >= 127 ? 1 : 2;
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\\\'";
    }
    exit = 2;
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 :
          return "\\\\b";
      case 9 :
          return "\\\\t";
      case 10 :
          return "\\\\n";
      case 0 :
      case 1 :
      case 2 :
      case 3 :
      case 4 :
      case 5 :
      case 6 :
      case 7 :
      case 11 :
      case 12 :
          exit = 1;
          break;
      case 13 :
          return "\\\\r";
      
    }
  }
  switch (exit) {
    case 1 :
        var s = [
          0,
          0,
          0,
          0
        ];
        s[0] = /* '\\\\' */92;
        s[1] = 48 + (c / 100 | 0) | 0;
        s[2] = 48 + (c / 10 | 0) % 10 | 0;
        s[3] = 48 + c % 10 | 0;
        return Caml_bytes.bytes_to_string(s);
    case 2 :
        var s$1 = [0];
        s$1[0] = c;
        return Caml_bytes.bytes_to_string(s$1);
    
  }
}

function lowercase_ascii(c) {
  if (c > 90 || c < 65) {
    return c;
  } else {
    return c + 32 | 0;
  }
}

function uppercase_ascii(c) {
  if (c > 122 || c < 97) {
    return c;
  } else {
    return c - 32 | 0;
  }
}

function compare(c1, c2) {
  return c1 - c2 | 0;
}

function equal(c1, c2) {
  return (c1 - c2 | 0) === 0;
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

export {
  chr ,
  escaped ,
  lowercase_ascii ,
  uppercase_ascii ,
  compare ,
  equal ,
  seeded_hash ,
  hash ,
}
/* No side effect */
`,Nu=`// Generated by Melange

import * as Caml_float from "melange.js/caml_float.js";

var one = {
  re: 1.0,
  im: 0.0
};

function add(x, y) {
  return {
          re: x.re + y.re,
          im: x.im + y.im
        };
}

function sub(x, y) {
  return {
          re: x.re - y.re,
          im: x.im - y.im
        };
}

function neg(x) {
  return {
          re: - x.re,
          im: - x.im
        };
}

function conj(x) {
  return {
          re: x.re,
          im: - x.im
        };
}

function mul(x, y) {
  return {
          re: x.re * y.re - x.im * y.im,
          im: x.re * y.im + x.im * y.re
        };
}

function div(x, y) {
  if (Math.abs(y.re) >= Math.abs(y.im)) {
    var r = y.im / y.re;
    var d = y.re + r * y.im;
    return {
            re: (x.re + r * x.im) / d,
            im: (x.im - r * x.re) / d
          };
  }
  var r$1 = y.re / y.im;
  var d$1 = y.im + r$1 * y.re;
  return {
          re: (r$1 * x.re + x.im) / d$1,
          im: (r$1 * x.im - x.re) / d$1
        };
}

function inv(x) {
  return div(one, x);
}

function norm2(x) {
  return x.re * x.re + x.im * x.im;
}

function norm(x) {
  return Caml_float.caml_hypot_float(x.re, x.im);
}

function arg(x) {
  return Math.atan2(x.im, x.re);
}

function polar(n, a) {
  return {
          re: Math.cos(a) * n,
          im: Math.sin(a) * n
        };
}

function sqrt(x) {
  if (x.re === 0.0 && x.im === 0.0) {
    return {
            re: 0.0,
            im: 0.0
          };
  }
  var r = Math.abs(x.re);
  var i = Math.abs(x.im);
  var w;
  if (r >= i) {
    var q = i / r;
    w = Math.sqrt(r) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + q * q)));
  } else {
    var q$1 = r / i;
    w = Math.sqrt(i) * Math.sqrt(0.5 * (q$1 + Math.sqrt(1.0 + q$1 * q$1)));
  }
  if (x.re >= 0.0) {
    return {
            re: w,
            im: 0.5 * x.im / w
          };
  } else {
    return {
            re: 0.5 * i / w,
            im: x.im >= 0.0 ? w : - w
          };
  }
}

function exp(x) {
  var e = Math.exp(x.re);
  return {
          re: e * Math.cos(x.im),
          im: e * Math.sin(x.im)
        };
}

function log(x) {
  return {
          re: Math.log(norm(x)),
          im: Math.atan2(x.im, x.re)
        };
}

function pow(x, y) {
  return exp(mul(y, log(x)));
}

var zero = {
  re: 0.0,
  im: 0.0
};

var i = {
  re: 0.0,
  im: 1.0
};

export {
  zero ,
  one ,
  i ,
  neg ,
  conj ,
  add ,
  sub ,
  mul ,
  inv ,
  div ,
  sqrt ,
  norm2 ,
  norm ,
  arg ,
  polar ,
  exp ,
  log ,
  pow ,
}
/* No side effect */
`,Tu=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_md5 from "melange.js/caml_md5.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Char from "./char.js";
import * as Stdlib__String from "./string.js";

function string(str) {
  return Caml_md5.caml_md5_string(str, 0, str.length);
}

function bytes(b) {
  return string(Caml_bytes.bytes_to_string(b));
}

function substring(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.substring",
          Error: new Error()
        };
  }
  return Caml_md5.caml_md5_string(str, ofs, len);
}

function subbytes(b, ofs, len) {
  return substring(Caml_bytes.bytes_to_string(b), ofs, len);
}

function file(filename) {
  var ic = Stdlib.open_in_bin(filename);
  var d;
  try {
    d = Caml_external_polyfill.resolve("caml_md5_chan")(ic, -1);
  }
  catch (e){
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    throw e;
  }
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return d;
}

var output = Stdlib.output_string;

function input(chan) {
  return Stdlib.really_input_string(chan, 16);
}

function char_hex(n) {
  return n + (
          n < 10 ? /* '0' */48 : 87
        ) | 0;
}

function to_hex(d) {
  if (d.length !== 16) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.to_hex",
          Error: new Error()
        };
  }
  var result = Caml_bytes.caml_create_bytes(32);
  for(var i = 0; i <= 15; ++i){
    var x = Caml_string.get(d, i);
    result[(i << 1)] = char_hex((x >>> 4));
    result[(i << 1) + 1 | 0] = char_hex(x & 15);
  }
  return Caml_bytes.bytes_to_string(result);
}

function from_hex(s) {
  if (s.length !== 32) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Digest.from_hex",
          Error: new Error()
        };
  }
  var digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          throw {
                MEL_EXN_ID: Stdlib.Invalid_argument,
                _1: "Digest.from_hex",
                Error: new Error()
              };
        }
        return (c - /* 'a' */97 | 0) + 10 | 0;
      }
      if (c >= 71) {
        throw {
              MEL_EXN_ID: Stdlib.Invalid_argument,
              _1: "Digest.from_hex",
              Error: new Error()
            };
      }
      return (c - /* 'A' */65 | 0) + 10 | 0;
    }
    if (c > 57 || c < 48) {
      throw {
            MEL_EXN_ID: Stdlib.Invalid_argument,
            _1: "Digest.from_hex",
            Error: new Error()
          };
    }
    return c - /* '0' */48 | 0;
  };
  var $$byte = function (i) {
    return (digit(Caml_string.get(s, i)) << 4) + digit(Caml_string.get(s, i + 1 | 0)) | 0;
  };
  var result = Caml_bytes.caml_create_bytes(16);
  for(var i = 0; i <= 15; ++i){
    Caml_bytes.set(result, i, Stdlib__Char.chr($$byte((i << 1))));
  }
  return Caml_bytes.bytes_to_string(result);
}

var compare = Stdlib__String.compare;

var equal = Stdlib__String.equal;

export {
  compare ,
  equal ,
  string ,
  bytes ,
  substring ,
  subbytes ,
  file ,
  output ,
  input ,
  to_hex ,
  from_hex ,
}
/* No side effect */
`,ju=`// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printexc from "./printexc.js";
import * as Stdlib__Queue from "./queue.js";

var atomic_lock = {
  contents: false
};

function atomically(f) {
  atomic_lock.contents = true;
  return Stdlib__Fun.protect((function (param) {
                atomic_lock.contents = false;
              }), f);
}

var first_spawn_queue = {
  length: 0,
  first: /* Nil */0,
  last: /* Nil */0
};

var first_spawn_occurred = {
  contents: false
};

function before_first_spawn(f) {
  atomically(function (param) {
        if (first_spawn_occurred.contents) {
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Domain.before_first_spawn",
                Error: new Error()
              };
        }
        Stdlib__Queue.push(f, first_spawn_queue);
      });
}

function maybe_first_spawn(param) {
  atomically(function (param) {
        if (first_spawn_occurred.contents) {
          return ;
        }
        first_spawn_occurred.contents = true;
        while(first_spawn_queue.length !== 0) {
          var f = Stdlib__Queue.take(first_spawn_queue);
          Curry._1(f, undefined);
        };
      });
}

var at_exit_table = {
  contents: /* [] */0
};

function at_exit(f) {
  atomically(function (param) {
        at_exit_table.contents = {
          hd: f,
          tl: at_exit_table.contents
        };
      });
}

function get_id(t) {
  return t.id;
}

function self(param) {
  return 0;
}

function cpu_relax(param) {
  
}

function is_main_domain(param) {
  return true;
}

function recommended_domain_count(param) {
  return 1;
}

var all_keys = {
  contents: /* [] */0
};

function new_key(split_from_parent, init) {
  var key = {
    table: undefined,
    split_from_parent: split_from_parent,
    init: init
  };
  atomically(function (param) {
        all_keys.contents = {
          hd: /* Key */{
            _0: key
          },
          tl: all_keys.contents
        };
      });
  return key;
}

function get(key) {
  var v = key.table;
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  var v$1 = Curry._1(key.init, undefined);
  atomically(function (param) {
        key.table = Caml_option.some(v$1);
      });
  return v$1;
}

function set(key, v) {
  atomically(function (param) {
        key.table = Caml_option.some(v);
      });
}

function prepare_split_keys_before_spawn(param) {
  return Stdlib__List.filter_map((function (param) {
                var key = param._0;
                var split = key.split_from_parent;
                if (split === undefined) {
                  return ;
                }
                var current = get(key);
                var child = Curry._1(split, current);
                return /* Key_value */{
                        _0: key,
                        _1: child
                      };
              }), all_keys.contents);
}

function perform_split_after_spawn(split_keys) {
  var perform_split = function (param) {
    set(param._0, param._1);
  };
  Stdlib__List.iter(perform_split, split_keys);
}

var next_id = {
  contents: 0
};

function spawn(f) {
  maybe_first_spawn(undefined);
  var status = {
    contents: /* Running */0
  };
  var split_keys = prepare_split_keys_before_spawn(undefined);
  var handle = new Promise((function (resolve, reject) {
          var param = [
            split_keys,
            status
          ];
          var status$1 = param[1];
          perform_split_after_spawn(param[0]);
          var exit = 0;
          var v;
          try {
            v = Curry._1(f, undefined);
            exit = 1;
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            var bt;
            status$1.contents = {
              TAG: /* Error */1,
              _0: exn,
              _1: bt
            };
            reject(exn);
          }
          if (exit === 1) {
            status$1.contents = {
              TAG: /* Return */0,
              _0: v
            };
            resolve(v);
          }
          var at_exit_callbacks = atomically(function (param) {
                return at_exit_table.contents;
              });
          try {
            Stdlib__List.iter((function (f) {
                    Curry._1(f, undefined);
                  }), at_exit_callbacks);
            return ;
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            var match = status$1.contents;
            if (typeof match === "number") {
              throw {
                    MEL_EXN_ID: "Assert_failure",
                    _1: [
                      "jscomp/stdlib/domain.ml",
                      77,
                      19
                    ],
                    Error: new Error()
                  };
            }
            if (match.TAG !== /* Return */0) {
              return ;
            }
            var bt$1;
            status$1.contents = {
              TAG: /* Error */1,
              _0: exn$1,
              _1: bt$1
            };
            return ;
          }
        }));
  return {
          id: (next_id.contents = next_id.contents + 1 | 0, next_id.contents),
          handle: handle,
          status: status
        };
}

function join(t) {
  return t.handle.then(function (param) {
                var v = t.status.contents;
                if (typeof v === "number") {
                  throw {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/stdlib/domain.ml",
                          179,
                          17
                        ],
                        Error: new Error()
                      };
                }
                if (v.TAG === /* Return */0) {
                  return Promise.resolve(v._0);
                }
                throw v._0;
              }).catch(function (param) {
              var match = t.status.contents;
              if (typeof match === "number") {
                throw {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/stdlib/domain.ml",
                        186,
                        30
                      ],
                      Error: new Error()
                    };
              }
              if (match.TAG === /* Return */0) {
                throw {
                      MEL_EXN_ID: "Assert_failure",
                      _1: [
                        "jscomp/stdlib/domain.ml",
                        186,
                        30
                      ],
                      Error: new Error()
                    };
              }
              throw match._0;
            });
}

var DLS = {
  new_key: new_key,
  get: get,
  set: set
};

export {
  spawn ,
  join ,
  get_id ,
  self ,
  before_first_spawn ,
  at_exit ,
  cpu_relax ,
  is_main_domain ,
  recommended_domain_count ,
  DLS ,
}
/* Stdlib__Fun Not a pure module */
`,Lu=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";

function left(v) {
  return {
          TAG: /* Left */0,
          _0: v
        };
}

function right(v) {
  return {
          TAG: /* Right */1,
          _0: v
        };
}

function is_left(param) {
  if (param.TAG === /* Left */0) {
    return true;
  } else {
    return false;
  }
}

function is_right(param) {
  if (param.TAG === /* Left */0) {
    return false;
  } else {
    return true;
  }
}

function find_left(param) {
  if (param.TAG === /* Left */0) {
    return Caml_option.some(param._0);
  }
  
}

function find_right(param) {
  if (param.TAG === /* Left */0) {
    return ;
  } else {
    return Caml_option.some(param._0);
  }
}

function map_left(f, e) {
  if (e.TAG === /* Left */0) {
    return {
            TAG: /* Left */0,
            _0: Curry._1(f, e._0)
          };
  } else {
    return e;
  }
}

function map_right(f, e) {
  if (e.TAG === /* Left */0) {
    return e;
  } else {
    return {
            TAG: /* Right */1,
            _0: Curry._1(f, e._0)
          };
  }
}

function map(left, right, param) {
  if (param.TAG === /* Left */0) {
    return {
            TAG: /* Left */0,
            _0: Curry._1(left, param._0)
          };
  } else {
    return {
            TAG: /* Right */1,
            _0: Curry._1(right, param._0)
          };
  }
}

function fold(left, right, param) {
  if (param.TAG === /* Left */0) {
    return Curry._1(left, param._0);
  } else {
    return Curry._1(right, param._0);
  }
}

function equal(left, right, e1, e2) {
  if (e1.TAG === /* Left */0) {
    if (e2.TAG === /* Left */0) {
      return Curry._2(left, e1._0, e2._0);
    } else {
      return false;
    }
  } else if (e2.TAG === /* Left */0) {
    return false;
  } else {
    return Curry._2(right, e1._0, e2._0);
  }
}

function compare(left, right, e1, e2) {
  if (e1.TAG === /* Left */0) {
    if (e2.TAG === /* Left */0) {
      return Curry._2(left, e1._0, e2._0);
    } else {
      return -1;
    }
  } else if (e2.TAG === /* Left */0) {
    return 1;
  } else {
    return Curry._2(right, e1._0, e2._0);
  }
}

var iter = fold;

var for_all = fold;

export {
  left ,
  right ,
  is_left ,
  is_right ,
  find_left ,
  find_right ,
  map_left ,
  map_right ,
  map ,
  fold ,
  iter ,
  for_all ,
  equal ,
  compare ,
}
/* No side effect */
`,Mu=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Hashtbl from "./hashtbl.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make(key, data) {
  var eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var seeded_hash = H.seeded_hash;
  var equal = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = Curry._2(seeded_hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make(H) {
  var equal = H.equal;
  var seeded_hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var equal$1 = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$1(param) {
  return {
          contents: /* [] */0
        };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  var x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_key(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */0;
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$2(key1, key2, data) {
  var eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return ;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return ;
  }
  var k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var seeded_hash = function (seed, param) {
    return Curry._2(H1.seeded_hash, seed, param[0]) + Math.imul(Curry._2(H2.seeded_hash, seed, param[1]), 65599) | 0;
  };
  var equal = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$1(H1, H2) {
  var equal = H2.equal;
  var equal$1 = H1.equal;
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var seeded_hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  var equal$2 = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$2(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$2(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$3(param) {
  return {
          contents: /* [] */0
        };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  var match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  var match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$1(b, k1, k2) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys(k1, k2, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */0;
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$4(keys, data) {
  var l = keys.length;
  var eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for(var i = 0; i < l; ++i){
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  var l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw {
            MEL_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0; i < l; ++i){
      var k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw {
                MEL_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              MEL_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return ;
    }
    throw exn;
  }
}

function MakeSeeded$2(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var seeded_hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._2(H.seeded_hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(var i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$2(H) {
  var equal = H.equal;
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var seeded_hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal$1 = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = seeded_hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(var i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = seeded_hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$5(param) {
  return {
          contents: /* [] */0
        };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw {
            MEL_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      var x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw {
                MEL_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              MEL_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw exn;
  }
}

function remove$2(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$2(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys$1(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */0;
}

var K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

var K1 = {
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

var K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

var K2 = {
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

var Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

var Kn = {
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

export {
  K1 ,
  K2 ,
  Kn ,
}
/* Stdlib__Hashtbl Not a pure module */
`,Du=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__String from "./string.js";
import * as Stdlib__Sys from "./sys.js";

function generic_quote(quotequote, s) {
  var l = s.length;
  var b = Stdlib__Buffer.create(l + 20 | 0);
  Stdlib__Buffer.add_char(b, /* '\\'' */39);
  for(var i = 0; i < l; ++i){
    if (Caml_string.get(s, i) === /* '\\'' */39) {
      Stdlib__Buffer.add_string(b, quotequote);
    } else {
      Stdlib__Buffer.add_char(b, Caml_string.get(s, i));
    }
  }
  Stdlib__Buffer.add_char(b, /* '\\'' */39);
  return Stdlib__Buffer.contents(b);
}

function generic_basename(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return Stdlib__String.sub(name, 0, 1);
      }
      if (!Curry._2(is_dir_sep, name, n)) {
        var _n$1 = n;
        var p = n + 1 | 0;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return Stdlib__String.sub(name, 0, p);
          }
          if (Curry._2(is_dir_sep, name, n$1)) {
            return Stdlib__String.sub(name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
          }
          _n$1 = n$1 - 1 | 0;
          continue ;
        };
      }
      _n = n - 1 | 0;
      continue ;
    };
  }
}

function generic_dirname(is_dir_sep, current_dir_name, name) {
  if (name === "") {
    return current_dir_name;
  } else {
    var _n = name.length - 1 | 0;
    while(true) {
      var n = _n;
      if (n < 0) {
        return Stdlib__String.sub(name, 0, 1);
      }
      if (!Curry._2(is_dir_sep, name, n)) {
        var _n$1 = n;
        while(true) {
          var n$1 = _n$1;
          if (n$1 < 0) {
            return current_dir_name;
          }
          if (Curry._2(is_dir_sep, name, n$1)) {
            var _n$2 = n$1;
            while(true) {
              var n$2 = _n$2;
              if (n$2 < 0) {
                return Stdlib__String.sub(name, 0, 1);
              }
              if (!Curry._2(is_dir_sep, name, n$2)) {
                return Stdlib__String.sub(name, 0, n$2 + 1 | 0);
              }
              _n$2 = n$2 - 1 | 0;
              continue ;
            };
          }
          _n$1 = n$1 - 1 | 0;
          continue ;
        };
      }
      _n = n - 1 | 0;
      continue ;
    };
  }
}

var current_dir_name = ".";

function is_dir_sep(s, i) {
  return Caml_string.get(s, i) === /* '/' */47;
}

function is_relative(n) {
  if (n.length < 1) {
    return true;
  } else {
    return Caml_string.get(n, 0) !== /* '/' */47;
  }
}

function is_implicit(n) {
  if (is_relative(n) && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== "./")) {
    if (n.length < 3) {
      return true;
    } else {
      return Stdlib__String.sub(n, 0, 3) !== "../";
    }
  } else {
    return false;
  }
}

function check_suffix(name, suff) {
  return Stdlib__String.ends_with(suff, name);
}

function chop_suffix_opt(suffix, filename) {
  var len_s = suffix.length;
  var len_f = filename.length;
  if (len_f < len_s) {
    return ;
  }
  var r = Stdlib__String.sub(filename, len_f - len_s | 0, len_s);
  if (r === suffix) {
    return Stdlib__String.sub(filename, 0, len_f - len_s | 0);
  }
  
}

var temp_dir_name;

try {
  temp_dir_name = Caml_sys.caml_sys_getenv("TMPDIR");
}
catch (raw_exn){
  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
  if (exn.MEL_EXN_ID === Stdlib.Not_found) {
    temp_dir_name = "/tmp";
  } else {
    throw exn;
  }
}

function quote(param) {
  return generic_quote("'\\\\''", param);
}

function quote_command(cmd, stdin, stdout, stderr, args) {
  return Stdlib__String.concat(" ", Stdlib__List.map(quote, {
                  hd: cmd,
                  tl: args
                })) + ((
            stdin !== undefined ? " <" + generic_quote("'\\\\''", stdin) : ""
          ) + ((
              stdout !== undefined ? " >" + generic_quote("'\\\\''", stdout) : ""
            ) + (
              stderr !== undefined ? (
                  Caml_obj.caml_equal(stderr, stdout) ? " 2>&1" : " 2>" + generic_quote("'\\\\''", stderr)
                ) : ""
            )));
}

function basename(param) {
  return generic_basename(is_dir_sep, current_dir_name, param);
}

function dirname(param) {
  return generic_dirname(is_dir_sep, current_dir_name, param);
}

var Unix = {
  $$null: "/dev/null",
  current_dir_name: current_dir_name,
  parent_dir_name: "..",
  dir_sep: "/",
  is_dir_sep: is_dir_sep,
  is_relative: is_relative,
  is_implicit: is_implicit,
  check_suffix: check_suffix,
  chop_suffix_opt: chop_suffix_opt,
  temp_dir_name: temp_dir_name,
  quote: quote,
  quote_command: quote_command,
  basename: basename,
  dirname: dirname
};

var current_dir_name$1 = ".";

function is_dir_sep$1(s, i) {
  var c = Caml_string.get(s, i);
  if (c === /* '/' */47 || c === /* '\\\\' */92) {
    return true;
  } else {
    return c === /* ':' */58;
  }
}

function is_relative$1(n) {
  if ((n.length < 1 || Caml_string.get(n, 0) !== /* '/' */47) && (n.length < 1 || Caml_string.get(n, 0) !== /* '\\\\' */92)) {
    if (n.length < 2) {
      return true;
    } else {
      return Caml_string.get(n, 1) !== /* ':' */58;
    }
  } else {
    return false;
  }
}

function is_implicit$1(n) {
  if (is_relative$1(n) && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== "./") && (n.length < 2 || Stdlib__String.sub(n, 0, 2) !== ".\\\\") && (n.length < 3 || Stdlib__String.sub(n, 0, 3) !== "../")) {
    if (n.length < 3) {
      return true;
    } else {
      return Stdlib__String.sub(n, 0, 3) !== "..\\\\";
    }
  } else {
    return false;
  }
}

function check_suffix$1(name, suff) {
  if (name.length < suff.length) {
    return false;
  }
  var s = Stdlib__String.sub(name, name.length - suff.length | 0, suff.length);
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s))) === Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(suff)));
}

function chop_suffix_opt$1(suffix, filename) {
  var len_s = suffix.length;
  var len_f = filename.length;
  if (len_f < len_s) {
    return ;
  }
  var r = Stdlib__String.sub(filename, len_f - len_s | 0, len_s);
  if (Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(r))) === Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(suffix)))) {
    return Stdlib__String.sub(filename, 0, len_f - len_s | 0);
  }
  
}

var temp_dir_name$1;

try {
  temp_dir_name$1 = Caml_sys.caml_sys_getenv("TEMP");
}
catch (raw_exn$1){
  var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
  if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
    temp_dir_name$1 = ".";
  } else {
    throw exn$1;
  }
}

function quote$1(s) {
  var l = s.length;
  var b = Stdlib__Buffer.create(l + 20 | 0);
  Stdlib__Buffer.add_char(b, /* '"' */34);
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i === l) {
        return Stdlib__Buffer.add_char(b, /* '"' */34);
      }
      var c = Caml_string.get(s, i);
      if (c === 34) {
        return loop_bs(0, i);
      }
      if (c === 92) {
        return loop_bs(0, i);
      }
      Stdlib__Buffer.add_char(b, c);
      _i = i + 1 | 0;
      continue ;
    };
  };
  var loop_bs = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i === l) {
        Stdlib__Buffer.add_char(b, /* '"' */34);
        return add_bs(n);
      }
      var match = Caml_string.get(s, i);
      if (match !== 34) {
        if (match !== 92) {
          add_bs(n);
          return loop(i);
        }
        _i = i + 1 | 0;
        _n = n + 1 | 0;
        continue ;
      }
      add_bs((n << 1) + 1 | 0);
      Stdlib__Buffer.add_char(b, /* '"' */34);
      return loop(i + 1 | 0);
    };
  };
  var add_bs = function (n) {
    for(var _j = 1; _j <= n; ++_j){
      Stdlib__Buffer.add_char(b, /* '\\\\' */92);
    }
  };
  loop(0);
  return Stdlib__Buffer.contents(b);
}

function quote_cmd(s) {
  var b = Stdlib__Buffer.create(s.length + 20 | 0);
  Stdlib__String.iter((function (c) {
          if (c >= 62) {
            if (c > 123 || c < 63) {
              if (c >= 125) {
                return Stdlib__Buffer.add_char(b, c);
              }
              
            } else if (c !== 94) {
              return Stdlib__Buffer.add_char(b, c);
            }
            
          } else if (c >= 42) {
            if (c !== 60) {
              return Stdlib__Buffer.add_char(b, c);
            }
            
          } else {
            if (c < 33) {
              return Stdlib__Buffer.add_char(b, c);
            }
            switch (c) {
              case 35 :
              case 36 :
              case 39 :
                  return Stdlib__Buffer.add_char(b, c);
              case 33 :
              case 34 :
              case 37 :
              case 38 :
              case 40 :
              case 41 :
                  break;
              
            }
          }
          Stdlib__Buffer.add_char(b, /* '^' */94);
          Stdlib__Buffer.add_char(b, c);
        }), s);
  return Stdlib__Buffer.contents(b);
}

function quote_cmd_filename(f) {
  if (!Stdlib__Bytes.exists((function (param) {
            if (param !== 34) {
              return param === 37;
            } else {
              return true;
            }
          }), Caml_bytes.bytes_of_string(f))) {
    if (Stdlib__String.contains(f, /* ' ' */32)) {
      return Stdlib__String.concat("", {
                  hd: "\\"",
                  tl: {
                    hd: f,
                    tl: {
                      hd: "\\"",
                      tl: /* [] */0
                    }
                  }
                });
    } else {
      return f;
    }
  }
  var s = "Filename.quote_command: bad file name " + f;
  throw {
        MEL_EXN_ID: "Failure",
        _1: s,
        Error: new Error()
      };
}

function quote_command$1(cmd, stdin, stdout, stderr, args) {
  return Stdlib__String.concat("", {
              hd: "\\"",
              tl: {
                hd: quote_cmd_filename(cmd),
                tl: {
                  hd: " ",
                  tl: {
                    hd: quote_cmd(Stdlib__String.concat(" ", Stdlib__List.map(quote$1, args))),
                    tl: {
                      hd: stdin !== undefined ? " <" + quote_cmd_filename(stdin) : "",
                      tl: {
                        hd: stdout !== undefined ? " >" + quote_cmd_filename(stdout) : "",
                        tl: {
                          hd: stderr !== undefined ? (
                              Caml_obj.caml_equal(stderr, stdout) ? " 2>&1" : " 2>" + quote_cmd_filename(stderr)
                            ) : "",
                          tl: {
                            hd: "\\"",
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                }
              }
            });
}

function has_drive(s) {
  var is_letter = function (param) {
    if (param >= 91) {
      return !(param > 122 || param < 97);
    } else {
      return param >= 65;
    }
  };
  if (s.length >= 2 && is_letter(Caml_string.get(s, 0))) {
    return Caml_string.get(s, 1) === /* ':' */58;
  } else {
    return false;
  }
}

function drive_and_path(s) {
  if (has_drive(s)) {
    return [
            Stdlib__String.sub(s, 0, 2),
            Stdlib__String.sub(s, 2, s.length - 2 | 0)
          ];
  } else {
    return [
            "",
            s
          ];
  }
}

function dirname$1(s) {
  var match = drive_and_path(s);
  var dir = generic_dirname(is_dir_sep$1, current_dir_name$1, match[1]);
  return match[0] + dir;
}

function basename$1(s) {
  var match = drive_and_path(s);
  return generic_basename(is_dir_sep$1, current_dir_name$1, match[1]);
}

var Win32 = {
  $$null: "NUL",
  current_dir_name: current_dir_name$1,
  parent_dir_name: "..",
  dir_sep: "\\\\",
  is_dir_sep: is_dir_sep$1,
  is_relative: is_relative$1,
  is_implicit: is_implicit$1,
  check_suffix: check_suffix$1,
  chop_suffix_opt: chop_suffix_opt$1,
  temp_dir_name: temp_dir_name$1,
  quote: quote$1,
  quote_command: quote_command$1,
  basename: basename$1,
  dirname: dirname$1
};

var current_dir_name$2 = ".";

function basename$2(param) {
  return generic_basename(is_dir_sep$1, current_dir_name$2, param);
}

function dirname$2(param) {
  return generic_dirname(is_dir_sep$1, current_dir_name$2, param);
}

var Cygwin = {
  $$null: "/dev/null",
  current_dir_name: current_dir_name$2,
  parent_dir_name: "..",
  dir_sep: "/",
  is_dir_sep: is_dir_sep$1,
  is_relative: is_relative$1,
  is_implicit: is_implicit$1,
  check_suffix: check_suffix$1,
  chop_suffix_opt: chop_suffix_opt$1,
  temp_dir_name: temp_dir_name,
  quote: quote,
  quote_command: quote_command,
  basename: basename$2,
  dirname: dirname$2
};

var Sysdeps;

switch (Stdlib__Sys.os_type) {
  case "Cygwin" :
      Sysdeps = Cygwin;
      break;
  case "Win32" :
      Sysdeps = Win32;
      break;
  default:
    Sysdeps = Unix;
}

var dir_sep = Sysdeps.dir_sep;

var is_dir_sep$2 = Sysdeps.is_dir_sep;

var check_suffix$2 = Sysdeps.check_suffix;

var temp_dir_name$2 = Sysdeps.temp_dir_name;

function concat(dirname, filename) {
  var l = dirname.length;
  if (l === 0 || Curry._2(is_dir_sep$2, dirname, l - 1 | 0)) {
    return dirname + filename;
  } else {
    return dirname + (dir_sep + filename);
  }
}

function chop_suffix(name, suff) {
  if (Curry._2(check_suffix$2, name, suff)) {
    return Stdlib__String.sub(name, 0, name.length - suff.length | 0);
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Filename.chop_suffix",
        Error: new Error()
      };
}

function extension_len(name) {
  var _i = name.length - 1 | 0;
  while(true) {
    var i = _i;
    if (i < 0 || Curry._2(is_dir_sep$2, name, i)) {
      return 0;
    }
    if (Caml_string.get(name, i) === /* '.' */46) {
      var _i$1 = i - 1 | 0;
      while(true) {
        var i$1 = _i$1;
        if (i$1 < 0 || Curry._2(is_dir_sep$2, name, i$1)) {
          return 0;
        }
        if (Caml_string.get(name, i$1) !== /* '.' */46) {
          return name.length - i | 0;
        }
        _i$1 = i$1 - 1 | 0;
        continue ;
      };
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return "";
  } else {
    return Stdlib__String.sub(name, name.length - l | 0, l);
  }
}

function chop_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Filename.chop_extension",
          Error: new Error()
        };
  }
  return Stdlib__String.sub(name, 0, name.length - l | 0);
}

function remove_extension(name) {
  var l = extension_len(name);
  if (l === 0) {
    return name;
  } else {
    return Stdlib__String.sub(name, 0, name.length - l | 0);
  }
}

var prng_key = Stdlib__Domain.DLS.new_key(undefined, Stdlib__Random.State.make_self_init);

function temp_file_name(temp_dir, prefix, suffix) {
  var random_state = Stdlib__Domain.DLS.get(prng_key);
  var rnd = Stdlib__Random.State.bits(random_state) & 16777215;
  return concat(temp_dir, Curry._3(Stdlib__Printf.sprintf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_x */6,
                          _1: {
                            TAG: /* Lit_padding */0,
                            _0: /* Zeros */2,
                            _1: 6
                          },
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "%s%06x%s"
                    }), prefix, rnd, suffix));
}

var current_temp_dir_name = Stdlib__Domain.DLS.new_key((function (prim) {
        return prim;
      }), (function (param) {
        return temp_dir_name$2;
      }));

function set_temp_dir_name(s) {
  Stdlib__Domain.DLS.set(current_temp_dir_name, s);
}

function get_temp_dir_name(param) {
  return Stdlib__Domain.DLS.get(current_temp_dir_name);
}

function temp_file(temp_dirOpt, prefix, suffix) {
  var temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      Caml_external_polyfill.resolve("caml_sys_close")(Caml_external_polyfill.resolve("caml_sys_open")(name, {
                hd: /* Open_wronly */1,
                tl: {
                  hd: /* Open_creat */3,
                  tl: {
                    hd: /* Open_excl */5,
                    tl: /* [] */0
                  }
                }
              }, 384));
      return name;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      }
      throw e;
    }
  };
}

function open_temp_file(modeOpt, permsOpt, temp_dirOpt, prefix, suffix) {
  var mode = modeOpt !== undefined ? modeOpt : ({
        hd: /* Open_text */7,
        tl: /* [] */0
      });
  var perms = permsOpt !== undefined ? permsOpt : 384;
  var temp_dir = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir, prefix, suffix);
    try {
      return [
              name,
              Stdlib.open_out_gen({
                    hd: /* Open_wronly */1,
                    tl: {
                      hd: /* Open_creat */3,
                      tl: {
                        hd: /* Open_excl */5,
                        tl: mode
                      }
                    }
                  }, perms, name)
            ];
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      }
      throw e;
    }
  };
}

function temp_dir(temp_dirOpt, permsOpt, prefix, suffix) {
  var temp_dir$1 = temp_dirOpt !== undefined ? temp_dirOpt : Stdlib__Domain.DLS.get(current_temp_dir_name);
  var perms = permsOpt !== undefined ? permsOpt : 448;
  var _counter = 0;
  while(true) {
    var counter = _counter;
    var name = temp_file_name(temp_dir$1, prefix, suffix);
    try {
      Caml_external_polyfill.resolve("caml_sys_mkdir")(name, perms);
      return name;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.MEL_EXN_ID === Stdlib.Sys_error) {
        if (counter >= 20) {
          throw e;
        }
        _counter = counter + 1 | 0;
        continue ;
      }
      throw e;
    }
  };
}

var current_dir_name$3 = Sysdeps.current_dir_name;

var parent_dir_name = Sysdeps.parent_dir_name;

var is_relative$2 = Sysdeps.is_relative;

var is_implicit$2 = Sysdeps.is_implicit;

var chop_suffix_opt$2 = Sysdeps.chop_suffix_opt;

var basename$3 = Sysdeps.basename;

var dirname$3 = Sysdeps.dirname;

var $$null = Sysdeps.$$null;

var quote$2 = Sysdeps.quote;

var quote_command$2 = Sysdeps.quote_command;

export {
  current_dir_name$3 as current_dir_name,
  parent_dir_name ,
  dir_sep ,
  concat ,
  is_relative$2 as is_relative,
  is_implicit$2 as is_implicit,
  check_suffix$2 as check_suffix,
  chop_suffix ,
  chop_suffix_opt$2 as chop_suffix_opt,
  extension ,
  remove_extension ,
  chop_extension ,
  basename$3 as basename,
  dirname$3 as dirname,
  $$null ,
  temp_file ,
  open_temp_file ,
  temp_dir ,
  get_temp_dir_name ,
  set_temp_dir_name ,
  quote$2 as quote,
  quote_command$2 as quote_command,
}
/* temp_dir_name Not a pure module */
`,Pu=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

var nan = Number.NaN;

var signaling_nan = Caml_int64.float_of_bits([
      2146435072,
      1
    ]);

function is_finite(x) {
  return x - x === 0;
}

function is_infinite(x) {
  return 1 / x === 0;
}

function is_nan(x) {
  return x !== x;
}

function is_integer(x) {
  if (x === Caml_external_polyfill.resolve("caml_trunc_float")(x)) {
    return is_finite(x);
  } else {
    return false;
  }
}

function succ(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.infinity);
}

function pred(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.neg_infinity);
}

function equal(x, y) {
  return Caml.caml_float_compare(x, y) === 0;
}

function min(x, y) {
  if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    if (y !== y) {
      return y;
    } else {
      return x;
    }
  } else if (x !== x) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    if (x !== x) {
      return x;
    } else {
      return y;
    }
  } else if (y !== y) {
    return y;
  } else {
    return x;
  }
}

function min_max(x, y) {
  if (x !== x || y !== y) {
    return [
            nan,
            nan
          ];
  } else if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    return [
            x,
            y
          ];
  } else {
    return [
            y,
            x
          ];
  }
}

function min_num(x, y) {
  if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    if (x !== x) {
      return y;
    } else {
      return x;
    }
  } else if (y !== y) {
    return x;
  } else {
    return y;
  }
}

function max_num(x, y) {
  if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    if (y !== y) {
      return x;
    } else {
      return y;
    }
  } else if (x !== x) {
    return y;
  } else {
    return x;
  }
}

function min_max_num(x, y) {
  if (x !== x) {
    return [
            y,
            y
          ];
  } else if (y !== y) {
    return [
            x,
            x
          ];
  } else if (y > x || !Caml_external_polyfill.resolve("caml_signbit_float")(y) && Caml_external_polyfill.resolve("caml_signbit_float")(x)) {
    return [
            x,
            y
          ];
  } else {
    return [
            y,
            x
          ];
  }
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function unsafe_fill(a, ofs, len, v) {
  for(var i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    a[i] = v;
  }
}

function check(a, ofs, len, msg) {
  if (!(ofs < 0 || len < 0 || (ofs + len | 0) < 0 || (ofs + len | 0) > a.length)) {
    return ;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg,
        Error: new Error()
      };
}

function make(n, v) {
  var result = Caml_array.make_float(n);
  unsafe_fill(result, 0, n, v);
  return result;
}

function init(l, f) {
  if (l < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.init",
          Error: new Error()
        };
  }
  var res = Caml_array.make_float(l);
  for(var i = 0; i < l; ++i){
    res[i] = Curry._1(f, i);
  }
  return res;
}

function append(a1, a2) {
  var l1 = a1.length;
  var l2 = a2.length;
  var result = Caml_array.make_float(l1 + l2 | 0);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a1, 0, result, 0, l1);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a2, 0, result, l1, l2);
  return result;
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Float.Array.concat",
        Error: new Error()
      };
}

function sum_lengths(_acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    _param = param.tl;
    _acc = ensure_ge(param.hd.length + acc | 0, acc);
    continue ;
  };
}

function concat(l) {
  var len = sum_lengths(0, l);
  var result = Caml_array.make_float(len);
  var loop = function (_l, _i) {
    while(true) {
      var i = _i;
      var l = _l;
      if (l) {
        var hd = l.hd;
        var hlen = hd.length;
        Caml_external_polyfill.resolve("caml_floatarray_blit")(hd, 0, result, i, hlen);
        _i = i + hlen | 0;
        _l = l.tl;
        continue ;
      }
      if (i === len) {
        return ;
      }
      throw {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "float.cppo.ml",
              278,
              14
            ],
            Error: new Error()
          };
    };
  };
  loop(l, 0);
  return result;
}

function sub(a, ofs, len) {
  check(a, ofs, len, "Float.Array.sub");
  var result = Caml_array.make_float(len);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, ofs, result, 0, len);
  return result;
}

function copy(a) {
  var l = a.length;
  var result = Caml_array.make_float(l);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, 0, result, 0, l);
  return result;
}

function fill(a, ofs, len, v) {
  check(a, ofs, len, "Float.Array.fill");
  unsafe_fill(a, ofs, len, v);
}

function blit(src, sofs, dst, dofs, len) {
  check(src, sofs, len, "Float.array.blit");
  check(dst, dofs, len, "Float.array.blit");
  Caml_external_polyfill.resolve("caml_floatarray_blit")(src, sofs, dst, dofs, len);
}

function to_list(a) {
  return Stdlib__List.init(a.length, (function (param) {
                return a[param];
              }));
}

function of_list(l) {
  var result = Caml_array.make_float(Stdlib__List.length(l));
  var _i = 0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var i = _i;
    if (!l$1) {
      return result;
    }
    result[i] = l$1.hd;
    _l = l$1.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.iter2: arrays must have the same length",
          Error: new Error()
        };
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  var l = a.length;
  var r = Caml_array.make_float(l);
  for(var i = 0; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_inplace(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._1(f, a[i]);
  }
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Float.Array.map2: arrays must have the same length",
          Error: new Error()
        };
  }
  var r = Caml_array.make_float(la);
  for(var i = 0; i < la; ++i){
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  var l = a.length;
  var r = Caml_array.make_float(l);
  for(var i = 0; i < l; ++i){
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function mapi_inplace(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._2(f, i, a[i]);
  }
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Caml.caml_float_compare(a[i], x) === 0) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem_ieee(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_opt(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var x = a[i];
    if (Curry._1(p, x)) {
      return x;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_index(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_map(f, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_mapi(f, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return ;
    }
    var r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

var Bottom = /* @__PURE__ */Caml_exceptions.create("Stdlib.Float.Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          MEL_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return Caml_array.set(a, exn._1, e);
      }
      throw exn;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return exn._1;
      }
      throw exn;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "float.cppo.ml",
                508,
                6
              ],
              Error: new Error()
            };
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Caml_array.get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Caml_array.get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Caml_array.set(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = Caml_array.get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = Caml_array.make_float(l2);
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

function to_seq(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = a[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = a[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  var l = Stdlib__Seq.fold_left((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, i);
  var len = Stdlib__List.length(l);
  var a = Caml_array.make_float(len);
  var _i = len - 1 | 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue ;
  };
}

function map_to_array(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = Caml_array.make(l, Curry._1(f, a[0]));
  for(var i = 1; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_from_array(f, a) {
  var l = a.length;
  var r = Caml_array.make_float(l);
  for(var i = 0; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

var zero = 0;

var one = 1;

var minus_one = -1;

var infinity = Stdlib.infinity;

var neg_infinity = Stdlib.neg_infinity;

var quiet_nan = nan;

var pi = 3.14159265358979312;

var max_float = Stdlib.max_float;

var min_float = Stdlib.min_float;

var epsilon = Stdlib.epsilon_float;

var of_string_opt = Stdlib.float_of_string_opt;

var to_string = Stdlib.string_of_float;

var compare = Caml.caml_float_compare;

function Array_length(prim) {
  return prim.length;
}

var Array_get = Caml_array.get;

var Array_set = Caml_array.set;

var Array_create = Caml_array.make_float;

var $$Array = {
  length: Array_length,
  get: Array_get,
  set: Array_set,
  make: make,
  create: Array_create,
  init: init,
  append: append,
  concat: concat,
  sub: sub,
  copy: copy,
  fill: fill,
  blit: blit,
  to_list: to_list,
  of_list: of_list,
  iter: iter,
  iteri: iteri,
  map: map,
  map_inplace: map_inplace,
  mapi: mapi,
  mapi_inplace: mapi_inplace,
  fold_left: fold_left,
  fold_right: fold_right,
  iter2: iter2,
  map2: map2,
  for_all: for_all,
  exists: exists,
  mem: mem,
  mem_ieee: mem_ieee,
  find_opt: find_opt,
  find_index: find_index,
  find_map: find_map,
  find_mapi: find_mapi,
  sort: sort,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  to_seq: to_seq,
  to_seqi: to_seqi,
  of_seq: of_seq,
  map_to_array: map_to_array,
  map_from_array: map_from_array
};

export {
  zero ,
  one ,
  minus_one ,
  succ ,
  pred ,
  infinity ,
  neg_infinity ,
  nan ,
  signaling_nan ,
  quiet_nan ,
  pi ,
  max_float ,
  min_float ,
  epsilon ,
  is_finite ,
  is_infinite ,
  is_nan ,
  is_integer ,
  of_string_opt ,
  to_string ,
  compare ,
  equal ,
  min ,
  max ,
  min_max ,
  min_num ,
  max_num ,
  min_max_num ,
  seeded_hash ,
  hash ,
  $$Array ,
}
/* nan Not a pure module */
`,Ou=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Queue from "./queue.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Stack from "./stack.js";
import * as Stdlib__String from "./string.js";

function id(x) {
  return x;
}

var String_tag = /* @__PURE__ */Caml_exceptions.create("Stdlib.Format.String_tag");

function pp_enqueue(state, token) {
  state.pp_right_total = state.pp_right_total + token.length | 0;
  Stdlib__Queue.add(token, state.pp_queue);
}

function pp_clear_queue(state) {
  state.pp_left_total = 1;
  state.pp_right_total = 1;
  Stdlib__Queue.clear(state.pp_queue);
}

function pp_output_string(state, s) {
  Curry._3(state.pp_out_string, s, 0, s.length);
}

function format_pp_text(state, size, text) {
  state.pp_space_left = state.pp_space_left - size | 0;
  pp_output_string(state, text);
  state.pp_is_new_line = false;
}

function format_string(state, s) {
  if (s !== "") {
    return format_pp_text(state, s.length, s);
  }
  
}

function break_new_line(state, param, width) {
  format_string(state, param[0]);
  Curry._1(state.pp_out_newline, undefined);
  state.pp_is_new_line = true;
  var indent = (state.pp_margin - width | 0) + param[1] | 0;
  var real_indent = Stdlib__Int.min(state.pp_max_indent, indent);
  state.pp_current_indent = real_indent;
  state.pp_space_left = state.pp_margin - state.pp_current_indent | 0;
  Curry._1(state.pp_out_indent, state.pp_current_indent);
  format_string(state, param[2]);
}

function break_line(state, width) {
  break_new_line(state, [
        "",
        0,
        ""
      ], width);
}

function break_same_line(state, param) {
  var width = param[1];
  format_string(state, param[0]);
  state.pp_space_left = state.pp_space_left - width | 0;
  Curry._1(state.pp_out_spaces, width);
  format_string(state, param[2]);
}

function pp_force_break_line(state) {
  var match = Stdlib__Stack.top_opt(state.pp_format_stack);
  if (match === undefined) {
    return Curry._1(state.pp_out_newline, undefined);
  }
  var width = match.width;
  if (width > state.pp_space_left && (match.box_type - 1 >>> 0) <= 3) {
    return break_line(state, width);
  }
  
}

function format_pp_token(state, size, param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Pp_stab */0 :
          var match = Stdlib__Stack.top_opt(state.pp_tbox_stack);
          if (match === undefined) {
            return ;
          }
          var tabs = match._0;
          var add_tab = function (n, ls) {
            if (!ls) {
              return {
                      hd: n,
                      tl: /* [] */0
                    };
            }
            var x = ls.hd;
            if (Caml_obj.caml_lessthan(n, x)) {
              return {
                      hd: n,
                      tl: ls
                    };
            } else {
              return {
                      hd: x,
                      tl: add_tab(n, ls.tl)
                    };
            }
          };
          tabs.contents = add_tab(state.pp_margin - state.pp_space_left | 0, tabs.contents);
          return ;
      case /* Pp_end */1 :
          Stdlib__Stack.pop_opt(state.pp_format_stack);
          return ;
      case /* Pp_tend */2 :
          Stdlib__Stack.pop_opt(state.pp_tbox_stack);
          return ;
      case /* Pp_newline */3 :
          var match$1 = Stdlib__Stack.top_opt(state.pp_format_stack);
          if (match$1 !== undefined) {
            return break_line(state, match$1.width);
          } else {
            return Curry._1(state.pp_out_newline, undefined);
          }
      case /* Pp_if_newline */4 :
          if (state.pp_current_indent !== (state.pp_margin - state.pp_space_left | 0)) {
            var match$2 = Stdlib__Queue.take_opt(state.pp_queue);
            if (match$2 === undefined) {
              return ;
            }
            var size$1 = match$2.size;
            state.pp_left_total = state.pp_left_total - match$2.length | 0;
            state.pp_space_left = state.pp_space_left + size$1 | 0;
            return ;
          } else {
            return ;
          }
      case /* Pp_close_tag */5 :
          var tag_name = Stdlib__Stack.pop_opt(state.pp_mark_stack);
          if (tag_name === undefined) {
            return ;
          }
          var marker = Curry._1(state.pp_mark_close_tag, Caml_option.valFromOption(tag_name));
          return pp_output_string(state, marker);
      
    }
  } else {
    switch (param.TAG | 0) {
      case /* Pp_text */0 :
          return format_pp_text(state, size, param._0);
      case /* Pp_break */1 :
          var breaks = param.breaks;
          var before = breaks[0];
          var fits = param.fits;
          var match$3 = Stdlib__Stack.top_opt(state.pp_format_stack);
          if (match$3 === undefined) {
            return ;
          }
          var width = match$3.width;
          switch (match$3.box_type) {
            case /* Pp_vbox */1 :
            case /* Pp_hvbox */2 :
                return break_new_line(state, breaks, width);
            case /* Pp_hovbox */3 :
                if ((size + before.length | 0) > state.pp_space_left) {
                  return break_new_line(state, breaks, width);
                } else {
                  return break_same_line(state, fits);
                }
            case /* Pp_box */4 :
                if (state.pp_is_new_line || !((size + before.length | 0) > state.pp_space_left || state.pp_current_indent > ((state.pp_margin - width | 0) + breaks[1] | 0))) {
                  return break_same_line(state, fits);
                } else {
                  return break_new_line(state, breaks, width);
                }
            case /* Pp_hbox */0 :
            case /* Pp_fits */5 :
                return break_same_line(state, fits);
            
          }
      case /* Pp_tbreak */2 :
          var insertion_point = state.pp_margin - state.pp_space_left | 0;
          var match$4 = Stdlib__Stack.top_opt(state.pp_tbox_stack);
          if (match$4 === undefined) {
            return ;
          }
          var tabs$1 = match$4._0;
          var match$5 = tabs$1.contents;
          var tab;
          if (match$5) {
            var first = match$5.hd;
            var find = function (_param) {
              while(true) {
                var param = _param;
                if (!param) {
                  return first;
                }
                var head = param.hd;
                if (head >= insertion_point) {
                  return head;
                }
                _param = param.tl;
                continue ;
              };
            };
            tab = find(tabs$1.contents);
          } else {
            tab = insertion_point;
          }
          var offset = tab - insertion_point | 0;
          if (offset >= 0) {
            return break_same_line(state, [
                        "",
                        offset + param._0 | 0,
                        ""
                      ]);
          } else {
            return break_new_line(state, [
                        "",
                        tab + param._1 | 0,
                        ""
                      ], state.pp_margin);
          }
      case /* Pp_begin */3 :
          var ty = param._1;
          var insertion_point$1 = state.pp_margin - state.pp_space_left | 0;
          if (insertion_point$1 > state.pp_max_indent) {
            pp_force_break_line(state);
          }
          var width$1 = state.pp_space_left - param._0 | 0;
          var box_type = ty !== 1 ? (
              size > state.pp_space_left ? ty : /* Pp_fits */5
            ) : /* Pp_vbox */1;
          return Stdlib__Stack.push({
                      box_type: box_type,
                      width: width$1
                    }, state.pp_format_stack);
      case /* Pp_tbegin */4 :
          return Stdlib__Stack.push(param._0, state.pp_tbox_stack);
      case /* Pp_open_tag */5 :
          var tag_name$1 = param._0;
          var marker$1 = Curry._1(state.pp_mark_open_tag, tag_name$1);
          pp_output_string(state, marker$1);
          return Stdlib__Stack.push(tag_name$1, state.pp_mark_stack);
      
    }
  }
}

function advance_left(state) {
  while(true) {
    var match = Stdlib__Queue.peek_opt(state.pp_queue);
    if (match === undefined) {
      return ;
    }
    var size = match.size;
    var pending_count = state.pp_right_total - state.pp_left_total | 0;
    if (!(size >= 0 || pending_count >= state.pp_space_left)) {
      return ;
    }
    Stdlib__Queue.take(state.pp_queue);
    var size$1 = size >= 0 ? size : 1000000010;
    format_pp_token(state, size$1, match.token);
    state.pp_left_total = match.length + state.pp_left_total | 0;
    continue ;
  };
}

function enqueue_advance(state, tok) {
  pp_enqueue(state, tok);
  advance_left(state);
}

function enqueue_string_as(state, size, s) {
  enqueue_advance(state, {
        size: size,
        token: {
          TAG: /* Pp_text */0,
          _0: s
        },
        length: size
      });
}

function initialize_scan_stack(stack) {
  Stdlib__Stack.clear(stack);
  var queue_elem = {
    size: -1,
    token: {
      TAG: /* Pp_text */0,
      _0: ""
    },
    length: 0
  };
  Stdlib__Stack.push({
        left_total: -1,
        queue_elem: queue_elem
      }, stack);
}

function set_size(state, ty) {
  var match = Stdlib__Stack.top_opt(state.pp_scan_stack);
  if (match === undefined) {
    return ;
  }
  var queue_elem = match.queue_elem;
  var size = queue_elem.size;
  if (match.left_total < state.pp_left_total) {
    return initialize_scan_stack(state.pp_scan_stack);
  }
  var match$1 = queue_elem.token;
  if (typeof match$1 === "number") {
    return ;
  }
  switch (match$1.TAG | 0) {
    case /* Pp_break */1 :
    case /* Pp_tbreak */2 :
        break;
    case /* Pp_begin */3 :
        if (!ty) {
          queue_elem.size = state.pp_right_total + size | 0;
          Stdlib__Stack.pop_opt(state.pp_scan_stack);
          return ;
        } else {
          return ;
        }
    default:
      return ;
  }
  if (ty) {
    queue_elem.size = state.pp_right_total + size | 0;
    Stdlib__Stack.pop_opt(state.pp_scan_stack);
    return ;
  }
  
}

function scan_push(state, b, token) {
  pp_enqueue(state, token);
  if (b) {
    set_size(state, true);
  }
  var elem_left_total = state.pp_right_total;
  var elem = {
    left_total: elem_left_total,
    queue_elem: token
  };
  Stdlib__Stack.push(elem, state.pp_scan_stack);
}

function pp_open_box_gen(state, indent, br_ty) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    if (state.pp_curr_depth === state.pp_max_boxes) {
      var s = state.pp_ellipsis;
      return enqueue_string_as(state, s.length, s);
    } else {
      return ;
    }
  }
  var size = -state.pp_right_total | 0;
  var elem = {
    size: size,
    token: {
      TAG: /* Pp_begin */3,
      _0: indent,
      _1: br_ty
    },
    length: 0
  };
  scan_push(state, false, elem);
}

function pp_close_box(state, param) {
  if (state.pp_curr_depth > 1) {
    if (state.pp_curr_depth < state.pp_max_boxes) {
      pp_enqueue(state, {
            size: 0,
            token: /* Pp_end */1,
            length: 0
          });
      set_size(state, true);
      set_size(state, false);
    }
    state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
    return ;
  }
  
}

function pp_open_stag(state, tag_name) {
  if (state.pp_print_tags) {
    Stdlib__Stack.push(tag_name, state.pp_tag_stack);
    Curry._1(state.pp_print_open_tag, tag_name);
  }
  if (!state.pp_mark_tags) {
    return ;
  }
  var token = {
    TAG: /* Pp_open_tag */5,
    _0: tag_name
  };
  pp_enqueue(state, {
        size: 0,
        token: token,
        length: 0
      });
}

function pp_close_stag(state, param) {
  if (state.pp_mark_tags) {
    pp_enqueue(state, {
          size: 0,
          token: /* Pp_close_tag */5,
          length: 0
        });
  }
  if (!state.pp_print_tags) {
    return ;
  }
  var tag_name = Stdlib__Stack.pop_opt(state.pp_tag_stack);
  if (tag_name !== undefined) {
    return Curry._1(state.pp_print_close_tag, Caml_option.valFromOption(tag_name));
  }
  
}

function pp_set_print_tags(state, b) {
  state.pp_print_tags = b;
}

function pp_set_mark_tags(state, b) {
  state.pp_mark_tags = b;
}

function pp_get_print_tags(state, param) {
  return state.pp_print_tags;
}

function pp_get_mark_tags(state, param) {
  return state.pp_mark_tags;
}

function pp_set_tags(state, b) {
  state.pp_print_tags = b;
  state.pp_mark_tags = b;
}

function pp_get_formatter_stag_functions(state, param) {
  return {
          mark_open_stag: state.pp_mark_open_tag,
          mark_close_stag: state.pp_mark_close_tag,
          print_open_stag: state.pp_print_open_tag,
          print_close_stag: state.pp_print_close_tag
        };
}

function pp_set_formatter_stag_functions(state, param) {
  state.pp_mark_open_tag = param.mark_open_stag;
  state.pp_mark_close_tag = param.mark_close_stag;
  state.pp_print_open_tag = param.print_open_stag;
  state.pp_print_close_tag = param.print_close_stag;
}

function pp_rinit(state) {
  pp_clear_queue(state);
  initialize_scan_stack(state.pp_scan_stack);
  Stdlib__Stack.clear(state.pp_format_stack);
  Stdlib__Stack.clear(state.pp_tbox_stack);
  Stdlib__Stack.clear(state.pp_tag_stack);
  Stdlib__Stack.clear(state.pp_mark_stack);
  state.pp_current_indent = 0;
  state.pp_curr_depth = 0;
  state.pp_space_left = state.pp_margin;
  pp_open_box_gen(state, 0, /* Pp_hovbox */3);
}

function clear_tag_stack(state) {
  var s = state.pp_tag_stack;
  var f = function (param) {
    pp_close_stag(state, undefined);
  };
  Stdlib__List.iter(f, s.c);
}

function pp_flush_queue(state, end_with_newline) {
  clear_tag_stack(state);
  while(state.pp_curr_depth > 1) {
    pp_close_box(state, undefined);
  };
  state.pp_right_total = 1000000010;
  advance_left(state);
  if (end_with_newline) {
    Curry._1(state.pp_out_newline, undefined);
  }
  pp_rinit(state);
}

function pp_print_as_size(state, size, s) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_string_as(state, size, s);
  }
  
}

var pp_print_as = pp_print_as_size;

function pp_print_string(state, s) {
  pp_print_as(state, s.length, s);
}

function pp_print_bytes(state, s) {
  pp_print_as(state, s.length, Stdlib__Bytes.to_string(s));
}

function pp_print_int(state, i) {
  pp_print_string(state, Caml_format.caml_format_int("%d", i));
}

function pp_print_float(state, f) {
  pp_print_string(state, Stdlib.string_of_float(f));
}

function pp_print_bool(state, b) {
  pp_print_string(state, b ? "true" : "false");
}

function pp_print_char(state, c) {
  pp_print_as(state, 1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
}

function pp_open_hbox(state, param) {
  pp_open_box_gen(state, 0, /* Pp_hbox */0);
}

function pp_open_vbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_vbox */1);
}

function pp_open_hvbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hvbox */2);
}

function pp_open_hovbox(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_hovbox */3);
}

function pp_open_box(state, indent) {
  pp_open_box_gen(state, indent, /* Pp_box */4);
}

function pp_print_newline(state, param) {
  pp_flush_queue(state, true);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_print_flush(state, param) {
  pp_flush_queue(state, false);
  Curry._1(state.pp_out_flush, undefined);
}

function pp_force_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
                size: 0,
                token: /* Pp_newline */3,
                length: 0
              });
  }
  
}

function pp_print_if_newline(state, param) {
  if (state.pp_curr_depth < state.pp_max_boxes) {
    return enqueue_advance(state, {
                size: 0,
                token: /* Pp_if_newline */4,
                length: 0
              });
  }
  
}

function pp_print_custom_break(state, fits, breaks) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return ;
  }
  var size = -state.pp_right_total | 0;
  var token = {
    TAG: /* Pp_break */1,
    fits: fits,
    breaks: breaks
  };
  var length = (fits[0].length + fits[1] | 0) + fits[2].length | 0;
  var elem = {
    size: size,
    token: token,
    length: length
  };
  scan_push(state, true, elem);
}

function pp_print_break(state, width, offset) {
  pp_print_custom_break(state, [
        "",
        width,
        ""
      ], [
        "",
        offset,
        ""
      ]);
}

function pp_print_space(state, param) {
  pp_print_break(state, 1, 0);
}

function pp_print_cut(state, param) {
  pp_print_break(state, 0, 0);
}

function pp_open_tbox(state, param) {
  state.pp_curr_depth = state.pp_curr_depth + 1 | 0;
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return ;
  }
  var elem = {
    size: 0,
    token: {
      TAG: /* Pp_tbegin */4,
      _0: /* Pp_tbox */{
        _0: {
          contents: /* [] */0
        }
      }
    },
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_close_tbox(state, param) {
  if (state.pp_curr_depth <= 1) {
    return ;
  }
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return ;
  }
  var elem = {
    size: 0,
    token: /* Pp_tend */2,
    length: 0
  };
  enqueue_advance(state, elem);
  state.pp_curr_depth = state.pp_curr_depth - 1 | 0;
}

function pp_print_tbreak(state, width, offset) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return ;
  }
  var size = -state.pp_right_total | 0;
  var elem = {
    size: size,
    token: {
      TAG: /* Pp_tbreak */2,
      _0: width,
      _1: offset
    },
    length: width
  };
  scan_push(state, true, elem);
}

function pp_print_tab(state, param) {
  pp_print_tbreak(state, 0, 0);
}

function pp_set_tab(state, param) {
  if (state.pp_curr_depth >= state.pp_max_boxes) {
    return ;
  }
  var elem = {
    size: 0,
    token: /* Pp_stab */0,
    length: 0
  };
  enqueue_advance(state, elem);
}

function pp_set_max_boxes(state, n) {
  if (n > 1) {
    state.pp_max_boxes = n;
    return ;
  }
  
}

function pp_get_max_boxes(state, param) {
  return state.pp_max_boxes;
}

function pp_over_max_boxes(state, param) {
  return state.pp_curr_depth === state.pp_max_boxes;
}

function pp_set_ellipsis_text(state, s) {
  state.pp_ellipsis = s;
}

function pp_get_ellipsis_text(state, param) {
  return state.pp_ellipsis;
}

function pp_limit(n) {
  if (n < 1000000010) {
    return n;
  } else {
    return 1000000009;
  }
}

function pp_set_max_indent(state, n) {
  if (n > 1) {
    var n$1 = state.pp_margin - n | 0;
    if (n$1 < 1) {
      return ;
    }
    var n$2 = pp_limit(n$1);
    state.pp_min_space_left = n$2;
    state.pp_max_indent = state.pp_margin - state.pp_min_space_left | 0;
    return pp_rinit(state);
  }
  
}

function pp_get_max_indent(state, param) {
  return state.pp_max_indent;
}

function pp_set_margin(state, n) {
  if (n < 1) {
    return ;
  }
  var n$1 = pp_limit(n);
  state.pp_margin = n$1;
  var new_max_indent = state.pp_max_indent <= state.pp_margin ? state.pp_max_indent : Stdlib__Int.max(Stdlib__Int.max(state.pp_margin - state.pp_min_space_left | 0, state.pp_margin / 2 | 0), 1);
  pp_set_max_indent(state, new_max_indent);
}

function validate_geometry(param) {
  var max_indent = param.max_indent;
  if (max_indent < 2) {
    return {
            TAG: /* Error */1,
            _0: "max_indent < 2"
          };
  } else if (param.margin <= max_indent) {
    return {
            TAG: /* Error */1,
            _0: "margin <= max_indent"
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  }
}

function check_geometry(geometry) {
  var match = validate_geometry(geometry);
  if (match.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function pp_get_margin(state, param) {
  return state.pp_margin;
}

function pp_set_full_geometry(state, param) {
  pp_set_margin(state, param.margin);
  pp_set_max_indent(state, param.max_indent);
}

function pp_set_geometry(state, max_indent, margin) {
  var geometry = {
    max_indent: max_indent,
    margin: margin
  };
  var msg = validate_geometry(geometry);
  if (msg.TAG === /* Ok */0) {
    return pp_set_full_geometry(state, geometry);
  }
  throw {
        MEL_EXN_ID: Stdlib.Invalid_argument,
        _1: "Format.pp_set_geometry: " + msg._0,
        Error: new Error()
      };
}

function pp_safe_set_geometry(state, max_indent, margin) {
  var geometry = {
    max_indent: max_indent,
    margin: margin
  };
  var _msg = validate_geometry(geometry);
  if (_msg.TAG === /* Ok */0) {
    return pp_set_full_geometry(state, geometry);
  }
  
}

function pp_get_geometry(state, param) {
  return {
          max_indent: state.pp_max_indent,
          margin: state.pp_margin
        };
}

function pp_update_geometry(state, update) {
  var geometry = pp_get_geometry(state, undefined);
  pp_set_full_geometry(state, Curry._1(update, geometry));
}

function pp_set_formatter_out_functions(state, param) {
  state.pp_out_string = param.out_string;
  state.pp_out_flush = param.out_flush;
  state.pp_out_newline = param.out_newline;
  state.pp_out_spaces = param.out_spaces;
  state.pp_out_indent = param.out_indent;
}

function pp_get_formatter_out_functions(state, param) {
  return {
          out_string: state.pp_out_string,
          out_flush: state.pp_out_flush,
          out_newline: state.pp_out_newline,
          out_spaces: state.pp_out_spaces,
          out_indent: state.pp_out_indent
        };
}

function pp_set_formatter_output_functions(state, f, g) {
  state.pp_out_string = f;
  state.pp_out_flush = g;
}

function pp_get_formatter_output_functions(state, param) {
  return [
          state.pp_out_string,
          state.pp_out_flush
        ];
}

function display_newline(state, param) {
  Curry._3(state.pp_out_string, "\\n", 0, 1);
}

var blank_line = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(80, /* ' ' */32));

function display_blanks(state, _n) {
  while(true) {
    var n = _n;
    if (n <= 0) {
      return ;
    }
    if (n <= 80) {
      return Curry._3(state.pp_out_string, blank_line, 0, n);
    }
    Curry._3(state.pp_out_string, blank_line, 0, 80);
    _n = n - 80 | 0;
    continue ;
  };
}

function pp_set_formatter_out_channel(state, oc) {
  state.pp_out_string = (function (param, param$1, param$2) {
      return Stdlib.output_substring(oc, param, param$1, param$2);
    });
  state.pp_out_flush = (function (param) {
      Caml_io.caml_ml_flush(oc);
    });
  state.pp_out_newline = (function (param) {
      return display_newline(state, param);
    });
  state.pp_out_spaces = (function (param) {
      return display_blanks(state, param);
    });
  state.pp_out_indent = (function (param) {
      return display_blanks(state, param);
    });
}

function default_pp_mark_open_tag(param) {
  if (param.MEL_EXN_ID === String_tag) {
    return "<" + (param._1 + ">");
  } else {
    return "";
  }
}

function default_pp_mark_close_tag(param) {
  if (param.MEL_EXN_ID === String_tag) {
    return "</" + (param._1 + ">");
  } else {
    return "";
  }
}

function default_pp_print_open_tag(prim) {
  
}

function default_pp_print_close_tag(prim) {
  
}

function pp_make_formatter(f, g, h, i, j) {
  var pp_queue = {
    length: 0,
    first: /* Nil */0,
    last: /* Nil */0
  };
  var sys_tok = {
    size: -1,
    token: {
      TAG: /* Pp_begin */3,
      _0: 0,
      _1: /* Pp_hovbox */3
    },
    length: 0
  };
  Stdlib__Queue.add(sys_tok, pp_queue);
  var scan_stack = {
    c: /* [] */0,
    len: 0
  };
  initialize_scan_stack(scan_stack);
  Stdlib__Stack.push({
        left_total: 1,
        queue_elem: sys_tok
      }, scan_stack);
  return {
          pp_scan_stack: scan_stack,
          pp_format_stack: {
            c: /* [] */0,
            len: 0
          },
          pp_tbox_stack: {
            c: /* [] */0,
            len: 0
          },
          pp_tag_stack: {
            c: /* [] */0,
            len: 0
          },
          pp_mark_stack: {
            c: /* [] */0,
            len: 0
          },
          pp_margin: 78,
          pp_min_space_left: 10,
          pp_max_indent: 68,
          pp_space_left: 78,
          pp_current_indent: 0,
          pp_is_new_line: true,
          pp_left_total: 1,
          pp_right_total: 1,
          pp_curr_depth: 1,
          pp_max_boxes: Stdlib.max_int,
          pp_ellipsis: ".",
          pp_out_string: f,
          pp_out_flush: g,
          pp_out_newline: h,
          pp_out_spaces: i,
          pp_out_indent: j,
          pp_print_tags: false,
          pp_mark_tags: false,
          pp_mark_open_tag: default_pp_mark_open_tag,
          pp_mark_close_tag: default_pp_mark_close_tag,
          pp_print_open_tag: default_pp_print_open_tag,
          pp_print_close_tag: default_pp_print_close_tag,
          pp_queue: pp_queue
        };
}

function formatter_of_out_functions(out_funs) {
  return pp_make_formatter(out_funs.out_string, out_funs.out_flush, out_funs.out_newline, out_funs.out_spaces, out_funs.out_indent);
}

function make_formatter(output, flush) {
  var ppf = pp_make_formatter(output, flush, (function (prim) {
          
        }), (function (prim) {
          
        }), (function (prim) {
          
        }));
  ppf.pp_out_newline = (function (param) {
      return display_newline(ppf, param);
    });
  ppf.pp_out_spaces = (function (param) {
      return display_blanks(ppf, param);
    });
  ppf.pp_out_indent = (function (param) {
      return display_blanks(ppf, param);
    });
  return ppf;
}

function formatter_of_out_channel(oc) {
  return make_formatter((function (param, param$1, param$2) {
                return Stdlib.output_substring(oc, param, param$1, param$2);
              }), (function (param) {
                Caml_io.caml_ml_flush(oc);
              }));
}

function formatter_of_buffer(b) {
  return make_formatter((function (param, param$1, param$2) {
                return Stdlib__Buffer.add_substring(b, param, param$1, param$2);
              }), (function (prim) {
                
              }));
}

function pp_make_buffer(param) {
  return Stdlib__Buffer.create(512);
}

var stdbuf = Stdlib__Buffer.create(512);

var std_formatter = formatter_of_out_channel(Stdlib.stdout);

var err_formatter = formatter_of_out_channel(Stdlib.stderr);

var str_formatter = formatter_of_buffer(stdbuf);

var stdbuf_key = Stdlib__Domain.DLS.new_key(undefined, pp_make_buffer);

Stdlib__Domain.DLS.set(stdbuf_key, stdbuf);

var str_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
        return formatter_of_buffer(Stdlib__Domain.DLS.get(stdbuf_key));
      }));

Stdlib__Domain.DLS.set(str_formatter_key, str_formatter);

function buffered_out_string(key, str, ofs, len) {
  Stdlib__Buffer.add_substring(Stdlib__Domain.DLS.get(key), str, ofs, len);
}

function buffered_out_flush(oc, key, param) {
  var buf = Stdlib__Domain.DLS.get(key);
  var len = buf.position;
  var str = Stdlib__Buffer.contents(buf);
  Stdlib.output_substring(oc, str, 0, len);
  Caml_io.caml_ml_flush(oc);
  buf.position = 0;
}

var std_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
        return Stdlib__Buffer.create(512);
      }));

var err_buf_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
        return Stdlib__Buffer.create(512);
      }));

var std_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
        var ppf = pp_make_formatter((function (param, param$1, param$2) {
                return buffered_out_string(std_buf_key, param, param$1, param$2);
              }), (function (param) {
                return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
              }), (function (prim) {
                
              }), (function (prim) {
                
              }), (function (prim) {
                
              }));
        ppf.pp_out_newline = (function (param) {
            return display_newline(ppf, param);
          });
        ppf.pp_out_spaces = (function (param) {
            return display_blanks(ppf, param);
          });
        ppf.pp_out_indent = (function (param) {
            return display_blanks(ppf, param);
          });
        Stdlib__Domain.at_exit(function (param) {
              return pp_print_flush(ppf, param);
            });
        return ppf;
      }));

Stdlib__Domain.DLS.set(std_formatter_key, std_formatter);

var err_formatter_key = Stdlib__Domain.DLS.new_key(undefined, (function (param) {
        var ppf = pp_make_formatter((function (param, param$1, param$2) {
                return buffered_out_string(err_buf_key, param, param$1, param$2);
              }), (function (param) {
                return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
              }), (function (prim) {
                
              }), (function (prim) {
                
              }), (function (prim) {
                
              }));
        ppf.pp_out_newline = (function (param) {
            return display_newline(ppf, param);
          });
        ppf.pp_out_spaces = (function (param) {
            return display_blanks(ppf, param);
          });
        ppf.pp_out_indent = (function (param) {
            return display_blanks(ppf, param);
          });
        Stdlib__Domain.at_exit(function (param) {
              return pp_print_flush(ppf, param);
            });
        return ppf;
      }));

Stdlib__Domain.DLS.set(err_formatter_key, err_formatter);

function get_std_formatter(param) {
  return Stdlib__Domain.DLS.get(std_formatter_key);
}

function get_err_formatter(param) {
  return Stdlib__Domain.DLS.get(err_formatter_key);
}

function get_str_formatter(param) {
  return Stdlib__Domain.DLS.get(str_formatter_key);
}

function get_stdbuf(param) {
  return Stdlib__Domain.DLS.get(stdbuf_key);
}

function flush_buffer_formatter(buf, ppf) {
  pp_flush_queue(ppf, false);
  var s = Stdlib__Buffer.contents(buf);
  Stdlib__Buffer.reset(buf);
  return s;
}

function flush_str_formatter(param) {
  var stdbuf = Stdlib__Domain.DLS.get(stdbuf_key);
  var str_formatter = Stdlib__Domain.DLS.get(str_formatter_key);
  return flush_buffer_formatter(stdbuf, str_formatter);
}

function make_synchronized_formatter(output, flush) {
  return Stdlib__Domain.DLS.new_key(undefined, (function (param) {
                var buf = Stdlib__Buffer.create(512);
                var output$p = function (param, param$1, param$2) {
                  return Stdlib__Buffer.add_substring(buf, param, param$1, param$2);
                };
                var flush$p = function (param) {
                  Curry._3(output, Stdlib__Buffer.contents(buf), 0, buf.position);
                  buf.position = 0;
                  Curry._1(flush, undefined);
                };
                return make_formatter(output$p, flush$p);
              }));
}

function synchronized_formatter_of_out_channel(oc) {
  return make_synchronized_formatter((function (param, param$1, param$2) {
                return Stdlib.output_substring(oc, param, param$1, param$2);
              }), (function (param) {
                Caml_io.caml_ml_flush(oc);
              }));
}

function make_symbolic_output_buffer(param) {
  return {
          symbolic_output_contents: /* [] */0
        };
}

function clear_symbolic_output_buffer(sob) {
  sob.symbolic_output_contents = /* [] */0;
}

function get_symbolic_output_buffer(sob) {
  return Stdlib__List.rev(sob.symbolic_output_contents);
}

function flush_symbolic_output_buffer(sob) {
  var items = Stdlib__List.rev(sob.symbolic_output_contents);
  sob.symbolic_output_contents = /* [] */0;
  return items;
}

function add_symbolic_output_item(sob, item) {
  sob.symbolic_output_contents = {
    hd: item,
    tl: sob.symbolic_output_contents
  };
}

function formatter_of_symbolic_output_buffer(sob) {
  var f = function (param, param$1, param$2) {
    return add_symbolic_output_item(sob, {
                TAG: /* Output_string */0,
                _0: Stdlib__String.sub(param, param$1, param$2)
              });
  };
  var g = function (param) {
    return add_symbolic_output_item(sob, /* Output_flush */0);
  };
  var h = function (param) {
    return add_symbolic_output_item(sob, /* Output_newline */1);
  };
  var i = function (param) {
    return add_symbolic_output_item(sob, {
                TAG: /* Output_spaces */1,
                _0: param
              });
  };
  var j = function (param) {
    return add_symbolic_output_item(sob, {
                TAG: /* Output_indent */2,
                _0: param
              });
  };
  return pp_make_formatter(f, g, h, i, j);
}

function open_hbox(v) {
  pp_open_hbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_vbox(v) {
  pp_open_vbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hvbox(v) {
  pp_open_hvbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_hovbox(v) {
  pp_open_hovbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_box(v) {
  pp_open_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_box(v) {
  pp_close_box(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_stag(v) {
  pp_open_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_stag(v) {
  pp_close_stag(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_as(v, w) {
  pp_print_as(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_string(v) {
  pp_print_string(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_bytes(v) {
  pp_print_bytes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_int(v) {
  var state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Caml_format.caml_format_int("%d", v));
}

function print_float(v) {
  var state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, Stdlib.string_of_float(v));
}

function print_char(v) {
  pp_print_char(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_bool(v) {
  var state = Stdlib__Domain.DLS.get(std_formatter_key);
  pp_print_string(state, v ? "true" : "false");
}

function print_break(v, w) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function print_cut(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function print_space(v) {
  pp_print_break(Stdlib__Domain.DLS.get(std_formatter_key), 1, 0);
}

function force_newline(v) {
  pp_force_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_flush(v) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_newline(v) {
  pp_print_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_if_newline(v) {
  pp_print_if_newline(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function open_tbox(v) {
  pp_open_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function close_tbox(v) {
  pp_close_tbox(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tbreak(v, w) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function set_tab(v) {
  pp_set_tab(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function print_tab(v) {
  pp_print_tbreak(Stdlib__Domain.DLS.get(std_formatter_key), 0, 0);
}

function set_margin(v) {
  pp_set_margin(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_margin(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_margin;
}

function set_max_indent(v) {
  pp_set_max_indent(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_indent(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_indent;
}

function set_geometry(max_indent, margin) {
  pp_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function safe_set_geometry(max_indent, margin) {
  pp_safe_set_geometry(Stdlib__Domain.DLS.get(std_formatter_key), max_indent, margin);
}

function get_geometry(v) {
  return pp_get_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function update_geometry(v) {
  pp_update_geometry(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_max_boxes(v) {
  pp_set_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_max_boxes(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_max_boxes;
}

function over_max_boxes(v) {
  return pp_over_max_boxes(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_ellipsis_text(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis = v;
}

function get_ellipsis_text(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_ellipsis;
}

function set_formatter_out_channel(v) {
  pp_set_formatter_out_channel(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_out_functions(v) {
  pp_set_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_out_functions(v) {
  return pp_get_formatter_out_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_output_functions(v, w) {
  pp_set_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v, w);
}

function get_formatter_output_functions(v) {
  return pp_get_formatter_output_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_formatter_stag_functions(v) {
  pp_set_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function get_formatter_stag_functions(v) {
  return pp_get_formatter_stag_functions(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function set_print_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags = v;
}

function get_print_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_print_tags;
}

function set_mark_tags(v) {
  Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags = v;
}

function get_mark_tags(v) {
  return Stdlib__Domain.DLS.get(std_formatter_key).pp_mark_tags;
}

function set_tags(v) {
  pp_set_tags(Stdlib__Domain.DLS.get(std_formatter_key), v);
}

function pp_print_iter(pp_sepOpt, iter, pp_v, ppf, v) {
  var pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  var is_first = {
    contents: true
  };
  var pp_v$1 = function (v) {
    if (is_first.contents) {
      is_first.contents = false;
    } else {
      Curry._2(pp_sep, ppf, undefined);
    }
    return Curry._2(pp_v, ppf, v);
  };
  return Curry._2(iter, pp_v$1, v);
}

function pp_print_list(pp_sepOpt, pp_v, ppf, v) {
  var pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__List.iter, pp_v, ppf, v);
}

function pp_print_array(pp_sepOpt, pp_v, ppf, v) {
  var pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Array.iter, pp_v, ppf, v);
}

function pp_print_seq(pp_sepOpt, pp_v, ppf, seq) {
  var pp_sep = pp_sepOpt !== undefined ? pp_sepOpt : pp_print_cut;
  pp_print_iter(pp_sep, Stdlib__Seq.iter, pp_v, ppf, seq);
}

function pp_print_text(ppf, s) {
  var len = s.length;
  var left = {
    contents: 0
  };
  var right = {
    contents: 0
  };
  var flush = function (param) {
    pp_print_string(ppf, Stdlib__String.sub(s, left.contents, right.contents - left.contents | 0));
    right.contents = right.contents + 1 | 0;
    left.contents = right.contents;
  };
  while(right.contents !== len) {
    var match = Caml_string.get(s, right.contents);
    if (match !== 10) {
      if (match !== 32) {
        right.contents = right.contents + 1 | 0;
      } else {
        flush(undefined);
        pp_print_break(ppf, 1, 0);
      }
    } else {
      flush(undefined);
      pp_force_newline(ppf, undefined);
    }
  };
  if (left.contents !== len) {
    return flush(undefined);
  }
  
}

function pp_print_option(noneOpt, pp_v, ppf, param) {
  var none = noneOpt !== undefined ? noneOpt : (function (param, param$1) {
        
      });
  if (param !== undefined) {
    return Curry._2(pp_v, ppf, Caml_option.valFromOption(param));
  } else {
    return Curry._2(none, ppf, undefined);
  }
}

function pp_print_result(ok, error, ppf, param) {
  if (param.TAG === /* Ok */0) {
    return Curry._2(ok, ppf, param._0);
  } else {
    return Curry._2(error, ppf, param._0);
  }
}

function pp_print_either(left, right, ppf, param) {
  if (param.TAG === /* Left */0) {
    return Curry._2(left, ppf, param._0);
  } else {
    return Curry._2(right, ppf, param._0);
  }
}

function compute_tag(output, tag_acc) {
  var buf = Stdlib__Buffer.create(16);
  var ppf = formatter_of_buffer(buf);
  Curry._2(output, ppf, tag_acc);
  pp_print_flush(ppf, undefined);
  var len = buf.position;
  if (len < 2) {
    return Stdlib__Buffer.contents(buf);
  } else {
    return Stdlib__Buffer.sub(buf, 1, len - 2 | 0);
  }
}

function output_formatting_lit(ppf, fmting_lit) {
  if (typeof fmting_lit === "number") {
    switch (fmting_lit) {
      case /* Close_box */0 :
          return pp_close_box(ppf, undefined);
      case /* Close_tag */1 :
          return pp_close_stag(ppf, undefined);
      case /* FFlush */2 :
          return pp_print_flush(ppf, undefined);
      case /* Force_newline */3 :
          return pp_force_newline(ppf, undefined);
      case /* Flush_newline */4 :
          return pp_print_newline(ppf, undefined);
      case /* Escaped_at */5 :
          return pp_print_char(ppf, /* '@' */64);
      case /* Escaped_percent */6 :
          return pp_print_char(ppf, /* '%' */37);
      
    }
  } else {
    switch (fmting_lit.TAG | 0) {
      case /* Break */0 :
          return pp_print_break(ppf, fmting_lit._1, fmting_lit._2);
      case /* Magic_size */1 :
          return ;
      case /* Scan_indic */2 :
          pp_print_char(ppf, /* '@' */64);
          return pp_print_char(ppf, fmting_lit._0);
      
    }
  }
}

function output_acc(ppf, acc) {
  var exit = 0;
  var p;
  var size;
  var s;
  var p$1;
  var size$1;
  var c;
  if (typeof acc === "number") {
    return ;
  }
  switch (acc.TAG | 0) {
    case /* Acc_formatting_lit */0 :
        output_acc(ppf, acc._0);
        return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */1 :
        var acc$p = acc._1;
        var p$2 = acc._0;
        if (acc$p.TAG === /* Acc_open_tag */0) {
          output_acc(ppf, p$2);
          return pp_open_stag(ppf, {
                      MEL_EXN_ID: String_tag,
                      _1: compute_tag(output_acc, acc$p._0)
                    });
        }
        output_acc(ppf, p$2);
        var match = CamlinternalFormat.open_box_of_string(compute_tag(output_acc, acc$p._0));
        return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */2 :
        var p$3 = acc._0;
        var exit$1 = 0;
        if (typeof p$3 === "number" || p$3.TAG !== /* Acc_formatting_lit */0) {
          exit$1 = 3;
        } else {
          var match$1 = p$3._1;
          if (typeof match$1 === "number" || match$1.TAG !== /* Magic_size */1) {
            exit$1 = 3;
          } else {
            p = p$3._0;
            size = match$1._1;
            s = acc._1;
            exit = 1;
          }
        }
        if (exit$1 === 3) {
          output_acc(ppf, p$3);
          return pp_print_string(ppf, acc._1);
        }
        break;
    case /* Acc_char_literal */3 :
        var p$4 = acc._0;
        var exit$2 = 0;
        if (typeof p$4 === "number" || p$4.TAG !== /* Acc_formatting_lit */0) {
          exit$2 = 3;
        } else {
          var match$2 = p$4._1;
          if (typeof match$2 === "number" || match$2.TAG !== /* Magic_size */1) {
            exit$2 = 3;
          } else {
            p$1 = p$4._0;
            size$1 = match$2._1;
            c = acc._1;
            exit = 2;
          }
        }
        if (exit$2 === 3) {
          output_acc(ppf, p$4);
          return pp_print_char(ppf, acc._1);
        }
        break;
    case /* Acc_data_string */4 :
        var p$5 = acc._0;
        var exit$3 = 0;
        if (typeof p$5 === "number" || p$5.TAG !== /* Acc_formatting_lit */0) {
          exit$3 = 3;
        } else {
          var match$3 = p$5._1;
          if (typeof match$3 === "number" || match$3.TAG !== /* Magic_size */1) {
            exit$3 = 3;
          } else {
            p = p$5._0;
            size = match$3._1;
            s = acc._1;
            exit = 1;
          }
        }
        if (exit$3 === 3) {
          output_acc(ppf, p$5);
          return pp_print_string(ppf, acc._1);
        }
        break;
    case /* Acc_data_char */5 :
        var p$6 = acc._0;
        var exit$4 = 0;
        if (typeof p$6 === "number" || p$6.TAG !== /* Acc_formatting_lit */0) {
          exit$4 = 3;
        } else {
          var match$4 = p$6._1;
          if (typeof match$4 === "number" || match$4.TAG !== /* Magic_size */1) {
            exit$4 = 3;
          } else {
            p$1 = p$6._0;
            size$1 = match$4._1;
            c = acc._1;
            exit = 2;
          }
        }
        if (exit$4 === 3) {
          output_acc(ppf, p$6);
          return pp_print_char(ppf, acc._1);
        }
        break;
    case /* Acc_delay */6 :
        output_acc(ppf, acc._0);
        return Curry._1(acc._1, ppf);
    case /* Acc_flush */7 :
        output_acc(ppf, acc._0);
        return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */8 :
        output_acc(ppf, acc._0);
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: acc._1,
              Error: new Error()
            };
    
  }
  switch (exit) {
    case 1 :
        output_acc(ppf, p);
        return pp_print_as_size(ppf, size, s);
    case 2 :
        output_acc(ppf, p$1);
        return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
    
  }
}

function strput_acc(ppf, acc) {
  var exit = 0;
  var p;
  var size;
  var s;
  var p$1;
  var size$1;
  var c;
  if (typeof acc === "number") {
    return ;
  }
  switch (acc.TAG | 0) {
    case /* Acc_formatting_lit */0 :
        strput_acc(ppf, acc._0);
        return output_formatting_lit(ppf, acc._1);
    case /* Acc_formatting_gen */1 :
        var acc$p = acc._1;
        var p$2 = acc._0;
        if (acc$p.TAG === /* Acc_open_tag */0) {
          strput_acc(ppf, p$2);
          return pp_open_stag(ppf, {
                      MEL_EXN_ID: String_tag,
                      _1: compute_tag(strput_acc, acc$p._0)
                    });
        }
        strput_acc(ppf, p$2);
        var match = CamlinternalFormat.open_box_of_string(compute_tag(strput_acc, acc$p._0));
        return pp_open_box_gen(ppf, match[0], match[1]);
    case /* Acc_string_literal */2 :
        var p$3 = acc._0;
        var exit$1 = 0;
        if (typeof p$3 === "number" || p$3.TAG !== /* Acc_formatting_lit */0) {
          exit$1 = 3;
        } else {
          var match$1 = p$3._1;
          if (typeof match$1 === "number" || match$1.TAG !== /* Magic_size */1) {
            exit$1 = 3;
          } else {
            p = p$3._0;
            size = match$1._1;
            s = acc._1;
            exit = 1;
          }
        }
        if (exit$1 === 3) {
          strput_acc(ppf, p$3);
          return pp_print_string(ppf, acc._1);
        }
        break;
    case /* Acc_char_literal */3 :
        var p$4 = acc._0;
        var exit$2 = 0;
        if (typeof p$4 === "number" || p$4.TAG !== /* Acc_formatting_lit */0) {
          exit$2 = 3;
        } else {
          var match$2 = p$4._1;
          if (typeof match$2 === "number" || match$2.TAG !== /* Magic_size */1) {
            exit$2 = 3;
          } else {
            p$1 = p$4._0;
            size$1 = match$2._1;
            c = acc._1;
            exit = 2;
          }
        }
        if (exit$2 === 3) {
          strput_acc(ppf, p$4);
          return pp_print_char(ppf, acc._1);
        }
        break;
    case /* Acc_data_string */4 :
        var p$5 = acc._0;
        var exit$3 = 0;
        if (typeof p$5 === "number" || p$5.TAG !== /* Acc_formatting_lit */0) {
          exit$3 = 3;
        } else {
          var match$3 = p$5._1;
          if (typeof match$3 === "number" || match$3.TAG !== /* Magic_size */1) {
            exit$3 = 3;
          } else {
            p = p$5._0;
            size = match$3._1;
            s = acc._1;
            exit = 1;
          }
        }
        if (exit$3 === 3) {
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, acc._1);
        }
        break;
    case /* Acc_data_char */5 :
        var p$6 = acc._0;
        var exit$4 = 0;
        if (typeof p$6 === "number" || p$6.TAG !== /* Acc_formatting_lit */0) {
          exit$4 = 3;
        } else {
          var match$4 = p$6._1;
          if (typeof match$4 === "number" || match$4.TAG !== /* Magic_size */1) {
            exit$4 = 3;
          } else {
            p$1 = p$6._0;
            size$1 = match$4._1;
            c = acc._1;
            exit = 2;
          }
        }
        if (exit$4 === 3) {
          strput_acc(ppf, p$6);
          return pp_print_char(ppf, acc._1);
        }
        break;
    case /* Acc_delay */6 :
        var p$7 = acc._0;
        var exit$5 = 0;
        if (typeof p$7 === "number" || p$7.TAG !== /* Acc_formatting_lit */0) {
          exit$5 = 3;
        } else {
          var match$5 = p$7._1;
          if (typeof match$5 === "number") {
            exit$5 = 3;
          } else {
            if (match$5.TAG === /* Magic_size */1) {
              strput_acc(ppf, p$7._0);
              return pp_print_as_size(ppf, match$5._1, Curry._1(acc._1, undefined));
            }
            exit$5 = 3;
          }
        }
        if (exit$5 === 3) {
          strput_acc(ppf, p$7);
          return pp_print_string(ppf, Curry._1(acc._1, undefined));
        }
        break;
    case /* Acc_flush */7 :
        strput_acc(ppf, acc._0);
        return pp_print_flush(ppf, undefined);
    case /* Acc_invalid_arg */8 :
        strput_acc(ppf, acc._0);
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: acc._1,
              Error: new Error()
            };
    
  }
  switch (exit) {
    case 1 :
        strput_acc(ppf, p);
        return pp_print_as_size(ppf, size, s);
    case 2 :
        strput_acc(ppf, p$1);
        return pp_print_as_size(ppf, size$1, Caml_bytes.bytes_to_string(Stdlib__Bytes.make(1, c)));
    
  }
}

function kfprintf(k, ppf, param) {
  return CamlinternalFormat.make_printf((function (acc) {
                output_acc(ppf, acc);
                return Curry._1(k, ppf);
              }), /* End_of_acc */0, param._0);
}

function ikfprintf(k, ppf, param) {
  return CamlinternalFormat.make_iprintf(k, ppf, param._0);
}

function ifprintf(_ppf, param) {
  return CamlinternalFormat.make_iprintf((function (prim) {
                
              }), undefined, param._0);
}

function fprintf(ppf) {
  return function (param) {
    return kfprintf((function (prim) {
                  
                }), ppf, param);
  };
}

function printf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
                output_acc(Stdlib__Domain.DLS.get(std_formatter_key), acc);
              }), /* End_of_acc */0, param._0);
}

function eprintf(param) {
  return CamlinternalFormat.make_printf((function (acc) {
                output_acc(Stdlib__Domain.DLS.get(err_formatter_key), acc);
              }), /* End_of_acc */0, param._0);
}

function kdprintf(k, param) {
  return CamlinternalFormat.make_printf((function (acc) {
                return Curry._1(k, (function (ppf) {
                              output_acc(ppf, acc);
                            }));
              }), /* End_of_acc */0, param._0);
}

function dprintf(fmt) {
  return kdprintf((function (i) {
                return i;
              }), fmt);
}

function ksprintf(k, param) {
  var b = Stdlib__Buffer.create(512);
  var ppf = formatter_of_buffer(b);
  var k$1 = function (acc) {
    strput_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */0, param._0);
}

function sprintf(fmt) {
  return ksprintf(id, fmt);
}

function kasprintf(k, param) {
  var b = Stdlib__Buffer.create(512);
  var ppf = formatter_of_buffer(b);
  var k$1 = function (acc) {
    output_acc(ppf, acc);
    return Curry._1(k, flush_buffer_formatter(b, ppf));
  };
  return CamlinternalFormat.make_printf(k$1, /* End_of_acc */0, param._0);
}

function asprintf(fmt) {
  return kasprintf(id, fmt);
}

function flush_standard_formatters(param) {
  pp_print_flush(Stdlib__Domain.DLS.get(std_formatter_key), undefined);
  pp_print_flush(Stdlib__Domain.DLS.get(err_formatter_key), undefined);
}

Stdlib.at_exit(flush_standard_formatters);

Stdlib__Domain.before_first_spawn(function (param) {
      flush_standard_formatters(undefined);
      var fs = pp_get_formatter_out_functions(std_formatter, undefined);
      pp_set_formatter_out_functions(std_formatter, {
            out_string: (function (param, param$1, param$2) {
                return buffered_out_string(std_buf_key, param, param$1, param$2);
              }),
            out_flush: (function (param) {
                return buffered_out_flush(Stdlib.stdout, std_buf_key, param);
              }),
            out_newline: fs.out_newline,
            out_spaces: fs.out_spaces,
            out_indent: fs.out_indent
          });
      var fs$1 = pp_get_formatter_out_functions(err_formatter, undefined);
      pp_set_formatter_out_functions(err_formatter, {
            out_string: (function (param, param$1, param$2) {
                return buffered_out_string(err_buf_key, param, param$1, param$2);
              }),
            out_flush: (function (param) {
                return buffered_out_flush(Stdlib.stderr, err_buf_key, param);
              }),
            out_newline: fs$1.out_newline,
            out_spaces: fs$1.out_spaces,
            out_indent: fs$1.out_indent
          });
    });

export {
  pp_open_box ,
  open_box ,
  pp_close_box ,
  close_box ,
  pp_open_hbox ,
  open_hbox ,
  pp_open_vbox ,
  open_vbox ,
  pp_open_hvbox ,
  open_hvbox ,
  pp_open_hovbox ,
  open_hovbox ,
  pp_print_string ,
  print_string ,
  pp_print_bytes ,
  print_bytes ,
  pp_print_as ,
  print_as ,
  pp_print_int ,
  print_int ,
  pp_print_float ,
  print_float ,
  pp_print_char ,
  print_char ,
  pp_print_bool ,
  print_bool ,
  pp_print_space ,
  print_space ,
  pp_print_cut ,
  print_cut ,
  pp_print_break ,
  print_break ,
  pp_print_custom_break ,
  pp_force_newline ,
  force_newline ,
  pp_print_if_newline ,
  print_if_newline ,
  pp_print_flush ,
  print_flush ,
  pp_print_newline ,
  print_newline ,
  pp_set_margin ,
  set_margin ,
  pp_get_margin ,
  get_margin ,
  pp_set_max_indent ,
  set_max_indent ,
  pp_get_max_indent ,
  get_max_indent ,
  check_geometry ,
  pp_set_geometry ,
  set_geometry ,
  pp_safe_set_geometry ,
  safe_set_geometry ,
  pp_update_geometry ,
  update_geometry ,
  pp_get_geometry ,
  get_geometry ,
  pp_set_max_boxes ,
  set_max_boxes ,
  pp_get_max_boxes ,
  get_max_boxes ,
  pp_over_max_boxes ,
  over_max_boxes ,
  pp_open_tbox ,
  open_tbox ,
  pp_close_tbox ,
  close_tbox ,
  pp_set_tab ,
  set_tab ,
  pp_print_tab ,
  print_tab ,
  pp_print_tbreak ,
  print_tbreak ,
  pp_set_ellipsis_text ,
  set_ellipsis_text ,
  pp_get_ellipsis_text ,
  get_ellipsis_text ,
  String_tag ,
  pp_open_stag ,
  open_stag ,
  pp_close_stag ,
  close_stag ,
  pp_set_tags ,
  set_tags ,
  pp_set_print_tags ,
  set_print_tags ,
  pp_set_mark_tags ,
  set_mark_tags ,
  pp_get_print_tags ,
  get_print_tags ,
  pp_get_mark_tags ,
  get_mark_tags ,
  pp_set_formatter_out_channel ,
  set_formatter_out_channel ,
  pp_set_formatter_output_functions ,
  set_formatter_output_functions ,
  pp_get_formatter_output_functions ,
  get_formatter_output_functions ,
  pp_set_formatter_out_functions ,
  set_formatter_out_functions ,
  pp_get_formatter_out_functions ,
  get_formatter_out_functions ,
  pp_set_formatter_stag_functions ,
  set_formatter_stag_functions ,
  pp_get_formatter_stag_functions ,
  get_formatter_stag_functions ,
  formatter_of_out_channel ,
  synchronized_formatter_of_out_channel ,
  std_formatter ,
  get_std_formatter ,
  err_formatter ,
  get_err_formatter ,
  formatter_of_buffer ,
  stdbuf ,
  get_stdbuf ,
  str_formatter ,
  get_str_formatter ,
  flush_str_formatter ,
  make_formatter ,
  make_synchronized_formatter ,
  formatter_of_out_functions ,
  make_symbolic_output_buffer ,
  clear_symbolic_output_buffer ,
  get_symbolic_output_buffer ,
  flush_symbolic_output_buffer ,
  add_symbolic_output_item ,
  formatter_of_symbolic_output_buffer ,
  pp_print_iter ,
  pp_print_list ,
  pp_print_array ,
  pp_print_seq ,
  pp_print_text ,
  pp_print_option ,
  pp_print_result ,
  pp_print_either ,
  fprintf ,
  printf ,
  eprintf ,
  sprintf ,
  asprintf ,
  dprintf ,
  ifprintf ,
  kfprintf ,
  kdprintf ,
  ikfprintf ,
  ksprintf ,
  kasprintf ,
}
/* blank_line Not a pure module */
`,zu=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Printexc from "./printexc.js";

function $$const(c, param) {
  return c;
}

function flip(f, x, y) {
  return Curry._2(f, y, x);
}

function negate(p, v) {
  return !Curry._1(p, v);
}

var Finally_raised = /* @__PURE__ */Caml_exceptions.create("Stdlib.Fun.Finally_raised");

Stdlib__Printexc.register_printer(function (param) {
      if (param.MEL_EXN_ID === Finally_raised) {
        return "Fun.Finally_raised: " + Stdlib__Printexc.to_string(param._1);
      }
      
    });

function protect($$finally, work) {
  var finally_no_exn = function (param) {
    try {
      return Curry._1($$finally, undefined);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      var bt;
      var exn = {
        MEL_EXN_ID: Finally_raised,
        _1: e
      };
      Caml_external_polyfill.resolve("caml_restore_raw_backtrace")(exn, bt);
      throw exn;
    }
  };
  var result;
  try {
    result = Curry._1(work, undefined);
  }
  catch (raw_work_exn){
    var work_exn = Caml_js_exceptions.internalToOCamlException(raw_work_exn);
    var work_bt;
    finally_no_exn(undefined);
    Caml_external_polyfill.resolve("caml_restore_raw_backtrace")(work_exn, work_bt);
    throw work_exn;
  }
  finally_no_exn(undefined);
  return result;
}

export {
  $$const ,
  flip ,
  negate ,
  protect ,
  Finally_raised ,
}
/*  Not a pure module */
`,Fu=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Sys from "./sys.js";

function eventlog_pause(param) {
  
}

function eventlog_resume(param) {
  
}

function print_stat(c) {
  var st = Caml_external_polyfill.resolve("caml_gc_stat")(undefined);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "minor_collections:      ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "minor_collections:      %d\\n"
          }), st.minor_collections);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "major_collections:      ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "major_collections:      %d\\n"
          }), st.major_collections);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "compactions:            ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "compactions:            %d\\n"
          }), st.compactions);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "forced_major_collections: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "forced_major_collections: %d\\n"
          }), st.forced_major_collections);
  Stdlib__Printf.fprintf(c, /* Format */{
        _0: {
          TAG: /* Char_literal */12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */0
        },
        _1: "\\n"
      });
  var l1 = Curry._1(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* Float */8,
              _0: [
                /* Float_flag_ */0,
                /* Float_f */0
              ],
              _1: /* No_padding */0,
              _2: /* Lit_precision */{
                _0: 0
              },
              _3: /* End_of_format */0
            },
            _1: "%.0f"
          }), st.minor_words).length;
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "minor_words:    ",
              _1: {
                TAG: /* Float */8,
                _0: [
                  /* Float_flag_ */0,
                  /* Float_f */0
                ],
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* Lit_precision */{
                  _0: 0
                },
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "minor_words:    %*.0f\\n"
          }), l1, st.minor_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "promoted_words: ",
              _1: {
                TAG: /* Float */8,
                _0: [
                  /* Float_flag_ */0,
                  /* Float_f */0
                ],
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* Lit_precision */{
                  _0: 0
                },
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "promoted_words: %*.0f\\n"
          }), l1, st.promoted_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "major_words:    ",
              _1: {
                TAG: /* Float */8,
                _0: [
                  /* Float_flag_ */0,
                  /* Float_f */0
                ],
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* Lit_precision */{
                  _0: 0
                },
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "major_words:    %*.0f\\n"
          }), l1, st.major_words);
  Stdlib__Printf.fprintf(c, /* Format */{
        _0: {
          TAG: /* Char_literal */12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */0
        },
        _1: "\\n"
      });
  var l2 = Curry._1(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* Int */4,
              _0: /* Int_d */0,
              _1: /* No_padding */0,
              _2: /* No_precision */0,
              _3: /* End_of_format */0
            },
            _1: "%d"
          }), st.top_heap_words).length;
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "top_heap_words: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "top_heap_words: %*d\\n"
          }), l2, st.top_heap_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "heap_words:     ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "heap_words:     %*d\\n"
          }), l2, st.heap_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "live_words:     ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "live_words:     %*d\\n"
          }), l2, st.live_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "free_words:     ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "free_words:     %*d\\n"
          }), l2, st.free_words);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "largest_free:   ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "largest_free:   %*d\\n"
          }), l2, st.largest_free);
  Curry._2(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "fragments:      ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: {
                  TAG: /* Arg_padding */1,
                  _0: /* Right */1
                },
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "fragments:      %*d\\n"
          }), l2, st.fragments);
  Stdlib__Printf.fprintf(c, /* Format */{
        _0: {
          TAG: /* Char_literal */12,
          _0: /* '\\n' */10,
          _1: /* End_of_format */0
        },
        _1: "\\n"
      });
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "live_blocks: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "live_blocks: %d\\n"
          }), st.live_blocks);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "free_blocks: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "free_blocks: %d\\n"
          }), st.free_blocks);
  Curry._1(Stdlib__Printf.fprintf(c, /* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "heap_chunks: ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "heap_chunks: %d\\n"
          }), st.heap_chunks);
}

function allocated_bytes(param) {
  var match = Caml_external_polyfill.resolve("caml_gc_counters")(undefined);
  return (match[0] + match[2] - match[1]) * (Stdlib__Sys.word_size / 8 | 0);
}

function call_alarm(arec) {
  if (!Stdlib__Atomic.get(arec.active)) {
    return ;
  }
  var $$finally = function (param) {
    Caml_external_polyfill.resolve("caml_final_register")(call_alarm, arec);
  };
  Stdlib__Fun.protect($$finally, arec.f);
}

function create_alarm(f) {
  var arec_active = Stdlib__Atomic.make(true);
  var arec = {
    active: arec_active,
    f: f
  };
  Caml_external_polyfill.resolve("caml_final_register")(call_alarm, arec);
  return arec_active;
}

function delete_alarm(a) {
  Stdlib__Atomic.set(a, false);
}

function null_tracker_alloc_minor(param) {
  
}

function null_tracker_alloc_major(param) {
  
}

function null_tracker_promote(param) {
  
}

function null_tracker_dealloc_minor(param) {
  
}

function null_tracker_dealloc_major(param) {
  
}

var null_tracker = {
  alloc_minor: null_tracker_alloc_minor,
  alloc_major: null_tracker_alloc_major,
  promote: null_tracker_promote,
  dealloc_minor: null_tracker_dealloc_minor,
  dealloc_major: null_tracker_dealloc_major
};

function start(sampling_rate, callstack_sizeOpt, tracker) {
  var callstack_size = callstack_sizeOpt !== undefined ? callstack_sizeOpt : Stdlib.max_int;
  Caml_external_polyfill.resolve("caml_memprof_start")(sampling_rate, callstack_size, tracker);
}

function finalise(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_final_register")(prim0, prim1);
}

function finalise_last(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_final_register_called_without_value")(prim0, prim1);
}

function finalise_release(prim) {
  return Caml_external_polyfill.resolve("caml_final_release")(prim);
}

function Memprof_stop(prim) {
  return Caml_external_polyfill.resolve("caml_memprof_stop")(prim);
}

var Memprof = {
  null_tracker: null_tracker,
  start: start,
  stop: Memprof_stop
};

export {
  print_stat ,
  allocated_bytes ,
  finalise ,
  finalise_last ,
  finalise_release ,
  create_alarm ,
  delete_alarm ,
  eventlog_pause ,
  eventlog_resume ,
  Memprof ,
}
/* Stdlib__Fun Not a pure module */
`,Bu=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Domain from "./domain.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__Seq from "./seq.js";

function flip_ongoing_traversal(h) {
  h.initial_size = -h.initial_size | 0;
}

var randomized = Stdlib__Atomic.make(false);

function randomize(param) {
  Stdlib__Atomic.set(randomized, true);
}

function is_randomized(param) {
  return Stdlib__Atomic.get(randomized);
}

var prng_key = Stdlib__Domain.DLS.new_key(undefined, Stdlib__Random.State.make_self_init);

function power_2_above(_x, n) {
  while(true) {
    var x = _x;
    if (x >= n) {
      return x;
    }
    if ((x << 1) < x) {
      return x;
    }
    _x = (x << 1);
    continue ;
  };
}

function create(randomOpt, initial_size) {
  var random = randomOpt !== undefined ? randomOpt : Stdlib__Atomic.get(randomized);
  var s = power_2_above(16, initial_size);
  var seed = random ? Stdlib__Random.State.bits(Stdlib__Domain.DLS.get(prng_key)) : 0;
  return {
          size: 0,
          data: Caml_array.make(s, /* Empty */0),
          seed: seed,
          initial_size: s
        };
}

function clear(h) {
  if (h.size > 0) {
    h.size = 0;
    return Stdlib__Array.fill(h.data, 0, h.data.length, /* Empty */0);
  }
  
}

function reset(h) {
  var len = h.data.length;
  if (len === Stdlib.abs(h.initial_size)) {
    return clear(h);
  } else {
    h.size = 0;
    h.data = Caml_array.make(Stdlib.abs(h.initial_size), /* Empty */0);
    return ;
  }
}

function copy_bucketlist(param) {
  if (!param) {
    return /* Empty */0;
  }
  var key = param.key;
  var data = param.data;
  var next = param.next;
  var loop = function (_prec, _param) {
    while(true) {
      var param = _param;
      var prec = _prec;
      if (!param) {
        return ;
      }
      var key = param.key;
      var data = param.data;
      var next = param.next;
      var r = /* Cons */{
        key: key,
        data: data,
        next: next
      };
      if (prec) {
        prec.next = r;
      } else {
        throw {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "hashtbl.cppo.ml",
                110,
                23
              ],
              Error: new Error()
            };
      }
      _param = next;
      _prec = r;
      continue ;
    };
  };
  var r = /* Cons */{
    key: key,
    data: data,
    next: next
  };
  loop(r, next);
  return r;
}

function copy(h) {
  return {
          size: h.size,
          data: Stdlib__Array.map(copy_bucketlist, h.data),
          seed: h.seed,
          initial_size: h.initial_size
        };
}

function length(h) {
  return h.size;
}

function insert_all_buckets(indexfun, inplace, odata, ndata) {
  var nsize = ndata.length;
  var ndata_tail = Caml_array.make(nsize, /* Empty */0);
  var insert_bucket = function (_cell) {
    while(true) {
      var cell = _cell;
      if (!cell) {
        return ;
      }
      var key = cell.key;
      var data = cell.data;
      var next = cell.next;
      var cell$1 = inplace ? cell : /* Cons */({
            key: key,
            data: data,
            next: /* Empty */0
          });
      var nidx = Curry._1(indexfun, key);
      var tail = Caml_array.get(ndata_tail, nidx);
      if (tail) {
        tail.next = cell$1;
      } else {
        Caml_array.set(ndata, nidx, cell$1);
      }
      Caml_array.set(ndata_tail, nidx, cell$1);
      _cell = next;
      continue ;
    };
  };
  for(var i = 0 ,i_finish = odata.length; i < i_finish; ++i){
    insert_bucket(Caml_array.get(odata, i));
  }
  if (!inplace) {
    return ;
  }
  for(var i$1 = 0; i$1 < nsize; ++i$1){
    var tail = Caml_array.get(ndata_tail, i$1);
    if (tail) {
      tail.next = /* Empty */0;
    }
    
  }
}

function resize(indexfun, h) {
  var odata = h.data;
  var osize = odata.length;
  var nsize = (osize << 1);
  if (nsize < osize) {
    return ;
  }
  var ndata = Caml_array.make(nsize, /* Empty */0);
  var inplace = h.initial_size >= 0;
  h.data = ndata;
  insert_all_buckets(Curry._1(indexfun, h), inplace, odata, ndata);
}

function iter(f, h) {
  var do_bucket = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var key = param.key;
      var data = param.data;
      var next = param.next;
      Curry._2(f, key, data);
      _param = next;
      continue ;
    };
  };
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
    if (!old_trav) {
      return flip_ongoing_traversal(h);
    } else {
      return ;
    }
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function filter_map_inplace_bucket(f, h, i, _prec, _slot) {
  while(true) {
    var slot = _slot;
    var prec = _prec;
    if (!slot) {
      if (prec) {
        prec.next = /* Empty */0;
        return ;
      } else {
        return Caml_array.set(h.data, i, /* Empty */0);
      }
    }
    var key = slot.key;
    var data = slot.data;
    var next = slot.next;
    var data$1 = Curry._2(f, key, data);
    if (data$1 !== undefined) {
      if (prec) {
        prec.next = slot;
      } else {
        Caml_array.set(h.data, i, slot);
      }
      slot.data = Caml_option.valFromOption(data$1);
      _slot = next;
      _prec = slot;
      continue ;
    }
    h.size = h.size - 1 | 0;
    _slot = next;
    continue ;
  };
}

function filter_map_inplace(f, h) {
  var d = h.data;
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      filter_map_inplace_bucket(f, h, i, /* Empty */0, Caml_array.get(h.data, i));
    }
    if (!old_trav) {
      return flip_ongoing_traversal(h);
    } else {
      return ;
    }
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function fold(f, h, init) {
  var do_bucket = function (_b, _accu) {
    while(true) {
      var accu = _accu;
      var b = _b;
      if (!b) {
        return accu;
      }
      var key = b.key;
      var data = b.data;
      var next = b.next;
      _accu = Curry._3(f, key, data, accu);
      _b = next;
      continue ;
    };
  };
  var old_trav = h.initial_size < 0;
  if (!old_trav) {
    flip_ongoing_traversal(h);
  }
  try {
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    if (!old_trav) {
      flip_ongoing_traversal(h);
    }
    return accu;
  }
  catch (exn){
    if (old_trav) {
      throw exn;
    }
    flip_ongoing_traversal(h);
    throw exn;
  }
}

function bucket_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    var next = param.next;
    _param = next;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function stats(h) {
  var mbl = Stdlib__Array.fold_left((function (m, b) {
          return Stdlib__Int.max(m, bucket_length(0, b));
        }), 0, h.data);
  var histo = Caml_array.make(mbl + 1 | 0, 0);
  Stdlib__Array.iter((function (b) {
          var l = bucket_length(0, b);
          Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
        }), h.data);
  return {
          num_bindings: h.size,
          num_buckets: h.data.length,
          max_bucket_length: mbl,
          bucket_histogram: histo
        };
}

function to_seq(tbl) {
  var tbl_data = tbl.data;
  var aux = function (_i, _buck, _param) {
    while(true) {
      var buck = _buck;
      var i = _i;
      if (buck) {
        var key = buck.key;
        var data = buck.data;
        var next = buck.next;
        return /* Cons */{
                _0: [
                  key,
                  data
                ],
                _1: (function(i,next){
                return function (param) {
                  return aux(i, next, param);
                }
                }(i,next))
              };
      }
      if (i === tbl_data.length) {
        return /* Nil */0;
      }
      _param = undefined;
      _buck = Caml_array.get(tbl_data, i);
      _i = i + 1 | 0;
      continue ;
    };
  };
  return function (param) {
    return aux(0, /* Empty */0, param);
  };
}

function to_seq_keys(m) {
  var partial_arg = to_seq(m);
  return function (param) {
    return Stdlib__Seq.map((function (prim) {
                  return prim[0];
                }), partial_arg, param);
  };
}

function to_seq_values(m) {
  var partial_arg = to_seq(m);
  return function (param) {
    return Stdlib__Seq.map((function (prim) {
                  return prim[1];
                }), partial_arg, param);
  };
}

function MakeSeeded(H) {
  var key_index = function (h, key) {
    return Curry._2(H.seeded_hash, h.seed, key) & (h.data.length - 1 | 0);
  };
  var add = function (h, key, data) {
    var i = key_index(h, key);
    var bucket = /* Cons */{
      key: key,
      data: data,
      next: Caml_array.get(h.data, i)
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    }
    
  };
  var remove = function (h, key) {
    var i = key_index(h, key);
    var _prec = /* Empty */0;
    var _c = Caml_array.get(h.data, i);
    while(true) {
      var c = _c;
      var prec = _prec;
      if (!c) {
        return ;
      }
      var k = c.key;
      var next = c.next;
      if (Curry._2(H.equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (prec) {
          prec.next = next;
          return ;
        } else {
          return Caml_array.set(h.data, i, next);
        }
      }
      _c = next;
      _prec = c;
      continue ;
    };
  };
  var find = function (h, key) {
    var match = Caml_array.get(h.data, key_index(h, key));
    if (match) {
      var k1 = match.key;
      var d1 = match.data;
      var next1 = match.next;
      if (Curry._2(H.equal, key, k1)) {
        return d1;
      }
      if (next1) {
        var k2 = next1.key;
        var d2 = next1.data;
        var next2 = next1.next;
        if (Curry._2(H.equal, key, k2)) {
          return d2;
        }
        if (next2) {
          var k3 = next2.key;
          var d3 = next2.data;
          var next3 = next2.next;
          if (Curry._2(H.equal, key, k3)) {
            return d3;
          } else {
            var _param = next3;
            while(true) {
              var param = _param;
              if (param) {
                var k = param.key;
                var data = param.data;
                var next = param.next;
                if (Curry._2(H.equal, key, k)) {
                  return data;
                }
                _param = next;
                continue ;
              }
              throw {
                    MEL_EXN_ID: Stdlib.Not_found,
                    Error: new Error()
                  };
            };
          }
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
  var find_opt = function (h, key) {
    var match = Caml_array.get(h.data, key_index(h, key));
    if (!match) {
      return ;
    }
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (Curry._2(H.equal, key, k1)) {
      return Caml_option.some(d1);
    }
    if (!next1) {
      return ;
    }
    var k2 = next1.key;
    var d2 = next1.data;
    var next2 = next1.next;
    if (Curry._2(H.equal, key, k2)) {
      return Caml_option.some(d2);
    }
    if (!next2) {
      return ;
    }
    var k3 = next2.key;
    var d3 = next2.data;
    var next3 = next2.next;
    if (Curry._2(H.equal, key, k3)) {
      return Caml_option.some(d3);
    } else {
      var _param = next3;
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var k = param.key;
        var data = param.data;
        var next = param.next;
        if (Curry._2(H.equal, key, k)) {
          return Caml_option.some(data);
        }
        _param = next;
        continue ;
      };
    }
  };
  var find_all = function (h, key) {
    var find_in_bucket_dps = function (_dst, _offset, _param) {
      while(true) {
        var dst = _dst;
        var offset = _offset;
        var param = _param;
        if (!param) {
          dst[offset] = /* [] */0;
          return ;
        }
        var k = param.key;
        var d = param.data;
        var next = param.next;
        if (Curry._2(H.equal, k, key)) {
          var block = {
            hd: d,
            tl: 24029
          };
          dst[offset] = block;
          _param = next;
          _offset = "tl";
          _dst = block;
          continue ;
        }
        _param = next;
        continue ;
      };
    };
    var _param = Caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var k = param.key;
      var d = param.data;
      var next = param.next;
      if (Curry._2(H.equal, k, key)) {
        var block = {
          hd: d,
          tl: 24029
        };
        find_in_bucket_dps(block, "tl", next);
        return block;
      }
      _param = next;
      continue ;
    };
  };
  var replace_bucket = function (key, data, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return true;
      }
      var k = param.key;
      var next = param.next;
      if (Curry._2(H.equal, k, key)) {
        param.key = key;
        param.data = data;
        return false;
      }
      _param = next;
      continue ;
    };
  };
  var replace = function (h, key, data) {
    var i = key_index(h, key);
    var l = Caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      Caml_array.set(h.data, i, /* Cons */{
            key: key,
            data: data,
            next: l
          });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize(key_index, h);
      } else {
        return ;
      }
    }
    
  };
  var mem = function (h, key) {
    var _param = Caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var k = param.key;
      var next = param.next;
      if (Curry._2(H.equal, k, key)) {
        return true;
      }
      _param = next;
      continue ;
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq
        };
}

function Make(H) {
  var equal = H.equal;
  var key_index = function (h, key) {
    return Curry._1(H.hash, key) & (h.data.length - 1 | 0);
  };
  var add = function (h, key, data) {
    var i = key_index(h, key);
    var bucket = /* Cons */{
      key: key,
      data: data,
      next: Caml_array.get(h.data, i)
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    }
    
  };
  var remove = function (h, key) {
    var i = key_index(h, key);
    var _prec = /* Empty */0;
    var _c = Caml_array.get(h.data, i);
    while(true) {
      var c = _c;
      var prec = _prec;
      if (!c) {
        return ;
      }
      var k = c.key;
      var next = c.next;
      if (Curry._2(equal, k, key)) {
        h.size = h.size - 1 | 0;
        if (prec) {
          prec.next = next;
          return ;
        } else {
          return Caml_array.set(h.data, i, next);
        }
      }
      _c = next;
      _prec = c;
      continue ;
    };
  };
  var find = function (h, key) {
    var match = Caml_array.get(h.data, key_index(h, key));
    if (match) {
      var k1 = match.key;
      var d1 = match.data;
      var next1 = match.next;
      if (Curry._2(equal, key, k1)) {
        return d1;
      }
      if (next1) {
        var k2 = next1.key;
        var d2 = next1.data;
        var next2 = next1.next;
        if (Curry._2(equal, key, k2)) {
          return d2;
        }
        if (next2) {
          var k3 = next2.key;
          var d3 = next2.data;
          var next3 = next2.next;
          if (Curry._2(equal, key, k3)) {
            return d3;
          } else {
            var _param = next3;
            while(true) {
              var param = _param;
              if (param) {
                var k = param.key;
                var data = param.data;
                var next = param.next;
                if (Curry._2(equal, key, k)) {
                  return data;
                }
                _param = next;
                continue ;
              }
              throw {
                    MEL_EXN_ID: Stdlib.Not_found,
                    Error: new Error()
                  };
            };
          }
        }
        throw {
              MEL_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
  var find_opt = function (h, key) {
    var match = Caml_array.get(h.data, key_index(h, key));
    if (!match) {
      return ;
    }
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (Curry._2(equal, key, k1)) {
      return Caml_option.some(d1);
    }
    if (!next1) {
      return ;
    }
    var k2 = next1.key;
    var d2 = next1.data;
    var next2 = next1.next;
    if (Curry._2(equal, key, k2)) {
      return Caml_option.some(d2);
    }
    if (!next2) {
      return ;
    }
    var k3 = next2.key;
    var d3 = next2.data;
    var next3 = next2.next;
    if (Curry._2(equal, key, k3)) {
      return Caml_option.some(d3);
    } else {
      var _param = next3;
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var k = param.key;
        var data = param.data;
        var next = param.next;
        if (Curry._2(equal, key, k)) {
          return Caml_option.some(data);
        }
        _param = next;
        continue ;
      };
    }
  };
  var find_all = function (h, key) {
    var find_in_bucket_dps = function (_dst, _offset, _param) {
      while(true) {
        var param = _param;
        var offset = _offset;
        var dst = _dst;
        if (!param) {
          dst[offset] = /* [] */0;
          return ;
        }
        var k = param.key;
        var d = param.data;
        var next = param.next;
        if (Curry._2(equal, k, key)) {
          var block = {
            hd: d,
            tl: 24029
          };
          dst[offset] = block;
          _param = next;
          _offset = "tl";
          _dst = block;
          continue ;
        }
        _param = next;
        continue ;
      };
    };
    var _param = Caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var k = param.key;
      var d = param.data;
      var next = param.next;
      if (Curry._2(equal, k, key)) {
        var block = {
          hd: d,
          tl: 24029
        };
        find_in_bucket_dps(block, "tl", next);
        return block;
      }
      _param = next;
      continue ;
    };
  };
  var replace_bucket = function (key, data, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return true;
      }
      var k = param.key;
      var next = param.next;
      if (Curry._2(equal, k, key)) {
        param.key = key;
        param.data = data;
        return false;
      }
      _param = next;
      continue ;
    };
  };
  var replace = function (h, key, data) {
    var i = key_index(h, key);
    var l = Caml_array.get(h.data, i);
    if (replace_bucket(key, data, l)) {
      Caml_array.set(h.data, i, /* Cons */{
            key: key,
            data: data,
            next: l
          });
      h.size = h.size + 1 | 0;
      if (h.size > (h.data.length << 1)) {
        return resize(key_index, h);
      } else {
        return ;
      }
    }
    
  };
  var mem = function (h, key) {
    var _param = Caml_array.get(h.data, key_index(h, key));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var k = param.key;
      var next = param.next;
      if (Curry._2(equal, k, key)) {
        return true;
      }
      _param = next;
      continue ;
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$1 = function (sz) {
    return create(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq
        };
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function hash_param(n1, n2, x) {
  return Caml_hash.caml_hash(n1, n2, 0, x);
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function key_index(h, key) {
  return Caml_hash.caml_hash(10, 100, h.seed, key) & (h.data.length - 1 | 0);
}

function add(h, key, data) {
  var i = key_index(h, key);
  var bucket = /* Cons */{
    key: key,
    data: data,
    next: Caml_array.get(h.data, i)
  };
  Caml_array.set(h.data, i, bucket);
  h.size = h.size + 1 | 0;
  if (h.size > (h.data.length << 1)) {
    return resize(key_index, h);
  }
  
}

function remove(h, key) {
  var i = key_index(h, key);
  var _prec = /* Empty */0;
  var _c = Caml_array.get(h.data, i);
  while(true) {
    var c = _c;
    var prec = _prec;
    if (!c) {
      return ;
    }
    var k = c.key;
    var next = c.next;
    if (Caml_obj.caml_equal(k, key)) {
      h.size = h.size - 1 | 0;
      if (prec) {
        prec.next = next;
        return ;
      } else {
        return Caml_array.set(h.data, i, next);
      }
    }
    _c = next;
    _prec = c;
    continue ;
  };
}

function find(h, key) {
  var match = Caml_array.get(h.data, key_index(h, key));
  if (match) {
    var k1 = match.key;
    var d1 = match.data;
    var next1 = match.next;
    if (Caml_obj.caml_equal(key, k1)) {
      return d1;
    }
    if (next1) {
      var k2 = next1.key;
      var d2 = next1.data;
      var next2 = next1.next;
      if (Caml_obj.caml_equal(key, k2)) {
        return d2;
      }
      if (next2) {
        var k3 = next2.key;
        var d3 = next2.data;
        var next3 = next2.next;
        if (Caml_obj.caml_equal(key, k3)) {
          return d3;
        } else {
          var _param = next3;
          while(true) {
            var param = _param;
            if (param) {
              var k = param.key;
              var data = param.data;
              var next = param.next;
              if (Caml_obj.caml_equal(key, k)) {
                return data;
              }
              _param = next;
              continue ;
            }
            throw {
                  MEL_EXN_ID: Stdlib.Not_found,
                  Error: new Error()
                };
          };
        }
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  }
  throw {
        MEL_EXN_ID: Stdlib.Not_found,
        Error: new Error()
      };
}

function find_opt(h, key) {
  var match = Caml_array.get(h.data, key_index(h, key));
  if (!match) {
    return ;
  }
  var k1 = match.key;
  var d1 = match.data;
  var next1 = match.next;
  if (Caml_obj.caml_equal(key, k1)) {
    return Caml_option.some(d1);
  }
  if (!next1) {
    return ;
  }
  var k2 = next1.key;
  var d2 = next1.data;
  var next2 = next1.next;
  if (Caml_obj.caml_equal(key, k2)) {
    return Caml_option.some(d2);
  }
  if (!next2) {
    return ;
  }
  var k3 = next2.key;
  var d3 = next2.data;
  var next3 = next2.next;
  if (Caml_obj.caml_equal(key, k3)) {
    return Caml_option.some(d3);
  } else {
    var _param = next3;
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var k = param.key;
      var data = param.data;
      var next = param.next;
      if (Caml_obj.caml_equal(key, k)) {
        return Caml_option.some(data);
      }
      _param = next;
      continue ;
    };
  }
}

function find_all(h, key) {
  var find_in_bucket_dps = function (_dst, _offset, _param) {
    while(true) {
      var dst = _dst;
      var offset = _offset;
      var param = _param;
      if (!param) {
        dst[offset] = /* [] */0;
        return ;
      }
      var k = param.key;
      var data = param.data;
      var next = param.next;
      if (Caml_obj.caml_equal(k, key)) {
        var block = {
          hd: data,
          tl: 24029
        };
        dst[offset] = block;
        _param = next;
        _offset = "tl";
        _dst = block;
        continue ;
      }
      _param = next;
      continue ;
    };
  };
  var _param = Caml_array.get(h.data, key_index(h, key));
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var k = param.key;
    var data = param.data;
    var next = param.next;
    if (Caml_obj.caml_equal(k, key)) {
      var block = {
        hd: data,
        tl: 24029
      };
      find_in_bucket_dps(block, "tl", next);
      return block;
    }
    _param = next;
    continue ;
  };
}

function replace_bucket(key, data, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    var k = param.key;
    var next = param.next;
    if (Caml_obj.caml_equal(k, key)) {
      param.key = key;
      param.data = data;
      return false;
    }
    _param = next;
    continue ;
  };
}

function replace(h, key, data) {
  var i = key_index(h, key);
  var l = Caml_array.get(h.data, i);
  if (replace_bucket(key, data, l)) {
    Caml_array.set(h.data, i, /* Cons */{
          key: key,
          data: data,
          next: l
        });
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(key_index, h);
    } else {
      return ;
    }
  }
  
}

function mem(h, key) {
  var _param = Caml_array.get(h.data, key_index(h, key));
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var k = param.key;
    var next = param.next;
    if (Caml_obj.caml_equal(k, key)) {
      return true;
    }
    _param = next;
    continue ;
  };
}

function add_seq(tbl, i) {
  Stdlib__Seq.iter((function (param) {
          add(tbl, param[0], param[1]);
        }), i);
}

function replace_seq(tbl, i) {
  Stdlib__Seq.iter((function (param) {
          replace(tbl, param[0], param[1]);
        }), i);
}

function of_seq(i) {
  var tbl = create(undefined, 16);
  replace_seq(tbl, i);
  return tbl;
}

function rebuild(randomOpt, h) {
  var random = randomOpt !== undefined ? randomOpt : Stdlib__Atomic.get(randomized);
  var s = power_2_above(16, h.data.length);
  var seed = random ? Stdlib__Random.State.bits(Stdlib__Domain.DLS.get(prng_key)) : h.seed;
  var h$p = {
    size: h.size,
    data: Caml_array.make(s, /* Empty */0),
    seed: seed,
    initial_size: h.initial_size
  };
  insert_all_buckets((function (param) {
          return key_index(h$p, param);
        }), false, h.data, h$p.data);
  return h$p;
}

var seeded_hash_param = Caml_hash.caml_hash;

export {
  create ,
  clear ,
  reset ,
  copy ,
  add ,
  find ,
  find_opt ,
  find_all ,
  mem ,
  remove ,
  replace ,
  iter ,
  filter_map_inplace ,
  fold ,
  length ,
  randomize ,
  is_randomized ,
  rebuild ,
  stats ,
  to_seq ,
  to_seq_keys ,
  to_seq_values ,
  add_seq ,
  replace_seq ,
  of_seq ,
  Make ,
  MakeSeeded ,
  hash ,
  seeded_hash ,
  hash_param ,
  seeded_hash_param ,
}
/* randomized Not a pure module */
`,Gu=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__Sys from "./sys.js";

function with_open(openfun, s, f) {
  var ic = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
                Stdlib.close_in_noerr(ic);
              }), (function (param) {
                return Curry._1(f, ic);
              }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_in_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_in, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
                return Stdlib.open_in_gen(flags, perm, param);
              }), s, f);
}

var seek = Stdlib.LargeFile.seek_in;

var pos = Stdlib.LargeFile.pos_in;

var length = Stdlib.LargeFile.in_channel_length;

function input_char(ic) {
  var c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
  return c;
}

function input_byte(ic) {
  var n;
  try {
    n = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
  return n;
}

function input_line(ic) {
  var s;
  try {
    s = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
  return s;
}

function really_input(ic, buf, pos, len) {
  try {
    Stdlib.really_input(ic, buf, pos, len);
    return Caml_option.some(undefined);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
}

function really_input_string(ic, len) {
  var s;
  try {
    s = Stdlib.really_input_string(ic, len);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw exn;
  }
  return s;
}

function read_upto(ic, buf, ofs, len) {
  var loop = function (_ofs, _len) {
    while(true) {
      var len = _len;
      var ofs = _ofs;
      if (len === 0) {
        return ofs;
      }
      var r = Stdlib.input(ic, buf, ofs, len);
      if (r === 0) {
        return ofs;
      }
      _len = len - r | 0;
      _ofs = ofs + r | 0;
      continue ;
    };
  };
  return loop(ofs, len) - ofs | 0;
}

function ensure(buf, ofs, n) {
  var len = buf.length;
  if (len >= (ofs + n | 0)) {
    return buf;
  }
  var new_len = len;
  while(new_len < (ofs + n | 0)) {
    new_len = (new_len << 1) + 1 | 0;
  };
  var new_len$1 = new_len;
  var new_len$2;
  if (new_len$1 <= Stdlib__Sys.max_string_length) {
    new_len$2 = new_len$1;
  } else if (ofs < Stdlib__Sys.max_string_length) {
    new_len$2 = Stdlib__Sys.max_string_length;
  } else {
    throw {
          MEL_EXN_ID: "Failure",
          _1: "In_channel.input_all: channel content is larger than maximum string length",
          Error: new Error()
        };
  }
  var new_buf = Caml_bytes.caml_create_bytes(new_len$2);
  Stdlib__Bytes.blit(buf, 0, new_buf, 0, ofs);
  return new_buf;
}

function input_all(ic) {
  var initial_size;
  try {
    initial_size = Caml_external_polyfill.resolve("caml_ml_channel_size")(ic) - Caml_external_polyfill.resolve("caml_ml_pos_in")(ic) | 0;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Sys_error) {
      initial_size = -1;
    } else {
      throw exn;
    }
  }
  var initial_size$1 = initial_size < 0 ? 65536 : initial_size;
  var initial_size$2 = initial_size$1 <= Stdlib__Sys.max_string_length ? initial_size$1 : Stdlib__Sys.max_string_length;
  var buf = Caml_bytes.caml_create_bytes(initial_size$2);
  var nread = read_upto(ic, buf, 0, initial_size$2);
  if (nread < initial_size$2) {
    return Stdlib__Bytes.sub_string(buf, 0, nread);
  }
  var c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn$1){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.End_of_file) {
      return Caml_bytes.bytes_to_string(buf);
    }
    throw exn$1;
  }
  var buf$1 = ensure(buf, nread, 65537);
  Caml_bytes.set(buf$1, nread, c);
  var _buf = buf$1;
  var _ofs = nread + 1 | 0;
  while(true) {
    var ofs = _ofs;
    var buf$2 = _buf;
    var buf$3 = ensure(buf$2, ofs, 65536);
    var rem = buf$3.length - ofs | 0;
    var r = read_upto(ic, buf$3, ofs, rem);
    if (r < rem) {
      return Stdlib__Bytes.sub_string(buf$3, 0, ofs + r | 0);
    }
    _ofs = ofs + rem | 0;
    _buf = buf$3;
    continue ;
  };
}

function input_lines_dps(_dst, _offset, ic) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        dst[offset] = /* [] */0;
        return ;
      }
      throw exn;
      dst[offset] = undefined;
      dst[offset] = undefined;
      return ;
    }
    var block = {
      hd: line,
      tl: 24029
    };
    dst[offset] = block;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function input_lines(ic) {
  var line;
  try {
    line = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return /* [] */0;
    }
    throw exn;
  }
  var block = {
    hd: line,
    tl: 24029
  };
  input_lines_dps(block, "tl", ic);
  return block;
}

function fold_lines(f, _accu, ic) {
  while(true) {
    var accu = _accu;
    var line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        return accu;
      }
      throw exn;
    }
    _accu = Curry._2(f, accu, line);
    continue ;
  };
}

var stdin = Stdlib.stdin;

var open_bin = Stdlib.open_in_bin;

var open_text = Stdlib.open_in;

var open_gen = Stdlib.open_in_gen;

var close = Stdlib.close_in;

var close_noerr = Stdlib.close_in_noerr;

var input = Stdlib.input;

var set_binary_mode = Stdlib.set_binary_mode_in;

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

export {
  stdin ,
  open_bin ,
  open_text ,
  open_gen ,
  with_open_bin ,
  with_open_text ,
  with_open_gen ,
  close ,
  close_noerr ,
  input_char ,
  input_byte ,
  input_line ,
  really_input_string ,
  input_all ,
  input_lines ,
  input ,
  really_input ,
  fold_lines ,
  seek ,
  pos ,
  length ,
  set_binary_mode ,
  isatty ,
}
/* Stdlib__Fun Not a pure module */
`,Ru=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

var min_int = -2147483648;

function lognot(x) {
  return x ^ -1;
}

function equal(prim0, prim1) {
  return prim0 === prim1;
}

var compare = Caml.caml_int_compare;

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function to_string(x) {
  return Caml_format.caml_format_int("%d", x);
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

var zero = 0;

var one = 1;

var minus_one = -1;

var max_int = 2147483647;

export {
  zero ,
  one ,
  minus_one ,
  abs ,
  max_int ,
  min_int ,
  lognot ,
  equal ,
  compare ,
  min ,
  max ,
  to_string ,
  seeded_hash ,
  hash ,
}
/* No side effect */
`,qu=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Sys from "./sys.js";

function succ(n) {
  return n + 1 | 0;
}

function pred(n) {
  return n - 1 | 0;
}

function abs(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n | 0;
  }
}

function lognot(n) {
  return n ^ -1;
}

var unsigned_to_int;

if (Stdlib__Sys.word_size !== 32) {
  if (Stdlib__Sys.word_size !== 64) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/int32.ml",
            69,
            6
          ],
          Error: new Error()
        };
  }
  unsigned_to_int = (function (n) {
      return n & -1;
    });
} else {
  unsigned_to_int = (function (n) {
      if (0 <= n && n <= Stdlib.max_int) {
        return n;
      }
      
    });
}

function to_string(n) {
  return Caml_format.caml_int32_format("%d", n);
}

function of_string_opt(s) {
  try {
    return Caml_format.caml_int32_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw exn;
  }
}

var compare = Caml.caml_int_compare;

function equal(x, y) {
  return x === y;
}

function unsigned_compare(n, m) {
  return Caml.caml_int_compare(n - -2147483648 | 0, m - -2147483648 | 0);
}

function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (x >= y) {
    return x;
  } else {
    return y;
  }
}

function unsigned_div(n, d) {
  if (d < 0) {
    if (unsigned_compare(n, d) < 0) {
      return 0;
    } else {
      return 1;
    }
  }
  var q = (((n >>> 1) / d | 0) << 1);
  var r = n - Math.imul(q, d) | 0;
  if (unsigned_compare(r, d) >= 0) {
    return q + 1 | 0;
  } else {
    return q;
  }
}

function unsigned_rem(n, d) {
  return n - Math.imul(unsigned_div(n, d), d) | 0;
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

var zero = 0;

var one = 1;

var minus_one = -1;

var max_int = 2147483647;

var min_int = -2147483648;

export {
  zero ,
  one ,
  minus_one ,
  unsigned_div ,
  unsigned_rem ,
  succ ,
  pred ,
  abs ,
  max_int ,
  min_int ,
  lognot ,
  unsigned_to_int ,
  of_string_opt ,
  to_string ,
  compare ,
  unsigned_compare ,
  equal ,
  min ,
  max ,
  seeded_hash ,
  hash ,
}
/* unsigned_to_int Not a pure module */
`,Vu=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib from "./stdlib.js";

var zero = Caml_int64.zero;

var one = Caml_int64.one;

function succ(n) {
  return Caml_int64.add(n, Caml_int64.one);
}

function pred(n) {
  return Caml_int64.sub(n, Caml_int64.one);
}

function abs(n) {
  if (Caml.i64_ge(n, Caml_int64.zero)) {
    return n;
  } else {
    return Caml_int64.neg(n);
  }
}

var min_int = Caml_int64.min_int;

function lognot(n) {
  return Caml_int64.xor(n, Caml_int64.neg_one);
}

var max_int = Caml_int64.of_int32(Stdlib.max_int);

function unsigned_to_int(n) {
  if (Caml_int64.compare(zero, n) <= 0 && Caml_int64.compare(n, max_int) <= 0) {
    return Caml_int64.to_int32(n);
  }
  
}

function to_string(n) {
  return Caml_format.caml_int64_format("%d", n);
}

function of_string_opt(s) {
  try {
    return Caml_format.caml_int64_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw exn;
  }
}

var compare = Caml_int64.compare;

function equal(x, y) {
  return Caml_int64.compare(x, y) === 0;
}

function unsigned_compare(n, m) {
  return Caml_int64.compare(Caml_int64.sub(n, min_int), Caml_int64.sub(m, min_int));
}

function min(x, y) {
  if (Caml.i64_le(x, y)) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (Caml.i64_ge(x, y)) {
    return x;
  } else {
    return y;
  }
}

function unsigned_div(n, d) {
  if (Caml.i64_lt(d, zero)) {
    if (unsigned_compare(n, d) < 0) {
      return zero;
    } else {
      return one;
    }
  }
  var q = Caml_int64.lsl_(Caml_int64.div(Caml_int64.lsr_(n, 1), d), 1);
  var r = Caml_int64.sub(n, Caml_int64.mul(q, d));
  if (unsigned_compare(r, d) >= 0) {
    return Caml_int64.add(q, Caml_int64.one);
  } else {
    return q;
  }
}

function unsigned_rem(n, d) {
  return Caml_int64.sub(n, Caml_int64.mul(unsigned_div(n, d), d));
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

var minus_one = Caml_int64.neg_one;

var max_int$1 = Caml_int64.max_int;

export {
  zero ,
  one ,
  minus_one ,
  unsigned_div ,
  unsigned_rem ,
  succ ,
  pred ,
  abs ,
  max_int$1 as max_int,
  min_int ,
  lognot ,
  unsigned_to_int ,
  of_string_opt ,
  to_string ,
  compare ,
  unsigned_compare ,
  equal ,
  min ,
  max ,
  seeded_hash ,
  hash ,
}
/* No side effect */
`,Xu=`// Generated by Melange

import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";

function from_fun(f) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return Curry._1(f, undefined);
            })
        };
}

function from_val(v) {
  return {
          LAZY_DONE: true,
          VAL: v
        };
}

function map(f, x) {
  return {
          LAZY_DONE: false,
          VAL: (function () {
              return Curry._1(f, CamlinternalLazy.force(x));
            })
        };
}

function map_val(f, x) {
  if (CamlinternalLazy.is_val(x)) {
    return {
            LAZY_DONE: true,
            VAL: Curry._1(f, CamlinternalLazy.force(x))
          };
  } else {
    return {
            LAZY_DONE: false,
            VAL: (function () {
                return Curry._1(f, CamlinternalLazy.force(x));
              })
          };
  }
}

var Undefined = CamlinternalLazy.Undefined;

var is_val = CamlinternalLazy.is_val;

var force_val = CamlinternalLazy.force_val;

export {
  Undefined ,
  map ,
  is_val ,
  from_val ,
  map_val ,
  from_fun ,
  force_val ,
}
/* No side effect */
`,Uu=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_lexer from "melange.js/caml_lexer.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";

var dummy_pos = {
  pos_fname: "",
  pos_lnum: 0,
  pos_bol: 0,
  pos_cnum: -1
};

function engine(tbl, state, buf) {
  var result = Caml_lexer.caml_lex_engine(tbl, state, buf);
  if (result >= 0 && buf.lex_curr_p !== dummy_pos) {
    buf.lex_start_p = buf.lex_curr_p;
    var init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

function new_engine(tbl, state, buf) {
  var result = Caml_lexer.caml_new_lex_engine(tbl, state, buf);
  if (result >= 0 && buf.lex_curr_p !== dummy_pos) {
    buf.lex_start_p = buf.lex_curr_p;
    var init = buf.lex_curr_p;
    buf.lex_curr_p = {
      pos_fname: init.pos_fname,
      pos_lnum: init.pos_lnum,
      pos_bol: init.pos_bol,
      pos_cnum: buf.lex_abs_pos + buf.lex_curr_pos | 0
    };
  }
  return result;
}

var zero_pos = {
  pos_fname: "",
  pos_lnum: 1,
  pos_bol: 0,
  pos_cnum: 0
};

function from_function(with_positionsOpt, f) {
  var with_positions = with_positionsOpt !== undefined ? with_positionsOpt : true;
  var partial_arg = Caml_bytes.caml_create_bytes(512);
  return {
          refill_buff: (function (param) {
              var read = Curry._2(f, partial_arg, partial_arg.length);
              var n = read > 0 ? read : (param.lex_eof_reached = true, 0);
              if ((param.lex_buffer_len + n | 0) > param.lex_buffer.length) {
                if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) <= param.lex_buffer.length) {
                  Stdlib__Bytes.blit(param.lex_buffer, param.lex_start_pos, param.lex_buffer, 0, param.lex_buffer_len - param.lex_start_pos | 0);
                } else {
                  var newlen = (param.lex_buffer.length << 1);
                  if (((param.lex_buffer_len - param.lex_start_pos | 0) + n | 0) > newlen) {
                    throw {
                          MEL_EXN_ID: "Failure",
                          _1: "Lexing.lex_refill: cannot grow buffer",
                          Error: new Error()
                        };
                  }
                  var newbuf = Caml_bytes.caml_create_bytes(newlen);
                  Stdlib__Bytes.blit(param.lex_buffer, param.lex_start_pos, newbuf, 0, param.lex_buffer_len - param.lex_start_pos | 0);
                  param.lex_buffer = newbuf;
                }
                var s = param.lex_start_pos;
                param.lex_abs_pos = param.lex_abs_pos + s | 0;
                param.lex_curr_pos = param.lex_curr_pos - s | 0;
                param.lex_start_pos = 0;
                param.lex_last_pos = param.lex_last_pos - s | 0;
                param.lex_buffer_len = param.lex_buffer_len - s | 0;
                var t = param.lex_mem;
                for(var i = 0 ,i_finish = t.length; i < i_finish; ++i){
                  var v = Caml_array.get(t, i);
                  if (v >= 0) {
                    Caml_array.set(t, i, v - s | 0);
                  }
                  
                }
              }
              Stdlib__Bytes.blit(partial_arg, 0, param.lex_buffer, param.lex_buffer_len, n);
              param.lex_buffer_len = param.lex_buffer_len + n | 0;
            }),
          lex_buffer: Caml_bytes.caml_create_bytes(1024),
          lex_buffer_len: 0,
          lex_abs_pos: 0,
          lex_start_pos: 0,
          lex_curr_pos: 0,
          lex_last_pos: 0,
          lex_last_action: 0,
          lex_eof_reached: false,
          lex_mem: [],
          lex_start_p: with_positions ? zero_pos : dummy_pos,
          lex_curr_p: with_positions ? zero_pos : dummy_pos
        };
}

function from_channel(with_positions, ic) {
  return from_function(with_positions, (function (buf, n) {
                return Stdlib.input(ic, buf, 0, n);
              }));
}

function from_string(with_positionsOpt, s) {
  var with_positions = with_positionsOpt !== undefined ? with_positionsOpt : true;
  return {
          refill_buff: (function (lexbuf) {
              lexbuf.lex_eof_reached = true;
            }),
          lex_buffer: Stdlib__Bytes.of_string(s),
          lex_buffer_len: s.length,
          lex_abs_pos: 0,
          lex_start_pos: 0,
          lex_curr_pos: 0,
          lex_last_pos: 0,
          lex_last_action: 0,
          lex_eof_reached: true,
          lex_mem: [],
          lex_start_p: with_positions ? zero_pos : dummy_pos,
          lex_curr_p: with_positions ? zero_pos : dummy_pos
        };
}

function set_position(lexbuf, position) {
  lexbuf.lex_curr_p = {
    pos_fname: lexbuf.lex_curr_p.pos_fname,
    pos_lnum: position.pos_lnum,
    pos_bol: position.pos_bol,
    pos_cnum: position.pos_cnum
  };
  lexbuf.lex_abs_pos = position.pos_cnum;
}

function set_filename(lexbuf, fname) {
  var init = lexbuf.lex_curr_p;
  lexbuf.lex_curr_p = {
    pos_fname: fname,
    pos_lnum: init.pos_lnum,
    pos_bol: init.pos_bol,
    pos_cnum: init.pos_cnum
  };
}

function with_positions(lexbuf) {
  return lexbuf.lex_curr_p !== dummy_pos;
}

function lexeme(lexbuf) {
  var len = lexbuf.lex_curr_pos - lexbuf.lex_start_pos | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, lexbuf.lex_start_pos, len);
}

function sub_lexeme(lexbuf, i1, i2) {
  var len = i2 - i1 | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_opt(lexbuf, i1, i2) {
  if (i1 < 0) {
    return ;
  }
  var len = i2 - i1 | 0;
  return Stdlib__Bytes.sub_string(lexbuf.lex_buffer, i1, len);
}

function sub_lexeme_char(lexbuf, i) {
  return Caml_bytes.get(lexbuf.lex_buffer, i);
}

function sub_lexeme_char_opt(lexbuf, i) {
  if (i >= 0) {
    return Caml_bytes.get(lexbuf.lex_buffer, i);
  }
  
}

function lexeme_char(lexbuf, i) {
  return Caml_bytes.get(lexbuf.lex_buffer, lexbuf.lex_start_pos + i | 0);
}

function lexeme_start(lexbuf) {
  return lexbuf.lex_start_p.pos_cnum;
}

function lexeme_end(lexbuf) {
  return lexbuf.lex_curr_p.pos_cnum;
}

function lexeme_start_p(lexbuf) {
  return lexbuf.lex_start_p;
}

function lexeme_end_p(lexbuf) {
  return lexbuf.lex_curr_p;
}

function new_line(lexbuf) {
  var lcp = lexbuf.lex_curr_p;
  if (lcp !== dummy_pos) {
    lexbuf.lex_curr_p = {
      pos_fname: lcp.pos_fname,
      pos_lnum: lcp.pos_lnum + 1 | 0,
      pos_bol: lcp.pos_cnum,
      pos_cnum: lcp.pos_cnum
    };
    return ;
  }
  
}

function flush_input(lb) {
  lb.lex_curr_pos = 0;
  lb.lex_abs_pos = 0;
  var lcp = lb.lex_curr_p;
  if (lcp !== dummy_pos) {
    lb.lex_curr_p = {
      pos_fname: lcp.pos_fname,
      pos_lnum: 1,
      pos_bol: 0,
      pos_cnum: 0
    };
  }
  lb.lex_buffer_len = 0;
}

export {
  dummy_pos ,
  from_channel ,
  from_string ,
  from_function ,
  set_position ,
  set_filename ,
  with_positions ,
  lexeme ,
  lexeme_char ,
  lexeme_start ,
  lexeme_end ,
  lexeme_start_p ,
  lexeme_end_p ,
  new_line ,
  flush_input ,
  sub_lexeme ,
  sub_lexeme_opt ,
  sub_lexeme_char ,
  sub_lexeme_char_opt ,
  engine ,
  new_engine ,
}
/* No side effect */
`,Hu=`// Generated by Melange

import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";

function length(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (!param) {
      return len;
    }
    _param = param.tl;
    _len = len + 1 | 0;
    continue ;
  };
}

function cons(a, l) {
  return {
          hd: a,
          tl: l
        };
}

function hd(param) {
  if (param) {
    return param.hd;
  }
  throw {
        MEL_EXN_ID: "Failure",
        _1: "hd",
        Error: new Error()
      };
}

function tl(param) {
  if (param) {
    return param.tl;
  }
  throw {
        MEL_EXN_ID: "Failure",
        _1: "tl",
        Error: new Error()
      };
}

function nth(l, n) {
  if (n < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1.hd;
      }
      _n = n$1 - 1 | 0;
      _l = l$1.tl;
      continue ;
    }
    throw {
          MEL_EXN_ID: "Failure",
          _1: "nth",
          Error: new Error()
        };
  };
}

function nth_opt(l, n) {
  if (n < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.nth",
          Error: new Error()
        };
  }
  var _l = l;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var l$1 = _l;
    if (!l$1) {
      return ;
    }
    if (n$1 === 0) {
      return Caml_option.some(l$1.hd);
    }
    _n = n$1 - 1 | 0;
    _l = l$1.tl;
    continue ;
  };
}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue ;
  };
}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function init_dps(_dst, _offset, _i, last, f) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var i = _i;
    if (i > last) {
      dst[offset] = /* [] */0;
      return ;
    }
    if (i === last) {
      dst[offset] = {
        hd: Curry._1(f, i),
        tl: /* [] */0
      };
      return ;
    }
    var r1 = Curry._1(f, i);
    var r2 = Curry._1(f, i + 1 | 0);
    var block = {
      hd: r2,
      tl: 24029
    };
    dst[offset] = {
      hd: r1,
      tl: block
    };
    _i = i + 2 | 0;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function init(len, f) {
  if (len < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.init",
          Error: new Error()
        };
  }
  var i = 0;
  var last = len - 1 | 0;
  if (i > last) {
    return /* [] */0;
  }
  if (i === last) {
    return {
            hd: Curry._1(f, i),
            tl: /* [] */0
          };
  }
  var r1 = Curry._1(f, i);
  var r2 = Curry._1(f, i + 1 | 0);
  var block = {
    hd: r2,
    tl: 24029
  };
  return {
          hd: r1,
          tl: (init_dps(block, "tl", i + 2 | 0, last, f), block)
        };
}

function flatten(param) {
  if (param) {
    return Stdlib.$at(param.hd, flatten(param.tl));
  } else {
    return /* [] */0;
  }
}

function map_dps(_dst, _offset, f, _param) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var param = _param;
    if (!param) {
      dst[offset] = /* [] */0;
      return ;
    }
    var match = param.tl;
    var a1 = param.hd;
    if (match) {
      var r1 = Curry._1(f, a1);
      var r2 = Curry._1(f, match.hd);
      var block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _offset = "tl";
      _dst = block;
      continue ;
    }
    var r1$1 = Curry._1(f, a1);
    dst[offset] = {
      hd: r1$1,
      tl: /* [] */0
    };
    return ;
  };
}

function map(f, param) {
  if (!param) {
    return /* [] */0;
  }
  var match = param.tl;
  var a1 = param.hd;
  if (match) {
    var r1 = Curry._1(f, a1);
    var r2 = Curry._1(f, match.hd);
    var block = {
      hd: r2,
      tl: 24029
    };
    return {
            hd: r1,
            tl: (map_dps(block, "tl", f, match.tl), block)
          };
  }
  var r1$1 = Curry._1(f, a1);
  return {
          hd: r1$1,
          tl: /* [] */0
        };
}

function mapi_dps(_dst, _offset, _i, f, _param) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var i = _i;
    var param = _param;
    if (!param) {
      dst[offset] = /* [] */0;
      return ;
    }
    var match = param.tl;
    var a1 = param.hd;
    if (match) {
      var r1 = Curry._2(f, i, a1);
      var r2 = Curry._2(f, i + 1 | 0, match.hd);
      var block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _i = i + 2 | 0;
      _offset = "tl";
      _dst = block;
      continue ;
    }
    var r1$1 = Curry._2(f, i, a1);
    dst[offset] = {
      hd: r1$1,
      tl: /* [] */0
    };
    return ;
  };
}

function mapi(f, l) {
  var i = 0;
  if (!l) {
    return /* [] */0;
  }
  var match = l.tl;
  var a1 = l.hd;
  if (match) {
    var r1 = Curry._2(f, i, a1);
    var r2 = Curry._2(f, i + 1 | 0, match.hd);
    var block = {
      hd: r2,
      tl: 24029
    };
    return {
            hd: r1,
            tl: (mapi_dps(block, "tl", i + 2 | 0, f, match.tl), block)
          };
  }
  var r1$1 = Curry._2(f, i, a1);
  return {
          hd: r1$1,
          tl: /* [] */0
        };
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: Curry._1(f, param.hd),
      tl: accu
    };
    continue ;
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    Curry._1(f, param.hd);
    _param = param.tl;
    continue ;
  };
}

function iteri(f, l) {
  var _i = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return ;
    }
    Curry._2(f, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (!l) {
      return accu;
    }
    _l = l.tl;
    _accu = Curry._2(f, accu, l.hd);
    continue ;
  };
}

function fold_right(f, l, accu) {
  if (l) {
    return Curry._2(f, l.hd, fold_right(f, l.tl, accu));
  } else {
    return accu;
  }
}

function map2_dps(_dst, _offset, f, _l1, _l2) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var l1 = _l1;
    var l2 = _l2;
    if (l1) {
      var match = l1.tl;
      var a1 = l1.hd;
      if (match) {
        if (l2) {
          var match$1 = l2.tl;
          if (match$1) {
            var r1 = Curry._2(f, a1, l2.hd);
            var r2 = Curry._2(f, match.hd, match$1.hd);
            var block = {
              hd: r2,
              tl: 24029
            };
            dst[offset] = {
              hd: r1,
              tl: block
            };
            _l2 = match$1.tl;
            _l1 = match.tl;
            _offset = "tl";
            _dst = block;
            continue ;
          }
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "List.map2",
                Error: new Error()
              };
          dst[offset] = undefined;
          return ;
        }
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2",
              Error: new Error()
            };
        dst[offset] = undefined;
        return ;
      }
      if (l2) {
        if (l2.tl) {
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "List.map2",
                Error: new Error()
              };
          dst[offset] = undefined;
          return ;
        }
        var r1$1 = Curry._2(f, a1, l2.hd);
        dst[offset] = {
          hd: r1$1,
          tl: /* [] */0
        };
        return ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2",
            Error: new Error()
          };
      dst[offset] = undefined;
      return ;
    }
    if (!l2) {
      dst[offset] = /* [] */0;
      return ;
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2",
          Error: new Error()
        };
    dst[offset] = undefined;
    return ;
  };
}

function map2(f, l1, l2) {
  if (l1) {
    var match = l1.tl;
    var a1 = l1.hd;
    if (match) {
      if (l2) {
        var match$1 = l2.tl;
        if (match$1) {
          var r1 = Curry._2(f, a1, l2.hd);
          var r2 = Curry._2(f, match.hd, match$1.hd);
          var block = {
            hd: r2,
            tl: 24029
          };
          return {
                  hd: r1,
                  tl: (map2_dps(block, "tl", f, match.tl, match$1.tl), block)
                };
        }
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2",
              Error: new Error()
            };
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2",
            Error: new Error()
          };
    }
    if (l2) {
      if (l2.tl) {
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "List.map2",
              Error: new Error()
            };
      }
      var r1$1 = Curry._2(f, a1, l2.hd);
      return {
              hd: r1$1,
              tl: /* [] */0
            };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2",
        Error: new Error()
      };
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        _accu = {
          hd: Curry._2(f, l1$1.hd, l2$1.hd),
          tl: accu
        };
        continue ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    if (l2$1) {
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.rev_map2",
            Error: new Error()
          };
    }
    return accu;
  };
}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        Curry._2(f, l1.hd, l2.hd);
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.iter2",
            Error: new Error()
          };
    }
    if (!l2) {
      return ;
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.iter2",
          Error: new Error()
        };
  };
}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2.tl;
        _l1 = l1.tl;
        _accu = Curry._3(f, accu, l1.hd, l2.hd);
        continue ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    if (l2) {
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.fold_left2",
            Error: new Error()
          };
    }
    return accu;
  };
}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return Curry._3(f, l1.hd, l2.hd, fold_right2(f, l1.tl, l2.tl, accu));
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  if (l2) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.fold_right2",
          Error: new Error()
        };
  }
  return accu;
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._1(p, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(p, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (!Curry._2(p, l1.hd, l2.hd)) {
          return false;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.for_all2",
            Error: new Error()
          };
    }
    if (!l2) {
      return true;
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.for_all2",
          Error: new Error()
        };
  };
}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1.hd, l2.hd)) {
          return true;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue ;
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.exists2",
            Error: new Error()
          };
    }
    if (!l2) {
      return false;
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.exists2",
          Error: new Error()
        };
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.caml_equal(param.hd, x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function memq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

function assoc_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (Caml_obj.caml_equal(match[0], x)) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  };
}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param.hd;
      if (match[0] === x) {
        return match[1];
      }
      _param = param.tl;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

function assq_opt(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param.hd;
    if (match[0] === x) {
      return Caml_option.some(match[1]);
    }
    _param = param.tl;
    continue ;
  };
}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Caml_obj.caml_equal(param.hd[0], x)) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (param.hd[0] === x) {
      return true;
    }
    _param = param.tl;
    continue ;
  };
}

function remove_assoc(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (Caml_obj.caml_equal(pair[0], x)) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assoc(x, l)
          };
  }
}

function remove_assq(x, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param.tl;
  var pair = param.hd;
  if (pair[0] === x) {
    return l;
  } else {
    return {
            hd: pair,
            tl: remove_assq(x, l)
          };
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param.hd;
      if (Curry._1(p, x)) {
        return x;
      }
      _param = param.tl;
      continue ;
    }
    throw {
          MEL_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  };
}

function find_opt(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var x = param.hd;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _param = param.tl;
    continue ;
  };
}

function find_index(p) {
  return function (param) {
    var _i = 0;
    var _param = param;
    while(true) {
      var param$1 = _param;
      var i = _i;
      if (!param$1) {
        return ;
      }
      if (Curry._1(p, param$1.hd)) {
        return i;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue ;
    };
  };
}

function find_map(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var result = Curry._1(f, param.hd);
    if (result !== undefined) {
      return result;
    }
    _param = param.tl;
    continue ;
  };
}

function find_mapi(f) {
  return function (param) {
    var _i = 0;
    var _param = param;
    while(true) {
      var param$1 = _param;
      var i = _i;
      if (!param$1) {
        return ;
      }
      var result = Curry._2(f, i, param$1.hd);
      if (result !== undefined) {
        return result;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue ;
    };
  };
}

function find_all(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var l = param.tl;
    var x = param.hd;
    if (Curry._1(p, x)) {
      var block = {
        hd: x,
        tl: 24029
      };
      find_all_dps(block, "tl", p, l);
      return block;
    }
    _param = l;
    continue ;
  };
}

function find_all_dps(_dst, _offset, p, _param) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var param = _param;
    if (!param) {
      dst[offset] = /* [] */0;
      return ;
    }
    var l = param.tl;
    var x = param.hd;
    if (Curry._1(p, x)) {
      var block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue ;
    }
    _param = l;
    continue ;
  };
}

function filteri_dps(_dst, _offset, p, _i, _param) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var i = _i;
    var param = _param;
    if (!param) {
      dst[offset] = /* [] */0;
      return ;
    }
    var l = param.tl;
    var x = param.hd;
    var i$p = i + 1 | 0;
    if (Curry._2(p, i, x)) {
      var block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _i = i$p;
      _offset = "tl";
      _dst = block;
      continue ;
    }
    _param = l;
    _i = i$p;
    continue ;
  };
}

function filteri(p, l) {
  var _i = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return /* [] */0;
    }
    var l$1 = param.tl;
    var x = param.hd;
    var i$p = i + 1 | 0;
    if (Curry._2(p, i, x)) {
      var block = {
        hd: x,
        tl: 24029
      };
      filteri_dps(block, "tl", p, i$p, l$1);
      return block;
    }
    _param = l$1;
    _i = i$p;
    continue ;
  };
}

function filter_map(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var l = param.tl;
    var v = Curry._1(f, param.hd);
    if (v !== undefined) {
      var block = {
        hd: Caml_option.valFromOption(v),
        tl: 24029
      };
      filter_map_dps(block, "tl", f, l);
      return block;
    }
    _param = l;
    continue ;
  };
}

function filter_map_dps(_dst, _offset, f, _param) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var param = _param;
    if (!param) {
      dst[offset] = /* [] */0;
      return ;
    }
    var l = param.tl;
    var v = Curry._1(f, param.hd);
    if (v !== undefined) {
      var block = {
        hd: Caml_option.valFromOption(v),
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue ;
    }
    _param = l;
    continue ;
  };
}

function concat_map(f, param) {
  if (param) {
    var ys = Curry._1(f, param.hd);
    var xs = param.tl;
    if (!ys) {
      return concat_map(f, xs);
    }
    var block = {
      hd: ys.hd,
      tl: 24029
    };
    prepend_concat_map_dps(block, "tl", ys.tl, f, xs);
    return block;
  } else {
    return /* [] */0;
  }
}

function prepend_concat_map_dps(_dst, _offset, _ys, f, xs) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var ys = _ys;
    if (!ys) {
      if (xs) {
        return prepend_concat_map_dps(dst, offset, Curry._1(f, xs.hd), f, xs.tl);
      } else {
        dst[offset] = /* [] */0;
        return ;
      }
    }
    var block = {
      hd: ys.hd,
      tl: 24029
    };
    dst[offset] = block;
    _ys = ys.tl;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function fold_left_map(f, accu, l) {
  var _accu = accu;
  var _l_accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var l_accu = _l_accu;
    var accu$1 = _accu;
    if (!param) {
      return [
              accu$1,
              rev_append(l_accu, /* [] */0)
            ];
    }
    var match = Curry._2(f, accu$1, param.hd);
    _param = param.tl;
    _l_accu = {
      hd: match[1],
      tl: l_accu
    };
    _accu = match[0];
    continue ;
  };
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (!param) {
      return [
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
    var l$1 = param.tl;
    var x = param.hd;
    if (Curry._1(p, x)) {
      _param = l$1;
      _yes = {
        hd: x,
        tl: yes
      };
      continue ;
    }
    _param = l$1;
    _no = {
      hd: x,
      tl: no
    };
    continue ;
  };
}

function partition_map(p, l) {
  var _left = /* [] */0;
  var _right = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var right = _right;
    var left = _left;
    if (!param) {
      return [
              rev_append(left, /* [] */0),
              rev_append(right, /* [] */0)
            ];
    }
    var l$1 = param.tl;
    var v = Curry._1(p, param.hd);
    if (v.TAG === /* Left */0) {
      _param = l$1;
      _left = {
        hd: v._0,
        tl: left
      };
      continue ;
    }
    _param = l$1;
    _right = {
      hd: v._0,
      tl: right
    };
    continue ;
  };
}

function split(param) {
  if (!param) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var match = param.hd;
  var match$1 = split(param.tl);
  return [
          {
            hd: match[0],
            tl: match$1[0]
          },
          {
            hd: match[1],
            tl: match$1[1]
          }
        ];
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return {
              hd: [
                l1.hd,
                l2.hd
              ],
              tl: combine(l1.tl, l2.tl)
            };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.combine",
          Error: new Error()
        };
  }
  if (!l2) {
    return /* [] */0;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.combine",
        Error: new Error()
      };
}

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  var h2 = l2.hd;
  var h1 = l1.hd;
  if (Curry._2(cmp, h1, h2) <= 0) {
    return {
            hd: h1,
            tl: merge(cmp, l1.tl, l2)
          };
  } else {
    return {
            hd: h2,
            tl: merge(cmp, l1, l2.tl)
          };
  }
}

function stable_sort(cmp, l) {
  var rev_merge = function (_l1, _l2, _accu) {
    while(true) {
      var accu = _accu;
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      var h2 = l2.hd;
      var h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) <= 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue ;
    };
  };
  var rev_merge_rev = function (_l1, _l2, _accu) {
    while(true) {
      var accu = _accu;
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      var h2 = l2.hd;
      var h1 = l1.hd;
      if (Curry._2(cmp, h1, h2) > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue ;
    };
  };
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var s = Curry._2(cmp, x1, x2) <= 0 ? (
                Curry._2(cmp, x2, x3) <= 0 ? ({
                      hd: x1,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    }) : (
                    Curry._2(cmp, x1, x3) <= 0 ? ({
                          hd: x1,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        })
                  )
              ) : (
                Curry._2(cmp, x1, x3) <= 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    }) : (
                    Curry._2(cmp, x2, x3) <= 0 ? ({
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        })
                  )
              );
            return [
                    s,
                    match$1.tl
                  ];
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var s$1 = Curry._2(cmp, x1$1, x2$1) <= 0 ? ({
              hd: x1$1,
              tl: {
                hd: x2$1,
                tl: /* [] */0
              }
            }) : ({
              hd: x2$1,
              tl: {
                hd: x1$1,
                tl: /* [] */0
              }
            });
        return [
                s$1,
                match$2.tl
              ];
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var match$3 = rev_sort(n1, l);
    var match$4 = rev_sort(n2, match$3[1]);
    return [
            rev_merge_rev(match$3[0], match$4[0], /* [] */0),
            match$4[1]
          ];
  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var s = Curry._2(cmp, x1, x2) > 0 ? (
                Curry._2(cmp, x2, x3) > 0 ? ({
                      hd: x1,
                      tl: {
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    }) : (
                    Curry._2(cmp, x1, x3) > 0 ? ({
                          hd: x1,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        })
                  )
              ) : (
                Curry._2(cmp, x1, x3) > 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }
                    }) : (
                    Curry._2(cmp, x2, x3) > 0 ? ({
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        })
                  )
              );
            return [
                    s,
                    match$1.tl
                  ];
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var s$1 = Curry._2(cmp, x1$1, x2$1) > 0 ? ({
              hd: x1$1,
              tl: {
                hd: x2$1,
                tl: /* [] */0
              }
            }) : ({
              hd: x2$1,
              tl: {
                hd: x1$1,
                tl: /* [] */0
              }
            });
        return [
                s$1,
                match$2.tl
              ];
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var match$3 = sort(n1, l);
    var match$4 = sort(n2, match$3[1]);
    return [
            rev_merge(match$3[0], match$4[0], /* [] */0),
            match$4[1]
          ];
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l)[0];
  }
}

function sort_uniq(cmp, l) {
  var rev_merge = function (_l1, _l2, _accu) {
    while(true) {
      var accu = _accu;
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      var t2 = l2.tl;
      var h2 = l2.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c = Curry._2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c < 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    };
  };
  var rev_merge_rev = function (_l1, _l2, _accu) {
    while(true) {
      var accu = _accu;
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      var t2 = l2.tl;
      var h2 = l2.hd;
      var t1 = l1.tl;
      var h1 = l1.hd;
      var c = Curry._2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue ;
      }
      if (c > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue ;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue ;
    };
  };
  var sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = Curry._2(cmp, x1, x2);
            var s;
            if (c === 0) {
              var c$1 = Curry._2(cmp, x2, x3);
              s = c$1 === 0 ? ({
                    hd: x2,
                    tl: /* [] */0
                  }) : (
                  c$1 < 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      })
                );
            } else if (c < 0) {
              var c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: /* [] */0
                  }
                };
              } else if (c$2 < 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: /* [] */0
                    }
                  }
                };
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                s = c$3 === 0 ? ({
                      hd: x1,
                      tl: {
                        hd: x2,
                        tl: /* [] */0
                      }
                    }) : (
                    c$3 < 0 ? ({
                          hd: x1,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        })
                  );
              }
            } else {
              var c$4 = Curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: /* [] */0
                  }
                };
              } else if (c$4 < 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: /* [] */0
                    }
                  }
                };
              } else {
                var c$5 = Curry._2(cmp, x2, x3);
                s = c$5 === 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    }) : (
                    c$5 < 0 ? ({
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        })
                  );
              }
            }
            return [
                    s,
                    match$1.tl
                  ];
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        var s$1 = c$6 === 0 ? ({
              hd: x1$1,
              tl: /* [] */0
            }) : (
            c$6 < 0 ? ({
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                }) : ({
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                })
          );
        return [
                s$1,
                match$2.tl
              ];
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var match$3 = rev_sort(n1, l);
    var match$4 = rev_sort(n2, match$3[1]);
    return [
            rev_merge_rev(match$3[0], match$4[0], /* [] */0),
            match$4[1]
          ];
  };
  var rev_sort = function (n, l) {
    if (n !== 2) {
      if (n === 3 && l) {
        var match = l.tl;
        if (match) {
          var match$1 = match.tl;
          if (match$1) {
            var x3 = match$1.hd;
            var x2 = match.hd;
            var x1 = l.hd;
            var c = Curry._2(cmp, x1, x2);
            var s;
            if (c === 0) {
              var c$1 = Curry._2(cmp, x2, x3);
              s = c$1 === 0 ? ({
                    hd: x2,
                    tl: /* [] */0
                  }) : (
                  c$1 > 0 ? ({
                        hd: x2,
                        tl: {
                          hd: x3,
                          tl: /* [] */0
                        }
                      }) : ({
                        hd: x3,
                        tl: {
                          hd: x2,
                          tl: /* [] */0
                        }
                      })
                );
            } else if (c > 0) {
              var c$2 = Curry._2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: /* [] */0
                  }
                };
              } else if (c$2 > 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: /* [] */0
                    }
                  }
                };
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                s = c$3 === 0 ? ({
                      hd: x1,
                      tl: {
                        hd: x2,
                        tl: /* [] */0
                      }
                    }) : (
                    c$3 > 0 ? ({
                          hd: x1,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x1,
                            tl: {
                              hd: x2,
                              tl: /* [] */0
                            }
                          }
                        })
                  );
              }
            } else {
              var c$4 = Curry._2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: /* [] */0
                  }
                };
              } else if (c$4 > 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: /* [] */0
                    }
                  }
                };
              } else {
                var c$5 = Curry._2(cmp, x2, x3);
                s = c$5 === 0 ? ({
                      hd: x2,
                      tl: {
                        hd: x1,
                        tl: /* [] */0
                      }
                    }) : (
                    c$5 > 0 ? ({
                          hd: x2,
                          tl: {
                            hd: x3,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        }) : ({
                          hd: x3,
                          tl: {
                            hd: x2,
                            tl: {
                              hd: x1,
                              tl: /* [] */0
                            }
                          }
                        })
                  );
              }
            }
            return [
                    s,
                    match$1.tl
                  ];
          }
          
        }
        
      }
      
    } else if (l) {
      var match$2 = l.tl;
      if (match$2) {
        var x2$1 = match$2.hd;
        var x1$1 = l.hd;
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        var s$1 = c$6 === 0 ? ({
              hd: x1$1,
              tl: /* [] */0
            }) : (
            c$6 > 0 ? ({
                  hd: x1$1,
                  tl: {
                    hd: x2$1,
                    tl: /* [] */0
                  }
                }) : ({
                  hd: x2$1,
                  tl: {
                    hd: x1$1,
                    tl: /* [] */0
                  }
                })
          );
        return [
                s$1,
                match$2.tl
              ];
      }
      
    }
    var n1 = (n >> 1);
    var n2 = n - n1 | 0;
    var match$3 = sort(n1, l);
    var match$4 = sort(n2, match$3[1]);
    return [
            rev_merge(match$3[0], match$4[0], /* [] */0),
            match$4[1]
          ];
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l)[0];
  }
}

function compare_lengths(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function compare_length_with(_l, _n) {
  while(true) {
    var n = _n;
    var l = _l;
    if (!l) {
      if (n === 0) {
        return 0;
      } else if (n > 0) {
        return -1;
      } else {
        return 1;
      }
    }
    if (n <= 0) {
      return 1;
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue ;
  };
}

function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function equal(eq, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!Curry._2(eq, l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function compare(cmp, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    var c = Curry._2(cmp, l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function to_seq(l) {
  var aux = function (l, param) {
    if (!l) {
      return /* Nil */0;
    }
    var tail = l.tl;
    return /* Cons */{
            _0: l.hd,
            _1: (function (param) {
                return aux(tail, param);
              })
          };
  };
  return function (param) {
    return aux(l, param);
  };
}

function of_seq_dps(_dst, _offset, _seq) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      dst[offset] = /* [] */0;
      return ;
    }
    var x1 = match._0;
    var match$1 = Curry._1(match._1, undefined);
    if (!match$1) {
      dst[offset] = {
        hd: x1,
        tl: /* [] */0
      };
      return ;
    }
    var block = {
      hd: match$1._0,
      tl: 24029
    };
    dst[offset] = {
      hd: x1,
      tl: block
    };
    _seq = match$1._1;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function of_seq(seq) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* [] */0;
  }
  var x1 = match._0;
  var match$1 = Curry._1(match._1, undefined);
  if (!match$1) {
    return {
            hd: x1,
            tl: /* [] */0
          };
  }
  var block = {
    hd: match$1._0,
    tl: 24029
  };
  return {
          hd: x1,
          tl: (of_seq_dps(block, "tl", match$1._1), block)
        };
}

var append = Stdlib.$at;

var concat = flatten;

var filter = find_all;

var sort = stable_sort;

var fast_sort = stable_sort;

export {
  length ,
  compare_lengths ,
  compare_length_with ,
  is_empty ,
  cons ,
  hd ,
  tl ,
  nth ,
  nth_opt ,
  rev ,
  init ,
  append ,
  rev_append ,
  concat ,
  flatten ,
  equal ,
  compare ,
  iter ,
  iteri ,
  map ,
  mapi ,
  rev_map ,
  filter_map ,
  concat_map ,
  fold_left_map ,
  fold_left ,
  fold_right ,
  iter2 ,
  map2 ,
  rev_map2 ,
  fold_left2 ,
  fold_right2 ,
  for_all ,
  exists ,
  for_all2 ,
  exists2 ,
  mem ,
  memq ,
  find ,
  find_opt ,
  find_index ,
  find_map ,
  find_mapi ,
  filter ,
  find_all ,
  filteri ,
  partition ,
  partition_map ,
  assoc ,
  assoc_opt ,
  assq ,
  assq_opt ,
  mem_assoc ,
  mem_assq ,
  remove_assoc ,
  remove_assq ,
  split ,
  combine ,
  sort ,
  stable_sort ,
  fast_sort ,
  sort_uniq ,
  merge ,
  to_seq ,
  of_seq ,
}
/* No side effect */
`,Wu=`// Generated by Melange

import * as Stdlib__List from "./list.js";

var length = Stdlib__List.length;

var compare_lengths = Stdlib__List.compare_lengths;

var compare_length_with = Stdlib__List.compare_length_with;

var is_empty = Stdlib__List.is_empty;

var cons = Stdlib__List.cons;

var hd = Stdlib__List.hd;

var tl = Stdlib__List.tl;

var nth = Stdlib__List.nth;

var nth_opt = Stdlib__List.nth_opt;

var rev = Stdlib__List.rev;

var init = Stdlib__List.init;

var append = Stdlib__List.append;

var rev_append = Stdlib__List.rev_append;

var concat = Stdlib__List.concat;

var flatten = Stdlib__List.flatten;

var equal = Stdlib__List.equal;

var compare = Stdlib__List.compare;

var iter = Stdlib__List.iter;

var iteri = Stdlib__List.iteri;

var map = Stdlib__List.map;

var mapi = Stdlib__List.mapi;

var rev_map = Stdlib__List.rev_map;

var filter_map = Stdlib__List.filter_map;

var concat_map = Stdlib__List.concat_map;

var fold_left_map = Stdlib__List.fold_left_map;

var fold_left = Stdlib__List.fold_left;

var fold_right = Stdlib__List.fold_right;

var iter2 = Stdlib__List.iter2;

var map2 = Stdlib__List.map2;

var rev_map2 = Stdlib__List.rev_map2;

var fold_left2 = Stdlib__List.fold_left2;

var fold_right2 = Stdlib__List.fold_right2;

var for_all = Stdlib__List.for_all;

var exists = Stdlib__List.exists;

var for_all2 = Stdlib__List.for_all2;

var exists2 = Stdlib__List.exists2;

var mem = Stdlib__List.mem;

var memq = Stdlib__List.memq;

var find = Stdlib__List.find;

var find_opt = Stdlib__List.find_opt;

var find_index = Stdlib__List.find_index;

var find_map = Stdlib__List.find_map;

var find_mapi = Stdlib__List.find_mapi;

var filter = Stdlib__List.filter;

var find_all = Stdlib__List.find_all;

var filteri = Stdlib__List.filteri;

var partition = Stdlib__List.partition;

var partition_map = Stdlib__List.partition_map;

var assoc = Stdlib__List.assoc;

var assoc_opt = Stdlib__List.assoc_opt;

var assq = Stdlib__List.assq;

var assq_opt = Stdlib__List.assq_opt;

var mem_assoc = Stdlib__List.mem_assoc;

var mem_assq = Stdlib__List.mem_assq;

var remove_assoc = Stdlib__List.remove_assoc;

var remove_assq = Stdlib__List.remove_assq;

var split = Stdlib__List.split;

var combine = Stdlib__List.combine;

var sort = Stdlib__List.sort;

var stable_sort = Stdlib__List.stable_sort;

var fast_sort = Stdlib__List.fast_sort;

var sort_uniq = Stdlib__List.sort_uniq;

var merge = Stdlib__List.merge;

var to_seq = Stdlib__List.to_seq;

var of_seq = Stdlib__List.of_seq;

export {
  length ,
  compare_lengths ,
  compare_length_with ,
  is_empty ,
  cons ,
  hd ,
  tl ,
  nth ,
  nth_opt ,
  rev ,
  init ,
  append ,
  rev_append ,
  concat ,
  flatten ,
  equal ,
  compare ,
  iter ,
  iteri ,
  map ,
  mapi ,
  rev_map ,
  filter_map ,
  concat_map ,
  fold_left_map ,
  fold_left ,
  fold_right ,
  iter2 ,
  map2 ,
  rev_map2 ,
  fold_left2 ,
  fold_right2 ,
  for_all ,
  exists ,
  for_all2 ,
  exists2 ,
  mem ,
  memq ,
  find ,
  find_opt ,
  find_index ,
  find_map ,
  find_mapi ,
  filter ,
  find_all ,
  filteri ,
  partition ,
  partition_map ,
  assoc ,
  assoc_opt ,
  assq ,
  assq_opt ,
  mem_assoc ,
  mem_assq ,
  remove_assoc ,
  remove_assq ,
  split ,
  combine ,
  sort ,
  stable_sort ,
  fast_sort ,
  sort_uniq ,
  merge ,
  to_seq ,
  of_seq ,
}
/* No side effect */
`,Ju=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

function Make(funarg) {
  var height = function (param) {
    if (param) {
      return param.h;
    } else {
      return 0;
    }
  };
  var create = function (l, x, d, r) {
    var hl = height(l);
    var hr = height(r);
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  };
  var singleton = function (x, d) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: d,
            r: /* Empty */0,
            h: 1
          };
  };
  var bal = function (l, x, d, r) {
    var hl = l ? l.h : 0;
    var hr = r ? r.h : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l.r;
        var ld = l.d;
        var lv = l.v;
        var ll = l.l;
        if (height(ll) >= height(lr)) {
          return create(ll, lv, ld, create(lr, x, d, r));
        }
        if (lr) {
          return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
        }
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal",
              Error: new Error()
            };
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    if (hr <= (hl + 2 | 0)) {
      return /* Node */{
              l: l,
              v: x,
              d: d,
              r: r,
              h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            };
    }
    if (r) {
      var rr = r.r;
      var rd = r.d;
      var rv = r.v;
      var rl = r.l;
      if (height(rr) >= height(rl)) {
        return create(create(l, x, d, rl), rv, rd, rr);
      }
      if (rl) {
        return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal",
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.bal",
          Error: new Error()
        };
  };
  var is_empty = function (param) {
    if (param) {
      return false;
    } else {
      return true;
    }
  };
  var add = function (x, data, m) {
    if (!m) {
      return /* Node */{
              l: /* Empty */0,
              v: x,
              d: data,
              r: /* Empty */0,
              h: 1
            };
    }
    var r = m.r;
    var d = m.d;
    var v = m.v;
    var l = m.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      if (d === data) {
        return m;
      } else {
        return /* Node */{
                l: l,
                v: x,
                d: data,
                r: r,
                h: m.h
              };
      }
    }
    if (c < 0) {
      var ll = add(x, data, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    var rr = add(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = Curry._2(funarg.compare, x, param.v);
        if (c === 0) {
          return param.d;
        }
        _param = c < 0 ? param.l : param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_first = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (Curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param.d;
          var _param$1 = param.l;
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (!param$1) {
              return [
                      v0,
                      d0
                    ];
            }
            var v$1 = param$1.v;
            if (Curry._1(f, v$1)) {
              _param$1 = param$1.l;
              _d0 = param$1.d;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.r;
            continue ;
          };
        }
        _param = param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_first_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _d0 = param.d;
        var _param$1 = param.l;
        while(true) {
          var param$1 = _param$1;
          var d0 = _d0;
          var v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.r;
          continue ;
        };
      }
      _param = param.r;
      continue ;
    };
  };
  var find_last = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (Curry._1(f, v)) {
          var _v0 = v;
          var _d0 = param.d;
          var _param$1 = param.r;
          while(true) {
            var param$1 = _param$1;
            var d0 = _d0;
            var v0 = _v0;
            if (!param$1) {
              return [
                      v0,
                      d0
                    ];
            }
            var v$1 = param$1.v;
            if (Curry._1(f, v$1)) {
              _param$1 = param$1.r;
              _d0 = param$1.d;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.l;
            continue ;
          };
        }
        _param = param.l;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_last_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _d0 = param.d;
        var _param$1 = param.r;
        while(true) {
          var param$1 = _param$1;
          var d0 = _d0;
          var v0 = _v0;
          if (!param$1) {
            return [
                    v0,
                    d0
                  ];
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _d0 = param$1.d;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.l;
          continue ;
        };
      }
      _param = param.l;
      continue ;
    };
  };
  var find_opt = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return Caml_option.some(param.d);
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    };
  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return true;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    };
  };
  var min_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param.l;
        if (!l) {
          return [
                  param.v,
                  param.d
                ];
        }
        _param = l;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var min_binding_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var l = param.l;
      if (!l) {
        return [
                param.v,
                param.d
              ];
      }
      _param = l;
      continue ;
    };
  };
  var max_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        if (!param.r) {
          return [
                  param.v,
                  param.d
                ];
        }
        _param = param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var max_binding_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (!param.r) {
        return [
                param.v,
                param.d
              ];
      }
      _param = param.r;
      continue ;
    };
  };
  var remove_min_binding = function (param) {
    if (param) {
      var l = param.l;
      if (l) {
        return bal(remove_min_binding(l), param.v, param.d, param.r);
      } else {
        return param.r;
      }
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Map.remove_min_elt",
          Error: new Error()
        };
  };
  var merge = function (t1, t2) {
    if (!t1) {
      return t2;
    }
    if (!t2) {
      return t1;
    }
    var match = min_binding(t2);
    return bal(t1, match[0], match[1], remove_min_binding(t2));
  };
  var remove = function (x, m) {
    if (!m) {
      return /* Empty */0;
    }
    var r = m.r;
    var d = m.d;
    var v = m.v;
    var l = m.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return merge(l, r);
    }
    if (c < 0) {
      var ll = remove(x, l);
      if (l === ll) {
        return m;
      } else {
        return bal(ll, v, d, r);
      }
    }
    var rr = remove(x, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  };
  var update = function (x, f, m) {
    if (m) {
      var r = m.r;
      var d = m.d;
      var v = m.v;
      var l = m.l;
      var c = Curry._2(funarg.compare, x, v);
      if (c === 0) {
        var data = Curry._1(f, Caml_option.some(d));
        if (data === undefined) {
          return merge(l, r);
        }
        var data$1 = Caml_option.valFromOption(data);
        if (d === data$1) {
          return m;
        } else {
          return /* Node */{
                  l: l,
                  v: x,
                  d: data$1,
                  r: r,
                  h: m.h
                };
        }
      }
      if (c < 0) {
        var ll = update(x, f, l);
        if (l === ll) {
          return m;
        } else {
          return bal(ll, v, d, r);
        }
      }
      var rr = update(x, f, r);
      if (r === rr) {
        return m;
      } else {
        return bal(l, v, d, rr);
      }
    }
    var data$2 = Curry._1(f, undefined);
    if (data$2 !== undefined) {
      return /* Node */{
              l: /* Empty */0,
              v: x,
              d: Caml_option.valFromOption(data$2),
              r: /* Empty */0,
              h: 1
            };
    } else {
      return /* Empty */0;
    }
  };
  var add_to_list = function (x, data, m) {
    var add = function (param) {
      if (param !== undefined) {
        return {
                hd: data,
                tl: param
              };
      } else {
        return {
                hd: data,
                tl: /* [] */0
              };
      }
    };
    return update(x, add, m);
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      iter(f, param.l);
      Curry._2(f, param.v, param.d);
      _param = param.r;
      continue ;
    };
  };
  var map = function (f, param) {
    if (!param) {
      return /* Empty */0;
    }
    var l$p = map(f, param.l);
    var d$p = Curry._1(f, param.d);
    var r$p = map(f, param.r);
    return /* Node */{
            l: l$p,
            v: param.v,
            d: d$p,
            r: r$p,
            h: param.h
          };
  };
  var mapi = function (f, param) {
    if (!param) {
      return /* Empty */0;
    }
    var v = param.v;
    var l$p = mapi(f, param.l);
    var d$p = Curry._2(f, v, param.d);
    var r$p = mapi(f, param.r);
    return /* Node */{
            l: l$p,
            v: v,
            d: d$p,
            r: r$p,
            h: param.h
          };
  };
  var fold = function (f, _m, _accu) {
    while(true) {
      var accu = _accu;
      var m = _m;
      if (!m) {
        return accu;
      }
      _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
      _m = m.r;
      continue ;
    };
  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return true;
      }
      if (!Curry._2(p, param.v, param.d)) {
        return false;
      }
      if (!for_all(p, param.l)) {
        return false;
      }
      _param = param.r;
      continue ;
    };
  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (Curry._2(p, param.v, param.d)) {
        return true;
      }
      if (exists(p, param.l)) {
        return true;
      }
      _param = param.r;
      continue ;
    };
  };
  var add_min_binding = function (k, x, param) {
    if (param) {
      return bal(add_min_binding(k, x, param.l), param.v, param.d, param.r);
    } else {
      return singleton(k, x);
    }
  };
  var add_max_binding = function (k, x, param) {
    if (param) {
      return bal(param.l, param.v, param.d, add_max_binding(k, x, param.r));
    } else {
      return singleton(k, x);
    }
  };
  var join = function (l, v, d, r) {
    if (!l) {
      return add_min_binding(v, d, r);
    }
    if (!r) {
      return add_max_binding(v, d, l);
    }
    var rh = r.h;
    var lh = l.h;
    if (lh > (rh + 2 | 0)) {
      return bal(l.l, l.v, l.d, join(l.r, v, d, r));
    } else if (rh > (lh + 2 | 0)) {
      return bal(join(l, v, d, r.l), r.v, r.d, r.r);
    } else {
      return create(l, v, d, r);
    }
  };
  var concat = function (t1, t2) {
    if (!t1) {
      return t2;
    }
    if (!t2) {
      return t1;
    }
    var match = min_binding(t2);
    return join(t1, match[0], match[1], remove_min_binding(t2));
  };
  var concat_or_join = function (t1, v, d, t2) {
    if (d !== undefined) {
      return join(t1, v, Caml_option.valFromOption(d), t2);
    } else {
      return concat(t1, t2);
    }
  };
  var split = function (x, param) {
    if (!param) {
      return [
              /* Empty */0,
              undefined,
              /* Empty */0
            ];
    }
    var r = param.r;
    var d = param.d;
    var v = param.v;
    var l = param.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return [
              l,
              Caml_option.some(d),
              r
            ];
    }
    if (c < 0) {
      var match = split(x, l);
      return [
              match[0],
              match[1],
              join(match[2], v, d, r)
            ];
    }
    var match$1 = split(x, r);
    return [
            join(l, v, d, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  };
  var merge$1 = function (f, s1, s2) {
    if (s1) {
      var v1 = s1.v;
      if (s1.h >= height(s2)) {
        var match = split(v1, s2);
        return concat_or_join(merge$1(f, s1.l, match[0]), v1, Curry._3(f, v1, Caml_option.some(s1.d), match[1]), merge$1(f, s1.r, match[2]));
      }
      
    } else if (!s2) {
      return /* Empty */0;
    }
    if (s2) {
      var v2 = s2.v;
      var match$1 = split(v2, s1);
      return concat_or_join(merge$1(f, match$1[0], s2.l), v2, Curry._3(f, v2, match$1[1], Caml_option.some(s2.d)), merge$1(f, match$1[2], s2.r));
    }
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/map.ml",
            408,
            10
          ],
          Error: new Error()
        };
  };
  var union = function (f, s1, s2) {
    if (!s1) {
      return s2;
    }
    if (!s2) {
      return s1;
    }
    var d2 = s2.d;
    var v2 = s2.v;
    var d1 = s1.d;
    var v1 = s1.v;
    if (s1.h >= s2.h) {
      var match = split(v1, s2);
      var d2$1 = match[1];
      var l = union(f, s1.l, match[0]);
      var r = union(f, s1.r, match[2]);
      if (d2$1 !== undefined) {
        return concat_or_join(l, v1, Curry._3(f, v1, d1, Caml_option.valFromOption(d2$1)), r);
      } else {
        return join(l, v1, d1, r);
      }
    }
    var match$1 = split(v2, s1);
    var d1$1 = match$1[1];
    var l$1 = union(f, match$1[0], s2.l);
    var r$1 = union(f, match$1[2], s2.r);
    if (d1$1 !== undefined) {
      return concat_or_join(l$1, v2, Curry._3(f, v2, Caml_option.valFromOption(d1$1), d2), r$1);
    } else {
      return join(l$1, v2, d2, r$1);
    }
  };
  var filter = function (p, m) {
    if (!m) {
      return /* Empty */0;
    }
    var r = m.r;
    var d = m.d;
    var v = m.v;
    var l = m.l;
    var l$p = filter(p, l);
    var pvd = Curry._2(p, v, d);
    var r$p = filter(p, r);
    if (pvd) {
      if (l === l$p && r === r$p) {
        return m;
      } else {
        return join(l$p, v, d, r$p);
      }
    } else {
      return concat(l$p, r$p);
    }
  };
  var filter_map = function (f, param) {
    if (!param) {
      return /* Empty */0;
    }
    var v = param.v;
    var l$p = filter_map(f, param.l);
    var fvd = Curry._2(f, v, param.d);
    var r$p = filter_map(f, param.r);
    if (fvd !== undefined) {
      return join(l$p, v, Caml_option.valFromOption(fvd), r$p);
    } else {
      return concat(l$p, r$p);
    }
  };
  var partition = function (p, param) {
    if (!param) {
      return [
              /* Empty */0,
              /* Empty */0
            ];
    }
    var d = param.d;
    var v = param.v;
    var match = partition(p, param.l);
    var lf = match[1];
    var lt = match[0];
    var pvd = Curry._2(p, v, d);
    var match$1 = partition(p, param.r);
    var rf = match$1[1];
    var rt = match$1[0];
    if (pvd) {
      return [
              join(lt, v, d, rt),
              concat(lf, rf)
            ];
    } else {
      return [
              concat(lt, rt),
              join(lf, v, d, rf)
            ];
    }
  };
  var cons_enum = function (_m, _e) {
    while(true) {
      var e = _e;
      var m = _m;
      if (!m) {
        return e;
      }
      _e = /* More */{
        _0: m.v,
        _1: m.d,
        _2: m.r,
        _3: e
      };
      _m = m.l;
      continue ;
    };
  };
  var compare = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        if (e2) {
          return -1;
        } else {
          return 0;
        }
      }
      if (!e2) {
        return 1;
      }
      var c = Curry._2(funarg.compare, e1._0, e2._0);
      if (c !== 0) {
        return c;
      }
      var c$1 = Curry._2(cmp, e1._1, e2._1);
      if (c$1 !== 0) {
        return c$1;
      }
      _e2 = cons_enum(e2._2, e2._3);
      _e1 = cons_enum(e1._2, e1._3);
      continue ;
    };
  };
  var equal = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        if (e2) {
          return false;
        } else {
          return true;
        }
      }
      if (!e2) {
        return false;
      }
      if (Curry._2(funarg.compare, e1._0, e2._0) !== 0) {
        return false;
      }
      if (!Curry._2(cmp, e1._1, e2._1)) {
        return false;
      }
      _e2 = cons_enum(e2._2, e2._3);
      _e1 = cons_enum(e1._2, e1._3);
      continue ;
    };
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
    } else {
      return 0;
    }
  };
  var bindings_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param.l;
      _accu = {
        hd: [
          param.v,
          param.d
        ],
        tl: bindings_aux(accu, param.r)
      };
      continue ;
    };
  };
  var bindings = function (s) {
    return bindings_aux(/* [] */0, s);
  };
  var of_list = function (bs) {
    return Stdlib__List.fold_left((function (m, param) {
                  return add(param[0], param[1], m);
                }), /* Empty */0, bs);
  };
  var add_seq = function (i, m) {
    return Stdlib__Seq.fold_left((function (m, param) {
                  return add(param[0], param[1], m);
                }), m, i);
  };
  var of_seq = function (i) {
    return add_seq(i, /* Empty */0);
  };
  var seq_of_enum_ = function (c, param) {
    if (!c) {
      return /* Nil */0;
    }
    var partial_arg = cons_enum(c._2, c._3);
    return /* Cons */{
            _0: [
              c._0,
              c._1
            ],
            _1: (function (param) {
                return seq_of_enum_(partial_arg, param);
              })
          };
  };
  var to_seq = function (m) {
    var partial_arg = cons_enum(m, /* End */0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  var snoc_enum = function (_s, _e) {
    while(true) {
      var e = _e;
      var s = _s;
      if (!s) {
        return e;
      }
      _e = /* More */{
        _0: s.v,
        _1: s.d,
        _2: s.l,
        _3: e
      };
      _s = s.r;
      continue ;
    };
  };
  var rev_seq_of_enum_ = function (c, param) {
    if (!c) {
      return /* Nil */0;
    }
    var partial_arg = snoc_enum(c._2, c._3);
    return /* Cons */{
            _0: [
              c._0,
              c._1
            ],
            _1: (function (param) {
                return rev_seq_of_enum_(partial_arg, param);
              })
          };
  };
  var to_rev_seq = function (c) {
    var partial_arg = snoc_enum(c, /* End */0);
    return function (param) {
      return rev_seq_of_enum_(partial_arg, param);
    };
  };
  var to_seq_from = function (low, m) {
    var aux = function (low, _m, _c) {
      while(true) {
        var c = _c;
        var m = _m;
        if (!m) {
          return c;
        }
        var r = m.r;
        var d = m.d;
        var v = m.v;
        var n = Curry._2(funarg.compare, v, low);
        if (n === 0) {
          return /* More */{
                  _0: v,
                  _1: d,
                  _2: r,
                  _3: c
                };
        }
        if (n < 0) {
          _m = r;
          continue ;
        }
        _c = /* More */{
          _0: v,
          _1: d,
          _2: r,
          _3: c
        };
        _m = m.l;
        continue ;
      };
    };
    var partial_arg = aux(low, m, /* End */0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  return {
          empty: /* Empty */0,
          add: add,
          add_to_list: add_to_list,
          update: update,
          singleton: singleton,
          remove: remove,
          merge: merge$1,
          union: union,
          cardinal: cardinal,
          bindings: bindings,
          min_binding: min_binding,
          min_binding_opt: min_binding_opt,
          max_binding: max_binding,
          max_binding_opt: max_binding_opt,
          choose: min_binding,
          choose_opt: min_binding_opt,
          find: find,
          find_opt: find_opt,
          find_first: find_first,
          find_first_opt: find_first_opt,
          find_last: find_last,
          find_last_opt: find_last_opt,
          iter: iter,
          fold: fold,
          map: map,
          mapi: mapi,
          filter: filter,
          filter_map: filter_map,
          partition: partition,
          split: split,
          is_empty: is_empty,
          mem: mem,
          equal: equal,
          compare: compare,
          for_all: for_all,
          exists: exists,
          to_list: bindings,
          of_list: of_list,
          to_seq: to_seq,
          to_rev_seq: to_rev_seq,
          to_seq_from: to_seq_from,
          add_seq: add_seq,
          of_seq: of_seq
        };
}

export {
  Make ,
}
/* No side effect */
`,Ku=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_string from "melange.js/caml_string.js";

function to_buffer(buff, ofs, len, v, flags) {
  if (ofs < 0 || len < 0 || ofs > (buff.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.to_buffer: substring out of bounds",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_output_value_to_buffer")(buff, ofs, len, v, flags);
}

function data_size(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 16 | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.data_size",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
}

function total_size(buff, ofs) {
  return 16 + data_size(buff, ofs) | 0;
}

function from_bytes(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 16 | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.from_bytes",
          Error: new Error()
        };
  }
  var len = Caml_external_polyfill.resolve("caml_marshal_data_size")(buff, ofs);
  if (ofs > (buff.length - (16 + len | 0) | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Marshal.from_bytes",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_input_value_from_bytes")(buff, ofs);
}

function from_string(buff, ofs) {
  return from_bytes(Caml_bytes.bytes_of_string(buff), ofs);
}

function compression_supported(param) {
  var s = Caml_external_polyfill.resolve("caml_output_value_to_string")(undefined, {
        hd: /* Compression */3,
        tl: /* [] */0
      });
  var match = Caml_string.get(s, 3);
  if (match === 189) {
    return true;
  }
  if (match === 190) {
    return false;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/marshal.ml",
          75,
          9
        ],
        Error: new Error()
      };
}

function to_channel(prim0, prim1, prim2) {
  return Caml_external_polyfill.resolve("caml_output_value")(prim0, prim1, prim2);
}

function from_channel(prim) {
  return Caml_external_polyfill.resolve("caml_input_value")(prim);
}

var header_size = 16;

export {
  to_channel ,
  to_buffer ,
  from_channel ,
  from_bytes ,
  from_string ,
  header_size ,
  data_size ,
  total_size ,
  compression_supported ,
}
/* No side effect */
`,Yu=`// Generated by Melange

import * as Stdlib__Hashtbl from "./hashtbl.js";
import * as Stdlib__Map from "./map.js";
import * as Stdlib__Set from "./set.js";

var Hashtbl = Stdlib__Hashtbl;

var $$Map = Stdlib__Map;

var $$Set = Stdlib__Set;

export {
  Hashtbl ,
  $$Map ,
  $$Set ,
}
/* Stdlib__Hashtbl Not a pure module */
`,Zu=`// Generated by Melange

import * as Curry from "melange.js/curry.js";

function create(param) {
  return {
          contents: false
        };
}

function lock(t) {
  t.contents = true;
}

function try_lock(t) {
  if (t.contents) {
    return false;
  } else {
    t.contents = true;
    return true;
  }
}

function unlock(t) {
  t.contents = false;
}

function protect(m, f) {
  m.contents = true;
  var x;
  try {
    x = Curry._1(f, undefined);
  }
  catch (e){
    m.contents = false;
    throw e;
  }
  m.contents = false;
  return x;
}

export {
  create ,
  lock ,
  try_lock ,
  unlock ,
  protect ,
}
/* No side effect */
`,Qu=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Stdlib__Sys from "./sys.js";

function is_block(a) {
  return typeof a !== "number";
}

function double_field(x, i) {
  return Caml_external_polyfill.resolve("caml_floatarray_get")(x, i);
}

function set_double_field(x, i, v) {
  Caml_external_polyfill.resolve("caml_floatarray_set")(x, i, v);
}

var Closure = {};

function of_val(x) {
  var slot = typeof x !== "number" && (x.TAG | 0) !== 248 && (x.length | 0) >= 1 ? x[0] : x;
  var name;
  if (typeof slot !== "number" && slot.TAG === 248) {
    name = slot[0];
  } else {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.extension_constructor",
          Error: new Error()
        };
  }
  if (name.TAG === 252) {
    return slot;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "Obj.extension_constructor",
        Error: new Error()
      };
}

function name(slot) {
  return slot[0];
}

function id(slot) {
  return slot[1];
}

var Extension_constructor = {
  of_val: of_val,
  name: name,
  id: id
};

var max_ephe_length = Stdlib__Sys.max_array_length - 2 | 0;

function create(l) {
  if (!(0 <= l && l <= max_ephe_length)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.Ephemeron.create",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_ephe_create")(l);
}

function length(x) {
  return (x.length | 0) - 2 | 0;
}

function raise_if_invalid_offset(e, o, msg) {
  if (0 <= o && o < ((e.length | 0) - 2 | 0)) {
    return ;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg,
        Error: new Error()
      };
}

function get_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.get_key");
  return Caml_external_polyfill.resolve("caml_ephe_get_key")(e, o);
}

function get_key_copy(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.get_key_copy");
  return Caml_external_polyfill.resolve("caml_ephe_get_key_copy")(e, o);
}

function set_key(e, o, x) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.set_key");
  Caml_external_polyfill.resolve("caml_ephe_set_key")(e, o, x);
}

function unset_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.unset_key");
  Caml_external_polyfill.resolve("caml_ephe_unset_key")(e, o);
}

function check_key(e, o) {
  raise_if_invalid_offset(e, o, "Obj.Ephemeron.check_key");
  return Caml_external_polyfill.resolve("caml_ephe_check_key")(e, o);
}

function blit_key(e1, o1, e2, o2, l) {
  if (l < 0 || o1 < 0 || o1 > (((e1.length | 0) - 2 | 0) - l | 0) || o2 < 0 || o2 > (((e2.length | 0) - 2 | 0) - l | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Obj.Ephemeron.blit_key",
          Error: new Error()
        };
  }
  if (l !== 0) {
    return Caml_external_polyfill.resolve("caml_ephe_blit_key")(e1, o1, e2, o2, l);
  }
  
}

var first_non_constant_constructor_tag = 0;

var last_non_constant_constructor_tag = 243;

var forcing_tag = 244;

var cont_tag = 245;

var lazy_tag = 246;

var closure_tag = 247;

var object_tag = 248;

var infix_tag = 249;

var forward_tag = 250;

var no_scan_tag = 251;

var abstract_tag = 251;

var string_tag = 252;

var double_tag = 253;

var double_array_tag = 254;

var custom_tag = 255;

var int_tag = 1000;

var out_of_heap_tag = 1001;

var unaligned_tag = 1002;

function Ephemeron_get_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_get_data")(prim);
}

function Ephemeron_get_data_copy(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_get_data_copy")(prim);
}

function Ephemeron_set_data(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ephe_set_data")(prim0, prim1);
}

function Ephemeron_unset_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_unset_data")(prim);
}

function Ephemeron_check_data(prim) {
  return Caml_external_polyfill.resolve("caml_ephe_check_data")(prim);
}

function Ephemeron_blit_data(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ephe_blit_data")(prim0, prim1);
}

var Ephemeron = {
  create: create,
  length: length,
  get_key: get_key,
  get_key_copy: get_key_copy,
  set_key: set_key,
  unset_key: unset_key,
  check_key: check_key,
  blit_key: blit_key,
  get_data: Ephemeron_get_data,
  get_data_copy: Ephemeron_get_data_copy,
  set_data: Ephemeron_set_data,
  unset_data: Ephemeron_unset_data,
  check_data: Ephemeron_check_data,
  blit_data: Ephemeron_blit_data,
  max_ephe_length: max_ephe_length
};

export {
  is_block ,
  double_field ,
  set_double_field ,
  first_non_constant_constructor_tag ,
  last_non_constant_constructor_tag ,
  forcing_tag ,
  cont_tag ,
  lazy_tag ,
  closure_tag ,
  object_tag ,
  infix_tag ,
  forward_tag ,
  no_scan_tag ,
  abstract_tag ,
  string_tag ,
  double_tag ,
  double_array_tag ,
  custom_tag ,
  int_tag ,
  out_of_heap_tag ,
  unaligned_tag ,
  Closure ,
  Extension_constructor ,
  Ephemeron ,
}
/* No side effect */
`,nf=`// Generated by Melange

import * as CamlinternalOO from "./camlinternalOO.js";

var copy = CamlinternalOO.copy;

var new_method = CamlinternalOO.public_method_label;

var public_method_label = CamlinternalOO.public_method_label;

export {
  copy ,
  new_method ,
  public_method_label ,
}
/* CamlinternalOO Not a pure module */
`,tf=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

function some(v) {
  return Caml_option.some(v);
}

function value(o, $$default) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return $$default;
  }
}

function get(param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "option is None",
        Error: new Error()
      };
}

function bind(o, f) {
  if (o !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(o));
  }
  
}

function join(param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  }
  
}

function map(f, o) {
  if (o !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(o)));
  }
  
}

function fold(none, some, param) {
  if (param !== undefined) {
    return Curry._1(some, Caml_option.valFromOption(param));
  } else {
    return none;
  }
}

function iter(f, param) {
  if (param !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(param));
  }
  
}

function is_none(param) {
  return param === undefined;
}

function is_some(param) {
  return param !== undefined;
}

function equal(eq, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return false;
    }
  } else {
    return o1 === undefined;
  }
}

function compare(cmp, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(cmp, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return 1;
    }
  } else if (o1 !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function to_result(none, param) {
  if (param !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(param)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: none
          };
  }
}

function to_list(param) {
  if (param !== undefined) {
    return {
            hd: Caml_option.valFromOption(param),
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq(param) {
  if (param === undefined) {
    return Stdlib__Seq.empty;
  }
  var partial_arg = Caml_option.valFromOption(param);
  return function (param) {
    return Stdlib__Seq.$$return(partial_arg, param);
  };
}

var none;

export {
  none ,
  some ,
  value ,
  get ,
  bind ,
  join ,
  map ,
  fold ,
  iter ,
  is_none ,
  is_some ,
  equal ,
  compare ,
  to_result ,
  to_list ,
  to_seq ,
}
/* No side effect */
`,ef=`// Generated by Melange

import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Fun from "./fun.js";

function with_open(openfun, s, f) {
  var oc = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
                Stdlib.close_out_noerr(oc);
              }), (function (param) {
                return Curry._1(f, oc);
              }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_out_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_out, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
                return Stdlib.open_out_gen(flags, perm, param);
              }), s, f);
}

var seek = Stdlib.LargeFile.seek_out;

var pos = Stdlib.LargeFile.pos_out;

var length = Stdlib.LargeFile.out_channel_length;

var stdout = Stdlib.stdout;

var stderr = Stdlib.stderr;

var open_bin = Stdlib.open_out_bin;

var open_text = Stdlib.open_out;

var open_gen = Stdlib.open_out_gen;

var close = Stdlib.close_out;

var close_noerr = Stdlib.close_out_noerr;

var output_char = Stdlib.output_char;

var output_byte = Stdlib.output_byte;

var output_string = Stdlib.output_string;

var output_bytes = Stdlib.output_bytes;

var output = Stdlib.output;

var output_substring = Stdlib.output_substring;

var flush = Stdlib.flush;

var flush_all = Stdlib.flush_all;

var set_binary_mode = Stdlib.set_binary_mode_out;

function set_buffered(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_buffered")(prim0, prim1);
}

function is_buffered(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_buffered")(prim);
}

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

export {
  stdout ,
  stderr ,
  open_bin ,
  open_text ,
  open_gen ,
  with_open_bin ,
  with_open_text ,
  with_open_gen ,
  close ,
  close_noerr ,
  output_char ,
  output_byte ,
  output_string ,
  output_bytes ,
  output ,
  output_substring ,
  flush ,
  flush_all ,
  seek ,
  pos ,
  length ,
  set_binary_mode ,
  set_buffered ,
  is_buffered ,
  isatty ,
}
/* Stdlib__Fun Not a pure module */
`,rf=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_parser from "melange.js/caml_parser.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Lexing from "./lexing.js";

var YYexit = /* @__PURE__ */Caml_exceptions.create("Stdlib.Parsing.YYexit");

var Parse_error = /* @__PURE__ */Caml_exceptions.create("Stdlib.Parsing.Parse_error");

var env = {
  s_stack: Caml_array.make(100, 0),
  v_stack: Caml_array.make(100, undefined),
  symb_start_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  symb_end_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  stacksize: 100,
  stackbase: 0,
  curr_char: 0,
  lval: undefined,
  symb_start: Stdlib__Lexing.dummy_pos,
  symb_end: Stdlib__Lexing.dummy_pos,
  asp: 0,
  rule_len: 0,
  rule_number: 0,
  sp: 0,
  state: 0,
  errflag: 0
};

function grow_stacks(param) {
  var oldsize = env.stacksize;
  var newsize = (oldsize << 1);
  var new_s = Caml_array.make(newsize, 0);
  var new_v = Caml_array.make(newsize, undefined);
  var new_start = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  var new_end = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  Stdlib__Array.blit(env.s_stack, 0, new_s, 0, oldsize);
  env.s_stack = new_s;
  Stdlib__Array.blit(env.v_stack, 0, new_v, 0, oldsize);
  env.v_stack = new_v;
  Stdlib__Array.blit(env.symb_start_stack, 0, new_start, 0, oldsize);
  env.symb_start_stack = new_start;
  Stdlib__Array.blit(env.symb_end_stack, 0, new_end, 0, oldsize);
  env.symb_end_stack = new_end;
  env.stacksize = newsize;
}

function clear_parser(param) {
  Stdlib__Array.fill(env.v_stack, 0, env.stacksize, undefined);
  env.lval = undefined;
}

var current_lookahead_fun = {
  contents: (function (param) {
      return false;
    })
};

function yyparse(tables, start, lexer, lexbuf) {
  var init_asp = env.asp;
  var init_sp = env.sp;
  var init_stackbase = env.stackbase;
  var init_state = env.state;
  var init_curr_char = env.curr_char;
  var init_lval = env.lval;
  var init_errflag = env.errflag;
  env.stackbase = env.sp + 1 | 0;
  env.curr_char = start;
  env.symb_end = lexbuf.lex_curr_p;
  try {
    var _cmd = /* Start */0;
    var _arg;
    while(true) {
      var arg = _arg;
      var cmd = _cmd;
      var match = Caml_parser.caml_parse_engine(tables, env, cmd, arg);
      switch (match) {
        case /* Read_token */0 :
            var t = Curry._1(lexer, lexbuf);
            env.symb_start = lexbuf.lex_start_p;
            env.symb_end = lexbuf.lex_curr_p;
            _arg = t;
            _cmd = /* Token_read */1;
            continue ;
        case /* Raise_parse_error */1 :
            throw {
                  MEL_EXN_ID: Parse_error,
                  Error: new Error()
                };
        case /* Grow_stacks_1 */2 :
            grow_stacks(undefined);
            _arg = undefined;
            _cmd = /* Stacks_grown_1 */2;
            continue ;
        case /* Grow_stacks_2 */3 :
            grow_stacks(undefined);
            _arg = undefined;
            _cmd = /* Stacks_grown_2 */3;
            continue ;
        case /* Compute_semantic_action */4 :
            var match$1;
            try {
              match$1 = [
                /* Semantic_action_computed */4,
                Curry._1(Caml_array.get(tables.actions, env.rule_number), env)
              ];
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Parse_error) {
                match$1 = [
                  /* Error_detected */5,
                  undefined
                ];
              } else {
                throw exn;
              }
            }
            _arg = match$1[1];
            _cmd = match$1[0];
            continue ;
        case /* Call_error_function */5 :
            Curry._1(tables.error_function, "syntax error");
            _arg = undefined;
            _cmd = /* Error_detected */5;
            continue ;
        
      }
    };
  }
  catch (raw_exn$1){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    var curr_char = env.curr_char;
    env.asp = init_asp;
    env.sp = init_sp;
    env.stackbase = init_stackbase;
    env.state = init_state;
    env.curr_char = init_curr_char;
    env.lval = init_lval;
    env.errflag = init_errflag;
    if (exn$1.MEL_EXN_ID === YYexit) {
      return exn$1._1;
    }
    current_lookahead_fun.contents = (function (tok) {
        if (typeof tok !== "number") {
          return Caml_array.get(tables.transl_block, tok.TAG | 0) === curr_char;
        } else {
          return Caml_array.get(tables.transl_const, tok) === curr_char;
        }
      });
    throw exn$1;
  }
}

function peek_val(env, n) {
  return Caml_array.get(env.v_stack, env.asp - n | 0);
}

function symbol_start_pos(param) {
  var _i = env.rule_len;
  while(true) {
    var i = _i;
    if (i <= 0) {
      return Caml_array.get(env.symb_end_stack, env.asp);
    }
    var st = Caml_array.get(env.symb_start_stack, (env.asp - i | 0) + 1 | 0);
    var en = Caml_array.get(env.symb_end_stack, (env.asp - i | 0) + 1 | 0);
    if (Caml_obj.caml_notequal(st, en)) {
      return st;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function symbol_end_pos(param) {
  return Caml_array.get(env.symb_end_stack, env.asp);
}

function rhs_start_pos(n) {
  return Caml_array.get(env.symb_start_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function rhs_end_pos(n) {
  return Caml_array.get(env.symb_end_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function symbol_start(param) {
  return symbol_start_pos(undefined).pos_cnum;
}

function symbol_end(param) {
  return symbol_end_pos(undefined).pos_cnum;
}

function rhs_start(n) {
  return rhs_start_pos(n).pos_cnum;
}

function rhs_end(n) {
  return rhs_end_pos(n).pos_cnum;
}

function is_current_lookahead(tok) {
  return Curry._1(current_lookahead_fun.contents, tok);
}

function parse_error(param) {
  
}

var set_trace = Caml_parser.caml_set_parser_trace;

export {
  symbol_start ,
  symbol_end ,
  rhs_start ,
  rhs_end ,
  symbol_start_pos ,
  symbol_end_pos ,
  rhs_start_pos ,
  rhs_end_pos ,
  clear_parser ,
  Parse_error ,
  set_trace ,
  YYexit ,
  yyparse ,
  peek_val ,
  is_current_lookahead ,
  parse_error ,
}
/* No side effect */
`,af=`// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Atomic from "./atomic.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Printf from "./printf.js";

var printers = Stdlib__Atomic.make(/* [] */0);

var locfmt = /* Format */{
  _0: {
    TAG: /* String_literal */11,
    _0: "File \\"",
    _1: {
      TAG: /* String */2,
      _0: /* No_padding */0,
      _1: {
        TAG: /* String_literal */11,
        _0: "\\", line ",
        _1: {
          TAG: /* Int */4,
          _0: /* Int_d */0,
          _1: /* No_padding */0,
          _2: /* No_precision */0,
          _3: {
            TAG: /* String_literal */11,
            _0: ", characters ",
            _1: {
              TAG: /* Int */4,
              _0: /* Int_d */0,
              _1: /* No_padding */0,
              _2: /* No_precision */0,
              _3: {
                TAG: /* Char_literal */12,
                _0: /* '-' */45,
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: ": ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: /* End_of_format */0
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  _1: "File \\"%s\\", line %d, characters %d-%d: %s"
};

var fields = (function(x){
  var s = ""
  var index = 1
  while ("_"+index in x){
    s += x ["_" + index];
    ++ index
  }
  if(index === 1){
    return s
  }
  return "(" + s + ")"
});

function use_printers(x) {
  var _param = Stdlib__Atomic.get(printers);
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var tl = param.tl;
    var val;
    try {
      val = Curry._1(param.hd, x);
    }
    catch (exn){
      _param = tl;
      continue ;
    }
    if (val !== undefined) {
      return Caml_option.some(Caml_option.valFromOption(val));
    }
    _param = tl;
    continue ;
  };
}

function to_string_default(x) {
  if (x.MEL_EXN_ID === Stdlib.Out_of_memory) {
    return "Out of memory";
  }
  if (x.MEL_EXN_ID === Stdlib.Stack_overflow) {
    return "Stack overflow";
  }
  if (x.MEL_EXN_ID === Stdlib.Match_failure) {
    var match = x._1;
    var $$char = match[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match[0], match[1], $$char, $$char + 5 | 0, "Pattern matching failed");
  }
  if (x.MEL_EXN_ID === Stdlib.Assert_failure) {
    var match$1 = x._1;
    var $$char$1 = match$1[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match$1[0], match$1[1], $$char$1, $$char$1 + 6 | 0, "Assertion failed");
  }
  if (x.MEL_EXN_ID === Stdlib.Undefined_recursive_module) {
    var match$2 = x._1;
    var $$char$2 = match$2[2];
    return Curry._5(Stdlib__Printf.sprintf(locfmt), match$2[0], match$2[1], $$char$2, $$char$2 + 6 | 0, "Undefined recursive module");
  }
  var constructor = Caml_exceptions.caml_exn_slot_name(x);
  return constructor + fields(x);
}

function to_string(e) {
  var s = use_printers(e);
  if (s !== undefined) {
    return s;
  } else {
    return to_string_default(e);
  }
}

function print(fct, arg) {
  try {
    return Curry._1(fct, arg);
  }
  catch (raw_x){
    var x = Caml_js_exceptions.internalToOCamlException(raw_x);
    Curry._1(Stdlib__Printf.eprintf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Uncaught exception: ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '\\n' */10,
                    _1: /* End_of_format */0
                  }
                }
              },
              _1: "Uncaught exception: %s\\n"
            }), to_string(x));
    Caml_io.caml_ml_flush(Stdlib.stderr);
    throw x;
  }
}

function $$catch(fct, arg) {
  try {
    return Curry._1(fct, arg);
  }
  catch (raw_x){
    var x = Caml_js_exceptions.internalToOCamlException(raw_x);
    Caml_io.caml_ml_flush(Stdlib.stdout);
    Curry._1(Stdlib__Printf.eprintf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Uncaught exception: ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '\\n' */10,
                    _1: /* End_of_format */0
                  }
                }
              },
              _1: "Uncaught exception: %s\\n"
            }), to_string(x));
    return Stdlib.exit(2);
  }
}

function raw_backtrace_entries(bt) {
  return bt;
}

function convert_raw_backtrace_slot(param) {
  throw {
        MEL_EXN_ID: "Failure",
        _1: "convert_raw_backtrace_slot not implemented",
        Error: new Error()
      };
}

function convert_raw_backtrace(bt) {
  try {
    return undefined;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw exn;
  }
}

function format_backtrace_slot(pos, slot) {
  var info = function (is_raise) {
    if (is_raise) {
      if (pos === 0) {
        return "Raised at";
      } else {
        return "Re-raised at";
      }
    } else if (pos === 0) {
      return "Raised by primitive operation at";
    } else {
      return "Called from";
    }
  };
  if (slot.TAG === /* Known_location */0) {
    return Curry._7(Stdlib__Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char_literal */12,
                        _0: /* ' ' */32,
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: " in file \\"",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* Char_literal */12,
                                _0: /* '"' */34,
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: ", line ",
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: {
                                        TAG: /* String_literal */11,
                                        _0: ", characters ",
                                        _1: {
                                          TAG: /* Int */4,
                                          _0: /* Int_d */0,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* Char_literal */12,
                                            _0: /* '-' */45,
                                            _1: {
                                              TAG: /* Int */4,
                                              _0: /* Int_d */0,
                                              _1: /* No_padding */0,
                                              _2: /* No_precision */0,
                                              _3: /* End_of_format */0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s %s in file \\"%s\\"%s, line %d, characters %d-%d"
                  }), info(slot.is_raise), slot.defname, slot.filename, slot.is_inline ? " (inlined)" : "", slot.line_number, slot.start_char, slot.end_char);
  } else if (slot.is_raise) {
    return ;
  } else {
    return Curry._1(Stdlib__Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: " unknown location",
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "%s unknown location"
                  }), info(false));
  }
}

function print_raw_backtrace(outchan, raw_backtrace) {
  var backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return Stdlib__Printf.fprintf(outchan, /* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "(Program not linked with -g, cannot print stack backtrace)\\n",
                  _1: /* End_of_format */0
                },
                _1: "(Program not linked with -g, cannot print stack backtrace)\\n"
              });
  }
  for(var i = 0 ,i_finish = backtrace.length; i < i_finish; ++i){
    var str = format_backtrace_slot(i, Caml_array.get(backtrace, i));
    if (str !== undefined) {
      Curry._1(Stdlib__Printf.fprintf(outchan, /* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '\\n' */10,
                    _1: /* End_of_format */0
                  }
                },
                _1: "%s\\n"
              }), str);
    }
    
  }
}

function print_backtrace(outchan) {
  print_raw_backtrace(outchan, undefined);
}

function raw_backtrace_to_string(raw_backtrace) {
  var backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return "(Program not linked with -g, cannot print stack backtrace)\\n";
  }
  var b = Stdlib__Buffer.create(1024);
  for(var i = 0 ,i_finish = backtrace.length; i < i_finish; ++i){
    var str = format_backtrace_slot(i, Caml_array.get(backtrace, i));
    if (str !== undefined) {
      Curry._1(Stdlib__Printf.bprintf(b, /* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* '\\n' */10,
                    _1: /* End_of_format */0
                  }
                },
                _1: "%s\\n"
              }), str);
    }
    
  }
  return Stdlib__Buffer.contents(b);
}

function backtrace_slot_is_raise(param) {
  return param.is_raise;
}

function backtrace_slot_is_inline(param) {
  if (param.TAG === /* Known_location */0) {
    return param.is_inline;
  } else {
    return false;
  }
}

function backtrace_slot_location(param) {
  if (param.TAG === /* Known_location */0) {
    return {
            filename: param.filename,
            line_number: param.line_number,
            start_char: param.start_char,
            end_char: param.end_char
          };
  }
  
}

function backtrace_slot_defname(param) {
  if (param.TAG === /* Known_location */0 && param.defname !== "") {
    return param.defname;
  }
  
}

function backtrace_slots(raw_backtrace) {
  var backtrace = convert_raw_backtrace(raw_backtrace);
  if (backtrace === undefined) {
    return ;
  }
  var usable_slot = function (param) {
    if (param.TAG === /* Known_location */0) {
      return true;
    } else {
      return false;
    }
  };
  var exists_usable = function (_i) {
    while(true) {
      var i = _i;
      if (i === -1) {
        return false;
      }
      if (usable_slot(Caml_array.get(backtrace, i))) {
        return true;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  if (exists_usable(backtrace.length - 1 | 0)) {
    return backtrace;
  }
  
}

function backtrace_slots_of_raw_entry(entry) {
  return backtrace_slots([entry]);
}

function raw_backtrace_length(bt) {
  return bt.length;
}

function get_backtrace(param) {
  return raw_backtrace_to_string(undefined);
}

function register_printer(fn) {
  while(true) {
    var old_printers = Stdlib__Atomic.get(printers);
    var new_printers = {
      hd: fn,
      tl: old_printers
    };
    var success = Stdlib__Atomic.compare_and_set(printers, old_printers, new_printers);
    if (success) {
      return ;
    }
    continue ;
  };
}

var errors = [
  "",
  "(Cannot print locations:\\n bytecode executable program file not found)",
  "(Cannot print locations:\\n bytecode executable program file appears to be corrupt)",
  "(Cannot print locations:\\n bytecode executable program file has wrong magic number)",
  "(Cannot print locations:\\n bytecode executable program file cannot be opened;\\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"
];

function default_uncaught_exception_handler(exn, raw_backtrace) {
  Curry._1(Stdlib__Printf.eprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "Fatal error: exception ",
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* Char_literal */12,
                  _0: /* '\\n' */10,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "Fatal error: exception %s\\n"
          }), to_string(exn));
  print_raw_backtrace(Stdlib.stderr, raw_backtrace);
  var status = Caml_external_polyfill.resolve("caml_ml_debug_info_status")(undefined);
  if (status < 0) {
    console.error(Caml_array.get(errors, Stdlib.abs(status)));
  }
  Caml_io.caml_ml_flush(Stdlib.stderr);
}

function set_uncaught_exception_handler(param) {
  
}

function record_backtrace(prim) {
  
}

function backtrace_status(prim) {
  
}

function get_raw_backtrace(prim) {
  
}

var Slot = {
  is_raise: backtrace_slot_is_raise,
  is_inline: backtrace_slot_is_inline,
  $$location: backtrace_slot_location,
  name: backtrace_slot_defname,
  format: format_backtrace_slot
};

function get_raw_backtrace_slot(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_raw_backtrace_slot")(prim0, prim1);
}

function get_raw_backtrace_next_slot(prim) {
  return Caml_external_polyfill.resolve("caml_raw_backtrace_next_slot")(prim);
}

var exn_slot_id = Caml_exceptions.caml_exn_slot_id;

var exn_slot_name = Caml_exceptions.caml_exn_slot_name;

export {
  to_string ,
  to_string_default ,
  print ,
  $$catch ,
  print_backtrace ,
  get_backtrace ,
  record_backtrace ,
  backtrace_status ,
  register_printer ,
  use_printers ,
  raw_backtrace_entries ,
  get_raw_backtrace ,
  print_raw_backtrace ,
  raw_backtrace_to_string ,
  default_uncaught_exception_handler ,
  set_uncaught_exception_handler ,
  backtrace_slots ,
  backtrace_slots_of_raw_entry ,
  Slot ,
  raw_backtrace_length ,
  get_raw_backtrace_slot ,
  convert_raw_backtrace_slot ,
  get_raw_backtrace_next_slot ,
  exn_slot_id ,
  exn_slot_name ,
}
/* printers Not a pure module */
`,sf=`// Generated by Melange

import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";

function kfprintf(k, o, param) {
  return CamlinternalFormat.make_printf((function (acc) {
                CamlinternalFormat.output_acc(o, acc);
                return Curry._1(k, o);
              }), /* End_of_acc */0, param._0);
}

function kbprintf(k, b, param) {
  return CamlinternalFormat.make_printf((function (acc) {
                CamlinternalFormat.bufput_acc(b, acc);
                return Curry._1(k, b);
              }), /* End_of_acc */0, param._0);
}

function ikfprintf(k, oc, param) {
  return CamlinternalFormat.make_iprintf(k, oc, param._0);
}

function fprintf(oc, fmt) {
  return kfprintf((function (prim) {
                
              }), oc, fmt);
}

function bprintf(b, fmt) {
  return kbprintf((function (prim) {
                
              }), b, fmt);
}

function ifprintf(oc, fmt) {
  return ikfprintf((function (prim) {
                
              }), oc, fmt);
}

function ibprintf(b, fmt) {
  return ikfprintf((function (prim) {
                
              }), b, fmt);
}

function printf(fmt) {
  return fprintf(Stdlib.stdout, fmt);
}

function eprintf(fmt) {
  return fprintf(Stdlib.stderr, fmt);
}

function ksprintf(k, param) {
  var k$p = function (acc) {
    var buf = Stdlib__Buffer.create(64);
    CamlinternalFormat.strput_acc(buf, acc);
    return Curry._1(k, Stdlib__Buffer.contents(buf));
  };
  return CamlinternalFormat.make_printf(k$p, /* End_of_acc */0, param._0);
}

function sprintf(fmt) {
  return ksprintf((function (s) {
                return s;
              }), fmt);
}

var ikbprintf = ikfprintf;

var kprintf = ksprintf;

export {
  fprintf ,
  printf ,
  eprintf ,
  sprintf ,
  bprintf ,
  ifprintf ,
  ibprintf ,
  kfprintf ,
  ikfprintf ,
  ksprintf ,
  kbprintf ,
  ikbprintf ,
  kprintf ,
}
/* No side effect */
`,of=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

var Empty = /* @__PURE__ */Caml_exceptions.create("Stdlib.Queue.Empty");

function create(param) {
  return {
          length: 0,
          first: /* Nil */0,
          last: /* Nil */0
        };
}

function clear(q) {
  q.length = 0;
  q.first = /* Nil */0;
  q.last = /* Nil */0;
}

function add(x, q) {
  var cell = /* Cons */{
    content: x,
    next: /* Nil */0
  };
  var last = q.last;
  if (last) {
    q.length = q.length + 1 | 0;
    last.next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
}

function peek(q) {
  var match = q.first;
  if (match) {
    return match.content;
  }
  throw {
        MEL_EXN_ID: Empty,
        Error: new Error()
      };
}

function peek_opt(q) {
  var match = q.first;
  if (match) {
    return Caml_option.some(match.content);
  }
  
}

function take(q) {
  var match = q.first;
  if (match) {
    var content = match.content;
    var match$1 = match.next;
    if (match$1) {
      var next = match.next;
      q.length = q.length - 1 | 0;
      q.first = next;
      return content;
    }
    clear(q);
    return content;
  }
  throw {
        MEL_EXN_ID: Empty,
        Error: new Error()
      };
}

function take_opt(q) {
  var match = q.first;
  if (!match) {
    return ;
  }
  var content = match.content;
  var match$1 = match.next;
  if (match$1) {
    var next = match.next;
    q.length = q.length - 1 | 0;
    q.first = next;
    return Caml_option.some(content);
  }
  clear(q);
  return Caml_option.some(content);
}

function copy(q) {
  var q_res = {
    length: q.length,
    first: /* Nil */0,
    last: /* Nil */0
  };
  var _prev = /* Nil */0;
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    var prev = _prev;
    if (cell) {
      var next = cell.next;
      var res = /* Cons */{
        content: cell.content,
        next: /* Nil */0
      };
      if (prev) {
        prev.next = res;
      } else {
        q_res.first = res;
      }
      _cell = next;
      _prev = res;
      continue ;
    }
    q_res.last = prev;
    return q_res;
  };
}

function is_empty(q) {
  return q.length === 0;
}

function length(q) {
  return q.length;
}

function iter(f, q) {
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    if (!cell) {
      return ;
    }
    var next = cell.next;
    Curry._1(f, cell.content);
    _cell = next;
    continue ;
  };
}

function fold(f, accu, q) {
  var _accu = accu;
  var _cell = q.first;
  while(true) {
    var cell = _cell;
    var accu$1 = _accu;
    if (!cell) {
      return accu$1;
    }
    var next = cell.next;
    var accu$2 = Curry._2(f, accu$1, cell.content);
    _cell = next;
    _accu = accu$2;
    continue ;
  };
}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return ;
  }
  var last = q2.last;
  if (last) {
    q2.length = q2.length + q1.length | 0;
    last.next = q1.first;
    q2.last = q1.last;
    return clear(q1);
  } else {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear(q1);
  }
}

function to_seq(q) {
  var aux = function (c, param) {
    if (!c) {
      return /* Nil */0;
    }
    var next = c.next;
    return /* Cons */{
            _0: c.content,
            _1: (function (param) {
                return aux(next, param);
              })
          };
  };
  var partial_arg = q.first;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function add_seq(q, i) {
  Stdlib__Seq.iter((function (x) {
          add(x, q);
        }), i);
}

function of_seq(g) {
  var q = {
    length: 0,
    first: /* Nil */0,
    last: /* Nil */0
  };
  add_seq(q, g);
  return q;
}

var push = add;

var pop = take;

var top = peek;

export {
  Empty ,
  create ,
  add ,
  push ,
  take ,
  take_opt ,
  pop ,
  peek ,
  peek_opt ,
  top ,
  clear ,
  copy ,
  is_empty ,
  length ,
  iter ,
  fold ,
  transfer ,
  to_seq ,
  add_seq ,
  of_seq ,
}
/* No side effect */
`,_f=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Digest from "./digest.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Int32 from "./int32.js";
import * as Stdlib__Int64 from "./int64.js";

function random_seed(param) {
  return [(Math.floor(Math.random()*0x7fffffff))];
}

function assign(st1, st2) {
  Stdlib__Array.blit(st2.st, 0, st1.st, 0, 55);
  st1.idx = st2.idx;
}

function full_init(s, seed) {
  var combine = function (accu, x) {
    return Stdlib__Digest.string(accu + Caml_format.caml_format_int("%d", x));
  };
  var extract = function (d) {
    return ((Caml_string.get(d, 0) + (Caml_string.get(d, 1) << 8) | 0) + (Caml_string.get(d, 2) << 16) | 0) + (Caml_string.get(d, 3) << 24) | 0;
  };
  var seed$1 = seed.length === 0 ? [0] : seed;
  var l = seed$1.length;
  for(var i = 0; i <= 54; ++i){
    Caml_array.set(s.st, i, i);
  }
  var accu = "x";
  for(var i$1 = 0 ,i_finish = 54 + Stdlib__Int.max(55, l) | 0; i$1 <= i_finish; ++i$1){
    var j = i$1 % 55;
    var k = i$1 % l;
    accu = combine(accu, Caml_array.get(seed$1, k));
    Caml_array.set(s.st, j, (Caml_array.get(s.st, j) ^ extract(accu)) & 1073741823);
  }
  s.idx = 0;
}

function make(seed) {
  var result = {
    st: Caml_array.make(55, 0),
    idx: 0
  };
  full_init(result, seed);
  return result;
}

function make_self_init(param) {
  return make(random_seed(undefined));
}

function copy(s) {
  var result = {
    st: Caml_array.make(55, 0),
    idx: 0
  };
  assign(result, s);
  return result;
}

function bits(s) {
  s.idx = (s.idx + 1 | 0) % 55;
  var curval = Caml_array.get(s.st, s.idx);
  var newval = Caml_array.get(s.st, (s.idx + 24 | 0) % 55) + (curval ^ (curval >>> 25) & 31) | 0;
  var newval30 = newval & 1073741823;
  Caml_array.set(s.st, s.idx, newval30);
  return newval30;
}

function intaux(s, n) {
  while(true) {
    var r = bits(s);
    var v = r % n;
    if ((r - v | 0) <= ((1073741823 - n | 0) + 1 | 0)) {
      return v;
    }
    continue ;
  };
}

function $$int(s, bound) {
  if (bound > 1073741823 || bound <= 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int",
          Error: new Error()
        };
  }
  return intaux(s, bound);
}

function full_int(s, bound) {
  if (bound <= 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.full_int",
          Error: new Error()
        };
  }
  if (bound > 1073741823) {
    while(true) {
      var b1 = bits(s);
      var b2 = bits(s);
      var match;
      if (bound <= 2147483647) {
        var bpos = ((b2 & 1073725440) << 1) | (b1 >>> 15);
        match = [
          bpos,
          2147483647
        ];
      } else {
        var b3 = bits(s);
        var bpos$1 = ((((b3 & 1073741312) << 12) | (b2 >>> 9)) << 20) | (b1 >>> 10);
        match = [
          bpos$1,
          Stdlib.max_int
        ];
      }
      var r = match[0];
      var v = r % bound;
      if ((r - v | 0) <= ((match[1] - bound | 0) + 1 | 0)) {
        return v;
      }
      continue ;
    };
  } else {
    return intaux(s, bound);
  }
}

function int32(s, bound) {
  if (bound <= 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int32",
          Error: new Error()
        };
  }
  while(true) {
    var b1 = bits(s);
    var b2 = ((bits(s) & 1) << 30);
    var r = b1 | b2;
    var v = r % bound;
    if ((r - v | 0) <= ((Stdlib__Int32.max_int - bound | 0) + 1 | 0)) {
      return v;
    }
    continue ;
  };
}

function int64(s, bound) {
  if (Caml.i64_le(bound, Caml_int64.zero)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Random.int64",
          Error: new Error()
        };
  }
  while(true) {
    var b1 = Caml_int64.of_int32(bits(s));
    var b2 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s)), 30);
    var b3 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s) & 7), 60);
    var r = Caml_int64.or_(b1, Caml_int64.or_(b2, b3));
    var v = Caml_int64.mod_(r, bound);
    if (!Caml.i64_gt(Caml_int64.sub(r, v), Caml_int64.add(Caml_int64.sub(Stdlib__Int64.max_int, bound), Caml_int64.one))) {
      return v;
    }
    continue ;
  };
}

function rawfloat(s) {
  var r1 = bits(s);
  var r2 = bits(s);
  return (r1 / 1073741824.0 + r2) / 1073741824.0;
}

function $$float(s, bound) {
  return rawfloat(s) * bound;
}

function bool(s) {
  return (bits(s) & 1) === 0;
}

function bits32(s) {
  var b1 = (bits(s) >>> 14);
  var b2 = (bits(s) >>> 14);
  return b1 | (b2 << 16);
}

function bits64(s) {
  var b1 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 9);
  var b2 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 9);
  var b3 = Caml_int64.lsr_(Caml_int64.of_int32(bits(s)), 8);
  return Caml_int64.or_(b1, Caml_int64.or_(Caml_int64.lsl_(b2, 21), Caml_int64.lsl_(b3, 42)));
}

var $$default = {
  st: [
    987910699,
    495797812,
    364182224,
    414272206,
    318284740,
    990407751,
    383018966,
    270373319,
    840823159,
    24560019,
    536292337,
    512266505,
    189156120,
    730249596,
    143776328,
    51606627,
    140166561,
    366354223,
    1003410265,
    700563762,
    981890670,
    913149062,
    526082594,
    1021425055,
    784300257,
    667753350,
    630144451,
    949649812,
    48546892,
    415514493,
    258888527,
    511570777,
    89983870,
    283659902,
    308386020,
    242688715,
    482270760,
    865188196,
    1027664170,
    207196989,
    193777847,
    619708188,
    671350186,
    149669678,
    257044018,
    87658204,
    558145612,
    183450813,
    28133145,
    901332182,
    710253903,
    510646120,
    652377910,
    409934019,
    801085050
  ],
  idx: 0
};

function bits$1(param) {
  return bits($$default);
}

function $$int$1(bound) {
  return $$int($$default, bound);
}

function full_int$1(bound) {
  return full_int($$default, bound);
}

function int32$1(bound) {
  return int32($$default, bound);
}

function int64$1(bound) {
  return int64($$default, bound);
}

function $$float$1(scale) {
  return rawfloat($$default) * scale;
}

function bool$1(param) {
  return bool($$default);
}

function bits32$1(param) {
  return bits32($$default);
}

function bits64$1(param) {
  return bits64($$default);
}

function full_init$1(seed) {
  full_init($$default, seed);
}

function init(seed) {
  full_init($$default, [seed]);
}

function self_init(param) {
  full_init$1(random_seed(undefined));
}

function get_state(param) {
  return copy($$default);
}

function set_state(s) {
  assign($$default, s);
}

var State = {
  make: make,
  make_self_init: make_self_init,
  copy: copy,
  bits: bits,
  $$int: $$int,
  full_int: full_int,
  int32: int32,
  int64: int64,
  $$float: $$float,
  bool: bool,
  bits32: bits32,
  bits64: bits64
};

export {
  init ,
  full_init$1 as full_init,
  self_init ,
  bits$1 as bits,
  $$int$1 as $$int,
  full_int$1 as full_int,
  int32$1 as int32,
  int64$1 as int64,
  $$float$1 as $$float,
  bool$1 as bool,
  bits32$1 as bits32,
  bits64$1 as bits64,
  State ,
  get_state ,
  set_state ,
}
/* Stdlib__Int32 Not a pure module */
`,lf=`// Generated by Melange

import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

function ok(v) {
  return {
          TAG: /* Ok */0,
          _0: v
        };
}

function error(e) {
  return {
          TAG: /* Error */1,
          _0: e
        };
}

function value(r, $$default) {
  if (r.TAG === /* Ok */0) {
    return r._0;
  } else {
    return $$default;
  }
}

function get_ok(param) {
  if (param.TAG === /* Ok */0) {
    return param._0;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "result is Error _",
        Error: new Error()
      };
}

function get_error(param) {
  if (param.TAG !== /* Ok */0) {
    return param._0;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "result is Ok _",
        Error: new Error()
      };
}

function bind(r, f) {
  if (r.TAG === /* Ok */0) {
    return Curry._1(f, r._0);
  } else {
    return r;
  }
}

function join(e) {
  if (e.TAG === /* Ok */0) {
    return e._0;
  } else {
    return e;
  }
}

function map(f, e) {
  if (e.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, e._0)
          };
  } else {
    return e;
  }
}

function map_error(f, v) {
  if (v.TAG === /* Ok */0) {
    return v;
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, v._0)
          };
  }
}

function fold(ok, error, param) {
  if (param.TAG === /* Ok */0) {
    return Curry._1(ok, param._0);
  } else {
    return Curry._1(error, param._0);
  }
}

function iter(f, param) {
  if (param.TAG === /* Ok */0) {
    return Curry._1(f, param._0);
  }
  
}

function iter_error(f, param) {
  if (param.TAG === /* Ok */0) {
    return ;
  } else {
    return Curry._1(f, param._0);
  }
}

function is_ok(param) {
  if (param.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function is_error(param) {
  if (param.TAG === /* Ok */0) {
    return false;
  } else {
    return true;
  }
}

function equal(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return false;
    }
  } else if (r1.TAG === /* Ok */0) {
    return false;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function compare(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return -1;
    }
  } else if (r1.TAG === /* Ok */0) {
    return 1;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function to_option(param) {
  if (param.TAG === /* Ok */0) {
    return Caml_option.some(param._0);
  }
  
}

function to_list(param) {
  if (param.TAG === /* Ok */0) {
    return {
            hd: param._0,
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq(param) {
  if (param.TAG !== /* Ok */0) {
    return Stdlib__Seq.empty;
  }
  var partial_arg = param._0;
  return function (param) {
    return Stdlib__Seq.$$return(partial_arg, param);
  };
}

export {
  ok ,
  error ,
  value ,
  get_ok ,
  get_error ,
  bind ,
  join ,
  map ,
  map_error ,
  fold ,
  iter ,
  iter_error ,
  is_ok ,
  is_error ,
  equal ,
  compare ,
  to_option ,
  to_list ,
  to_seq ,
}
/* No side effect */
`,cf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as CamlinternalFormat from "./camlinternalFormat.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__String from "./string.js";

function next_char(ib) {
  try {
    var c = Curry._1(ib.ic_get_next_char, undefined);
    ib.ic_current_char = c;
    ib.ic_current_char_is_valid = true;
    ib.ic_char_count = ib.ic_char_count + 1 | 0;
    if (c === /* '\\n' */10) {
      ib.ic_line_count = ib.ic_line_count + 1 | 0;
    }
    return c;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      ib.ic_current_char = /* '\\000' */0;
      ib.ic_current_char_is_valid = false;
      ib.ic_eof = true;
      return /* '\\000' */0;
    }
    throw exn;
  }
}

function peek_char(ib) {
  if (ib.ic_current_char_is_valid) {
    return ib.ic_current_char;
  } else {
    return next_char(ib);
  }
}

function checked_peek_char(ib) {
  var c = peek_char(ib);
  if (ib.ic_eof) {
    throw {
          MEL_EXN_ID: Stdlib.End_of_file,
          Error: new Error()
        };
  }
  return c;
}

function end_of_input(ib) {
  peek_char(ib);
  return ib.ic_eof;
}

function beginning_of_input(ib) {
  return ib.ic_char_count === 0;
}

function name_of_input(ib) {
  var _ic = ib.ic_input_name;
  if (typeof _ic === "number") {
    if (_ic === /* From_function */0) {
      return "unnamed function";
    } else {
      return "unnamed character string";
    }
  } else if (_ic.TAG === /* From_channel */0) {
    return "unnamed Stdlib input channel";
  } else {
    return _ic._0;
  }
}

function char_count(ib) {
  if (ib.ic_current_char_is_valid) {
    return ib.ic_char_count - 1 | 0;
  } else {
    return ib.ic_char_count;
  }
}

function token(ib) {
  var token_buffer = ib.ic_token_buffer;
  var tok = Stdlib__Buffer.contents(token_buffer);
  token_buffer.position = 0;
  ib.ic_token_count = ib.ic_token_count + 1 | 0;
  return tok;
}

function ignore_char(width, ib) {
  var width$1 = width - 1 | 0;
  ib.ic_current_char_is_valid = false;
  return width$1;
}

function store_char(width, ib, c) {
  Stdlib__Buffer.add_char(ib.ic_token_buffer, c);
  return ignore_char(width, ib);
}

function create(iname, next) {
  return {
          ic_eof: false,
          ic_current_char: /* '\\000' */0,
          ic_current_char_is_valid: false,
          ic_char_count: 0,
          ic_line_count: 0,
          ic_token_count: 0,
          ic_get_next_char: next,
          ic_token_buffer: Stdlib__Buffer.create(1024),
          ic_input_name: iname
        };
}

function from_string(s) {
  var i = {
    contents: 0
  };
  var len = s.length;
  var next = function (param) {
    if (i.contents >= len) {
      throw {
            MEL_EXN_ID: Stdlib.End_of_file,
            Error: new Error()
          };
    }
    var c = Caml_string.get(s, i.contents);
    i.contents = i.contents + 1 | 0;
    return c;
  };
  return create(/* From_string */1, next);
}

function from_function(param) {
  return create(/* From_function */0, param);
}

var file_buffer_size = {
  contents: 1024
};

function scan_close_at_end(ic) {
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  throw {
        MEL_EXN_ID: Stdlib.End_of_file,
        Error: new Error()
      };
}

function scan_raise_at_end(_ic) {
  throw {
        MEL_EXN_ID: Stdlib.End_of_file,
        Error: new Error()
      };
}

function from_ic(scan_close_ic, iname, ic) {
  var len = file_buffer_size.contents;
  var buf = Caml_bytes.caml_create_bytes(len);
  var i = {
    contents: 0
  };
  var lim = {
    contents: 0
  };
  var eof = {
    contents: false
  };
  var next = function (param) {
    if (i.contents < lim.contents) {
      var c = Caml_bytes.get(buf, i.contents);
      i.contents = i.contents + 1 | 0;
      return c;
    }
    if (eof.contents) {
      throw {
            MEL_EXN_ID: Stdlib.End_of_file,
            Error: new Error()
          };
    }
    lim.contents = Stdlib.input(ic, buf, 0, len);
    if (lim.contents === 0) {
      eof.contents = true;
      return Curry._1(scan_close_ic, ic);
    } else {
      i.contents = 1;
      return Caml_bytes.get(buf, 0);
    }
  };
  return create(iname, next);
}

var stdin = from_ic(scan_raise_at_end, {
      TAG: /* From_file */1,
      _0: "-",
      _1: Stdlib.stdin
    }, Stdlib.stdin);

function open_in_file(open_in, fname) {
  if (fname === "-") {
    return stdin;
  }
  var ic = Curry._1(open_in, fname);
  return from_ic(scan_close_at_end, {
              TAG: /* From_file */1,
              _0: fname,
              _1: ic
            }, ic);
}

function open_in(param) {
  return open_in_file(Stdlib.open_in, param);
}

function open_in_bin(param) {
  return open_in_file(Stdlib.open_in_bin, param);
}

function from_channel(ic) {
  return from_ic(scan_raise_at_end, {
              TAG: /* From_channel */0,
              _0: ic
            }, ic);
}

function close_in(ib) {
  var ic = ib.ic_input_name;
  if (typeof ic === "number") {
    return ;
  } else if (ic.TAG === /* From_channel */0) {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic._0);
  } else {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic._1);
  }
}

var Scan_failure = /* @__PURE__ */Caml_exceptions.create("Stdlib.Scanf.Scan_failure");

function bad_input_escape(c) {
  var s = Curry._1(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "illegal escape character ",
              _1: {
                TAG: /* Caml_char */1,
                _0: /* End_of_format */0
              }
            },
            _1: "illegal escape character %C"
          }), c);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function bad_token_length(message) {
  var s = Curry._1(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "scanning of ",
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* String_literal */11,
                  _0: " failed: the specified length was too short for token",
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "scanning of %s failed: the specified length was too short for token"
          }), message);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function bad_hex_float(param) {
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: "not a valid float in hexadecimal notation",
        Error: new Error()
      };
}

function character_mismatch_err(c, ci) {
  return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "looking for ",
                    _1: {
                      TAG: /* Caml_char */1,
                      _0: {
                        TAG: /* String_literal */11,
                        _0: ", found ",
                        _1: {
                          TAG: /* Caml_char */1,
                          _0: /* End_of_format */0
                        }
                      }
                    }
                  },
                  _1: "looking for %C, found %C"
                }), c, ci);
}

function check_this_char(ib, c) {
  var ci = checked_peek_char(ib);
  if (ci === c) {
    ib.ic_current_char_is_valid = false;
    return ;
  }
  var s = character_mismatch_err(c, ci);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function check_char(ib, c) {
  if (c !== 10) {
    if (c !== 32) {
      return check_this_char(ib, c);
    } else {
      while(true) {
        var c$1 = peek_char(ib);
        if (ib.ic_eof) {
          return ;
        }
        if (c$1 > 13 || c$1 < 9) {
          if (c$1 !== 32) {
            return ;
          }
          ib.ic_current_char_is_valid = false;
          continue ;
        }
        if (c$1 === 12 || c$1 === 11) {
          return ;
        }
        ib.ic_current_char_is_valid = false;
        continue ;
      };
    }
  } else {
    var ci = checked_peek_char(ib);
    if (ci === 10) {
      ib.ic_current_char_is_valid = false;
      return ;
    }
    if (ci !== 13) {
      var s = character_mismatch_err(/* '\\n' */10, ci);
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: s,
            Error: new Error()
          };
    }
    ib.ic_current_char_is_valid = false;
    return check_this_char(ib, /* '\\n' */10);
  }
}

function token_bool(ib) {
  var s = token(ib);
  switch (s) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      var s$1 = Curry._1(Stdlib__Printf.sprintf(/* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "invalid boolean '",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Char_literal */12,
                      _0: /* '\\'' */39,
                      _1: /* End_of_format */0
                    }
                  }
                },
                _1: "invalid boolean '%s'"
              }), s);
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: s$1,
            Error: new Error()
          };
  }
}

function integer_conversion_of_char(param) {
  switch (param) {
    case 98 :
        return /* B_conversion */0;
    case 100 :
        return /* D_conversion */1;
    case 105 :
        return /* I_conversion */2;
    case 111 :
        return /* O_conversion */3;
    case 117 :
        return /* U_conversion */4;
    case 89 :
    case 90 :
    case 91 :
    case 92 :
    case 93 :
    case 94 :
    case 95 :
    case 96 :
    case 97 :
    case 99 :
    case 101 :
    case 102 :
    case 103 :
    case 104 :
    case 106 :
    case 107 :
    case 108 :
    case 109 :
    case 110 :
    case 112 :
    case 113 :
    case 114 :
    case 115 :
    case 116 :
    case 118 :
    case 119 :
        break;
    case 88 :
    case 120 :
        return /* X_conversion */5;
    default:
      
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/scanf.ml",
          516,
          9
        ],
        Error: new Error()
      };
}

function token_int_literal(conv, ib) {
  var tok;
  switch (conv) {
    case /* B_conversion */0 :
        tok = "0b" + token(ib);
        break;
    case /* D_conversion */1 :
    case /* I_conversion */2 :
        tok = token(ib);
        break;
    case /* O_conversion */3 :
        tok = "0o" + token(ib);
        break;
    case /* U_conversion */4 :
        tok = "0u" + token(ib);
        break;
    case /* X_conversion */5 :
        tok = "0x" + token(ib);
        break;
    
  }
  var l = tok.length;
  if (l === 0 || Caml_string.get(tok, 0) !== /* '+' */43) {
    return tok;
  } else {
    return Stdlib__String.sub(tok, 1, l - 1 | 0);
  }
}

function token_float(ib) {
  return Caml_format.caml_float_of_string(token(ib));
}

function scan_decimal_digit_star(_width, ib) {
  while(true) {
    var width = _width;
    if (width === 0) {
      return width;
    }
    var c = peek_char(ib);
    if (ib.ic_eof) {
      return width;
    }
    if (c >= 58) {
      if (c !== 95) {
        return width;
      }
      var width$1 = ignore_char(width, ib);
      _width = width$1;
      continue ;
    }
    if (c < 48) {
      return width;
    }
    var width$2 = store_char(width, ib, c);
    _width = width$2;
    continue ;
  };
}

function scan_decimal_digit_plus(width, ib) {
  if (width === 0) {
    return bad_token_length("decimal digits");
  }
  var c = checked_peek_char(ib);
  if (c > 57 || c < 48) {
    var s = Curry._1(Stdlib__Printf.sprintf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "character ",
                _1: {
                  TAG: /* Caml_char */1,
                  _0: {
                    TAG: /* String_literal */11,
                    _0: " is not a decimal digit",
                    _1: /* End_of_format */0
                  }
                }
              },
              _1: "character %C is not a decimal digit"
            }), c);
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: s,
          Error: new Error()
        };
  }
  var width$1 = store_char(width, ib, c);
  return scan_decimal_digit_star(width$1, ib);
}

function scan_digit_plus(basis, digitp, width, ib) {
  if (width === 0) {
    return bad_token_length("digits");
  }
  var c = checked_peek_char(ib);
  if (Curry._1(digitp, c)) {
    var width$1 = store_char(width, ib, c);
    var _width = width$1;
    while(true) {
      var width$2 = _width;
      if (width$2 === 0) {
        return width$2;
      }
      var c$1 = peek_char(ib);
      if (ib.ic_eof) {
        return width$2;
      }
      if (Curry._1(digitp, c$1)) {
        var width$3 = store_char(width$2, ib, c$1);
        _width = width$3;
        continue ;
      }
      if (c$1 !== 95) {
        return width$2;
      }
      var width$4 = ignore_char(width$2, ib);
      _width = width$4;
      continue ;
    };
  }
  var s = Curry._2(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "character ",
              _1: {
                TAG: /* Caml_char */1,
                _0: {
                  TAG: /* String_literal */11,
                  _0: " is not a valid ",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: " digit",
                      _1: /* End_of_format */0
                    }
                  }
                }
              }
            },
            _1: "character %C is not a valid %s digit"
          }), c, basis);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function is_binary_digit(param) {
  return param === 49 || param === 48;
}

function scan_binary_int(param, param$1) {
  return scan_digit_plus("binary", is_binary_digit, param, param$1);
}

function is_octal_digit(param) {
  return !(param > 55 || param < 48);
}

function scan_octal_int(param, param$1) {
  return scan_digit_plus("octal", is_octal_digit, param, param$1);
}

function is_hexa_digit(param) {
  if (param > 70 || param < 48) {
    return !(param > 102 || param < 97);
  } else {
    return param > 64 || param < 58;
  }
}

function scan_hexadecimal_int(param, param$1) {
  return scan_digit_plus("hexadecimal", is_hexa_digit, param, param$1);
}

function scan_sign(width, ib) {
  var c = checked_peek_char(ib);
  if (c !== 43 && c !== 45) {
    return width;
  } else {
    return store_char(width, ib, c);
  }
}

function scan_optionally_signed_decimal_int(width, ib) {
  var width$1 = scan_sign(width, ib);
  return scan_decimal_digit_plus(width$1, ib);
}

function scan_int_conversion(conv, width, ib) {
  switch (conv) {
    case /* B_conversion */0 :
        return scan_binary_int(width, ib);
    case /* D_conversion */1 :
        return scan_optionally_signed_decimal_int(width, ib);
    case /* I_conversion */2 :
        var width$1 = scan_sign(width, ib);
        var c = checked_peek_char(ib);
        if (c !== 48) {
          return scan_decimal_digit_plus(width$1, ib);
        }
        var width$2 = store_char(width$1, ib, c);
        if (width$2 === 0) {
          return width$2;
        }
        var c$1 = peek_char(ib);
        if (ib.ic_eof) {
          return width$2;
        } else if (c$1 >= 99) {
          if (c$1 !== 111) {
            if (c$1 !== 120) {
              return scan_decimal_digit_star(width$2, ib);
            } else {
              return scan_hexadecimal_int(store_char(width$2, ib, c$1), ib);
            }
          } else {
            return scan_octal_int(store_char(width$2, ib, c$1), ib);
          }
        } else if (c$1 !== 88) {
          if (c$1 >= 98) {
            return scan_binary_int(store_char(width$2, ib, c$1), ib);
          } else {
            return scan_decimal_digit_star(width$2, ib);
          }
        } else {
          return scan_hexadecimal_int(store_char(width$2, ib, c$1), ib);
        }
    case /* O_conversion */3 :
        return scan_octal_int(width, ib);
    case /* U_conversion */4 :
        return scan_decimal_digit_plus(width, ib);
    case /* X_conversion */5 :
        return scan_hexadecimal_int(width, ib);
    
  }
}

function scan_fractional_part(width, ib) {
  if (width === 0) {
    return width;
  }
  var c = peek_char(ib);
  if (ib.ic_eof || c > 57 || c < 48) {
    return width;
  } else {
    return scan_decimal_digit_star(store_char(width, ib, c), ib);
  }
}

function scan_exponent_part(width, ib) {
  if (width === 0) {
    return width;
  }
  var c = peek_char(ib);
  if (ib.ic_eof || c !== 69 && c !== 101) {
    return width;
  } else {
    return scan_optionally_signed_decimal_int(store_char(width, ib, c), ib);
  }
}

function scan_integer_part(width, ib) {
  var width$1 = scan_sign(width, ib);
  return scan_decimal_digit_star(width$1, ib);
}

function scan_float(width, precision, ib) {
  var width$1 = scan_integer_part(width, ib);
  if (width$1 === 0) {
    return [
            width$1,
            precision
          ];
  }
  var c = peek_char(ib);
  if (ib.ic_eof) {
    return [
            width$1,
            precision
          ];
  }
  if (c !== 46) {
    return [
            scan_exponent_part(width$1, ib),
            precision
          ];
  }
  var width$2 = store_char(width$1, ib, c);
  var precision$1 = Stdlib__Int.min(width$2, precision);
  var width$3 = width$2 - (precision$1 - scan_fractional_part(precision$1, ib) | 0) | 0;
  return [
          scan_exponent_part(width$3, ib),
          precision$1
        ];
}

function check_case_insensitive_string(width, ib, error, str) {
  var lowercase = function (c) {
    if (c > 90 || c < 65) {
      return c;
    } else {
      return Stdlib.char_of_int((c - /* 'A' */65 | 0) + /* 'a' */97 | 0);
    }
  };
  var len = str.length;
  var width$1 = width;
  for(var i = 0; i < len; ++i){
    var c = peek_char(ib);
    if (lowercase(c) !== lowercase(Caml_string.get(str, i))) {
      Curry._1(error, undefined);
    }
    if (width$1 === 0) {
      Curry._1(error, undefined);
    }
    width$1 = store_char(width$1, ib, c);
  }
  return width$1;
}

function scan_hex_float(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation",
          Error: new Error()
        };
  }
  var width$1 = scan_sign(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation",
          Error: new Error()
        };
  }
  var c = peek_char(ib);
  if (c >= 78) {
    if (c > 109 || c < 79) {
      if (c >= 111) {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation",
              Error: new Error()
            };
      }
      var width$2 = store_char(width$1, ib, c);
      if (width$2 === 0 || end_of_input(ib)) {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation",
              Error: new Error()
            };
      }
      return check_case_insensitive_string(width$2, ib, bad_hex_float, "an");
    }
    if (c !== 105) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation",
            Error: new Error()
          };
    }
    
  } else if (c !== 48) {
    if (c !== 73) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation",
            Error: new Error()
          };
    }
    
  } else {
    var width$3 = store_char(width$1, ib, c);
    if (width$3 === 0 || end_of_input(ib)) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "not a valid float in hexadecimal notation",
            Error: new Error()
          };
    }
    var width$4 = check_case_insensitive_string(width$3, ib, bad_hex_float, "x");
    if (width$4 === 0 || end_of_input(ib)) {
      return width$4;
    }
    var match = peek_char(ib);
    var width$5 = match > 80 || match < 46 ? (
        match !== 112 ? scan_hexadecimal_int(width$4, ib) : width$4
      ) : (
        match > 79 || match < 47 ? width$4 : scan_hexadecimal_int(width$4, ib)
      );
    if (width$5 === 0 || end_of_input(ib)) {
      return width$5;
    }
    var c$1 = peek_char(ib);
    var width$6;
    if (c$1 !== 46) {
      width$6 = width$5;
    } else {
      var width$7 = store_char(width$5, ib, c$1);
      if (width$7 === 0 || end_of_input(ib)) {
        width$6 = width$7;
      } else {
        var match$1 = peek_char(ib);
        if (match$1 !== 80 && match$1 !== 112) {
          var precision$1 = Stdlib__Int.min(width$7, precision);
          width$6 = width$7 - (precision$1 - scan_hexadecimal_int(precision$1, ib) | 0) | 0;
        } else {
          width$6 = width$7;
        }
      }
    }
    if (width$6 === 0 || end_of_input(ib)) {
      return width$6;
    }
    var c$2 = peek_char(ib);
    var exit = 0;
    if (c$2 !== 80) {
      if (c$2 !== 112) {
        return width$6;
      }
      exit = 2;
    } else {
      exit = 2;
    }
    if (exit === 2) {
      var width$8 = store_char(width$6, ib, c$2);
      if (width$8 === 0 || end_of_input(ib)) {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "not a valid float in hexadecimal notation",
              Error: new Error()
            };
      }
      return scan_optionally_signed_decimal_int(width$8, ib);
    }
    
  }
  var width$9 = store_char(width$1, ib, c);
  if (width$9 === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "not a valid float in hexadecimal notation",
          Error: new Error()
        };
  }
  return check_case_insensitive_string(width$9, ib, bad_hex_float, "nfinity");
}

function scan_caml_float_rest(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token",
          Error: new Error()
        };
  }
  var width$1 = scan_decimal_digit_star(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token",
          Error: new Error()
        };
  }
  var c = peek_char(ib);
  if (c > 101 || c < 69) {
    if (c !== 46) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token",
            Error: new Error()
          };
    }
    var width$2 = store_char(width$1, ib, c);
    var precision$1 = Stdlib__Int.min(width$2, precision);
    var width_precision = scan_fractional_part(precision$1, ib);
    var frac_width = precision$1 - width_precision | 0;
    var width$3 = width$2 - frac_width | 0;
    return scan_exponent_part(width$3, ib);
  }
  if (c > 100 || c < 70) {
    return scan_exponent_part(width$1, ib);
  }
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: "no dot or exponent part found in float token",
        Error: new Error()
      };
}

function scan_caml_float(width, precision, ib) {
  if (width === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token",
          Error: new Error()
        };
  }
  var width$1 = scan_sign(width, ib);
  if (width$1 === 0 || end_of_input(ib)) {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token",
          Error: new Error()
        };
  }
  var c = peek_char(ib);
  if (c >= 49) {
    if (c >= 58) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token",
            Error: new Error()
          };
    }
    var width$2 = store_char(width$1, ib, c);
    if (width$2 === 0 || end_of_input(ib)) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token",
            Error: new Error()
          };
    }
    return scan_caml_float_rest(width$2, precision, ib);
  }
  if (c >= 48) {
    var width$3 = store_char(width$1, ib, c);
    if (width$3 === 0 || end_of_input(ib)) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: "no dot or exponent part found in float token",
            Error: new Error()
          };
    }
    var c$1 = peek_char(ib);
    var exit = 0;
    if (c$1 !== 88) {
      if (c$1 !== 120) {
        return scan_caml_float_rest(width$3, precision, ib);
      }
      exit = 1;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var width$4 = store_char(width$3, ib, c$1);
      if (width$4 === 0 || end_of_input(ib)) {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token",
              Error: new Error()
            };
      }
      var width$5 = scan_hexadecimal_int(width$4, ib);
      if (width$5 === 0 || end_of_input(ib)) {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token",
              Error: new Error()
            };
      }
      var c$2 = peek_char(ib);
      var width$6;
      if (c$2 > 112 || c$2 < 80) {
        if (c$2 !== 46) {
          throw {
                MEL_EXN_ID: Scan_failure,
                _1: "no dot or exponent part found in float token",
                Error: new Error()
              };
        }
        var width$7 = store_char(width$5, ib, c$2);
        if (width$7 === 0 || end_of_input(ib)) {
          width$6 = width$7;
        } else {
          var match = peek_char(ib);
          if (match !== 80 && match !== 112) {
            var precision$1 = Stdlib__Int.min(width$7, precision);
            width$6 = width$7 - (precision$1 - scan_hexadecimal_int(precision$1, ib) | 0) | 0;
          } else {
            width$6 = width$7;
          }
        }
      } else if (c$2 > 111 || c$2 < 81) {
        width$6 = width$5;
      } else {
        throw {
              MEL_EXN_ID: Scan_failure,
              _1: "no dot or exponent part found in float token",
              Error: new Error()
            };
      }
      if (width$6 === 0 || end_of_input(ib)) {
        return width$6;
      }
      var c$3 = peek_char(ib);
      var exit$1 = 0;
      if (c$3 !== 80) {
        if (c$3 !== 112) {
          return width$6;
        }
        exit$1 = 2;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        var width$8 = store_char(width$6, ib, c$3);
        if (width$8 === 0 || end_of_input(ib)) {
          throw {
                MEL_EXN_ID: Scan_failure,
                _1: "not a valid float in hexadecimal notation",
                Error: new Error()
              };
        }
        return scan_optionally_signed_decimal_int(width$8, ib);
      }
      
    }
    
  } else {
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: "no dot or exponent part found in float token",
          Error: new Error()
        };
  }
}

function scan_string(stp, width, ib) {
  var _width = width;
  while(true) {
    var width$1 = _width;
    if (width$1 === 0) {
      return width$1;
    }
    var c = peek_char(ib);
    if (ib.ic_eof) {
      return width$1;
    }
    if (stp !== undefined) {
      if (c === stp) {
        ib.ic_current_char_is_valid = false;
        return width$1;
      }
      _width = store_char(width$1, ib, c);
      continue ;
    }
    if (c > 13 || c < 9) {
      if (c === 32) {
        return width$1;
      }
      _width = store_char(width$1, ib, c);
      continue ;
    }
    if (!(c === 12 || c === 11)) {
      return width$1;
    }
    _width = store_char(width$1, ib, c);
    continue ;
  };
}

function scan_char(width, ib) {
  return store_char(width, ib, checked_peek_char(ib));
}

function char_for_backslash(c) {
  if (c < 110) {
    if (c !== 98) {
      return c;
    } else {
      return /* '\\b' */8;
    }
  }
  if (c >= 117) {
    return c;
  }
  switch (c) {
    case 110 :
        return /* '\\n' */10;
    case 114 :
        return /* '\\r' */13;
    case 111 :
    case 112 :
    case 113 :
    case 115 :
        return c;
    case 116 :
        return /* '\\t' */9;
    
  }
}

function char_for_decimal_code(c0, c1, c2) {
  var c = (Math.imul(100, c0 - /* '0' */48 | 0) + Math.imul(10, c1 - /* '0' */48 | 0) | 0) + (c2 - /* '0' */48 | 0) | 0;
  if (!(c < 0 || c > 255)) {
    return Stdlib.char_of_int(c);
  }
  var s = Curry._3(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "bad character decimal encoding \\\\",
              _1: {
                TAG: /* Char */0,
                _0: {
                  TAG: /* Char */0,
                  _0: {
                    TAG: /* Char */0,
                    _0: /* End_of_format */0
                  }
                }
              }
            },
            _1: "bad character decimal encoding \\\\%c%c%c"
          }), c0, c1, c2);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function hexadecimal_value_of_char(c) {
  if (c >= /* 'a' */97) {
    return c - 87 | 0;
  } else if (c >= /* 'A' */65) {
    return c - 55 | 0;
  } else {
    return c - /* '0' */48 | 0;
  }
}

function char_for_hexadecimal_code(c1, c2) {
  var c = (hexadecimal_value_of_char(c1) << 4) + hexadecimal_value_of_char(c2) | 0;
  if (!(c < 0 || c > 255)) {
    return Stdlib.char_of_int(c);
  }
  var s = Curry._2(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "bad character hexadecimal encoding \\\\",
              _1: {
                TAG: /* Char */0,
                _0: {
                  TAG: /* Char */0,
                  _0: /* End_of_format */0
                }
              }
            },
            _1: "bad character hexadecimal encoding \\\\%c%c"
          }), c1, c2);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function check_next_char(message, width, ib) {
  if (width === 0) {
    return bad_token_length(message);
  }
  var c = peek_char(ib);
  if (ib.ic_eof) {
    var s = Curry._1(Stdlib__Printf.sprintf(/* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "scanning of ",
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " failed: premature end of file occurred before end of token",
                    _1: /* End_of_format */0
                  }
                }
              },
              _1: "scanning of %s failed: premature end of file occurred before end of token"
            }), message);
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: s,
          Error: new Error()
        };
  } else {
    return c;
  }
}

function scan_backslash_char(width, ib) {
  var c = check_next_char("a Char", width, ib);
  if (c >= 40) {
    if (c >= 58) {
      switch (c) {
        case 92 :
        case 98 :
        case 110 :
        case 114 :
        case 116 :
            break;
        case 93 :
        case 94 :
        case 95 :
        case 96 :
        case 97 :
        case 99 :
        case 100 :
        case 101 :
        case 102 :
        case 103 :
        case 104 :
        case 105 :
        case 106 :
        case 107 :
        case 108 :
        case 109 :
        case 111 :
        case 112 :
        case 113 :
        case 115 :
        case 117 :
        case 118 :
        case 119 :
            return bad_input_escape(c);
        case 120 :
            var get_digit = function (param) {
              var c = next_char(ib);
              if (c > 70 || c < 48) {
                if (c > 102 || c < 97) {
                  return bad_input_escape(c);
                } else {
                  return c;
                }
              } else if (c > 64 || c < 58) {
                return c;
              } else {
                return bad_input_escape(c);
              }
            };
            var c1 = get_digit(undefined);
            var c2 = get_digit(undefined);
            return store_char(width - 2 | 0, ib, char_for_hexadecimal_code(c1, c2));
        default:
          return bad_input_escape(c);
      }
    } else {
      if (c < 48) {
        return bad_input_escape(c);
      }
      var get_digit$1 = function (param) {
        var c = next_char(ib);
        if (c > 57 || c < 48) {
          return bad_input_escape(c);
        } else {
          return c;
        }
      };
      var c1$1 = get_digit$1(undefined);
      var c2$1 = get_digit$1(undefined);
      return store_char(width - 2 | 0, ib, char_for_decimal_code(c, c1$1, c2$1));
    }
  } else if (c !== 34 && c < 39) {
    return bad_input_escape(c);
  }
  return store_char(width, ib, char_for_backslash(c));
}

function scan_caml_char(width, ib) {
  var find_stop = function (width) {
    var c = check_next_char("a Char", width, ib);
    if (c === 39) {
      return ignore_char(width, ib);
    }
    var s = character_mismatch_err(/* '\\'' */39, c);
    throw {
          MEL_EXN_ID: Scan_failure,
          _1: s,
          Error: new Error()
        };
  };
  var c = checked_peek_char(ib);
  if (c === 39) {
    var width$1 = ignore_char(width, ib);
    var c$1 = check_next_char("a Char", width$1, ib);
    if (c$1 !== 92) {
      return find_stop(store_char(width$1, ib, c$1));
    } else {
      return find_stop(scan_backslash_char(ignore_char(width$1, ib), ib));
    }
  }
  var s = character_mismatch_err(/* '\\'' */39, c);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function scan_caml_string(width, ib) {
  var find_stop = function (_width) {
    while(true) {
      var width = _width;
      var c = check_next_char("a String", width, ib);
      if (c === 34) {
        return ignore_char(width, ib);
      }
      if (c === 92) {
        var width$1 = ignore_char(width, ib);
        var match = check_next_char("a String", width$1, ib);
        if (match !== 10) {
          if (match !== 13) {
            return find_stop(scan_backslash_char(width$1, ib));
          } else {
            var width$2 = ignore_char(width$1, ib);
            var match$1 = check_next_char("a String", width$2, ib);
            if (match$1 !== 10) {
              return find_stop(store_char(width$2, ib, /* '\\r' */13));
            } else {
              return skip_spaces(ignore_char(width$2, ib));
            }
          }
        } else {
          return skip_spaces(ignore_char(width$1, ib));
        }
      }
      _width = store_char(width, ib, c);
      continue ;
    };
  };
  var skip_spaces = function (_width) {
    while(true) {
      var width = _width;
      var match = check_next_char("a String", width, ib);
      if (match !== 32) {
        return find_stop(width);
      }
      _width = ignore_char(width, ib);
      continue ;
    };
  };
  var c = checked_peek_char(ib);
  if (c === 34) {
    return find_stop(ignore_char(width, ib));
  }
  var s = character_mismatch_err(/* '"' */34, c);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function scan_chars_in_char_set(char_set, scan_indic, width, ib) {
  var scan_chars = function (_i, stp) {
    while(true) {
      var i = _i;
      var c = peek_char(ib);
      if (!(i > 0 && !ib.ic_eof && CamlinternalFormat.is_in_char_set(char_set, c) && c !== stp)) {
        return ;
      }
      store_char(Stdlib.max_int, ib, c);
      _i = i - 1 | 0;
      continue ;
    };
  };
  if (scan_indic === undefined) {
    return scan_chars(width, -1);
  }
  scan_chars(width, scan_indic);
  if (ib.ic_eof) {
    return ;
  }
  var ci = peek_char(ib);
  if (scan_indic === ci) {
    ib.ic_current_char_is_valid = false;
    return ;
  }
  var s = character_mismatch_err(scan_indic, ci);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s,
        Error: new Error()
      };
}

function scanf_bad_input(ib, x) {
  var s;
  if (x.MEL_EXN_ID === Scan_failure || x.MEL_EXN_ID === Stdlib.Failure) {
    s = x._1;
  } else {
    throw x;
  }
  var i = char_count(ib);
  var s$1 = Curry._2(Stdlib__Printf.sprintf(/* Format */{
            _0: {
              TAG: /* String_literal */11,
              _0: "scanf: bad input at char number ",
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* String_literal */11,
                  _0: ": ",
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "scanf: bad input at char number %i: %s"
          }), i, s);
  throw {
        MEL_EXN_ID: Scan_failure,
        _1: s$1,
        Error: new Error()
      };
}

function get_counter(ib, counter) {
  switch (counter) {
    case /* Line_counter */0 :
        return ib.ic_line_count;
    case /* Char_counter */1 :
        return char_count(ib);
    case /* Token_counter */2 :
        return ib.ic_token_count;
    
  }
}

function stopper_of_formatting_lit(fmting) {
  if (Caml_obj.caml_equal(fmting, /* Escaped_percent */6)) {
    return [
            /* '%' */37,
            ""
          ];
  }
  var str = CamlinternalFormat.string_of_formatting_lit(fmting);
  var stp = Caml_string.get(str, 1);
  var sub_str = Stdlib__String.sub(str, 2, str.length - 2 | 0);
  return [
          stp,
          sub_str
        ];
}

function take_format_readers(k, _fmt) {
  while(true) {
    var fmt = _fmt;
    if (typeof fmt === "number") {
      return Curry._1(k, /* Nil */0);
    }
    switch (fmt.TAG | 0) {
      case /* Int */4 :
      case /* Int32 */5 :
      case /* Nativeint */6 :
      case /* Int64 */7 :
      case /* Float */8 :
          _fmt = fmt._3;
          continue ;
      case /* Format_subst */14 :
          return take_fmtty_format_readers(k, CamlinternalFormatBasics.erase_rel(CamlinternalFormat.symm(fmt._1)), fmt._2);
      case /* Formatting_gen */18 :
          _fmt = CamlinternalFormatBasics.concat_fmt(fmt._0._0._0, fmt._1);
          continue ;
      case /* Reader */19 :
          var fmt_rest = fmt._0;
          return (function(fmt_rest){
          return function (reader) {
            var new_k = function (readers_rest) {
              return Curry._1(k, /* Cons */{
                          _0: reader,
                          _1: readers_rest
                        });
            };
            return take_format_readers(new_k, fmt_rest);
          }
          }(fmt_rest));
      case /* Char */0 :
      case /* Caml_char */1 :
      case /* Flush */10 :
      case /* Alpha */15 :
      case /* Theta */16 :
      case /* Scan_next_char */22 :
          _fmt = fmt._0;
          continue ;
      case /* Ignored_param */23 :
          var ign = fmt._0;
          var fmt$1 = fmt._1;
          if (typeof ign === "number") {
            if (ign === /* Ignored_reader */2) {
              return (function(fmt$1){
              return function (reader) {
                var new_k = function (readers_rest) {
                  return Curry._1(k, /* Cons */{
                              _0: reader,
                              _1: readers_rest
                            });
                };
                return take_format_readers(new_k, fmt$1);
              }
              }(fmt$1));
            } else {
              return take_format_readers(k, fmt$1);
            }
          } else if (ign.TAG === /* Ignored_format_subst */9) {
            return take_fmtty_format_readers(k, ign._1, fmt$1);
          } else {
            return take_format_readers(k, fmt$1);
          }
      case /* Format_arg */13 :
      case /* Scan_char_set */20 :
      case /* Custom */24 :
          _fmt = fmt._2;
          continue ;
      default:
        _fmt = fmt._1;
        continue ;
    }
  };
}

function take_fmtty_format_readers(k, _fmtty, fmt) {
  while(true) {
    var fmtty = _fmtty;
    if (typeof fmtty === "number") {
      return take_format_readers(k, fmt);
    }
    switch (fmtty.TAG | 0) {
      case /* Format_arg_ty */8 :
          _fmtty = fmtty._1;
          continue ;
      case /* Format_subst_ty */9 :
          var ty = CamlinternalFormat.trans(CamlinternalFormat.symm(fmtty._0), fmtty._1);
          _fmtty = CamlinternalFormatBasics.concat_fmtty(ty, fmtty._2);
          continue ;
      case /* Reader_ty */13 :
          var fmt_rest = fmtty._0;
          return (function(fmt_rest){
          return function (reader) {
            var new_k = function (readers_rest) {
              return Curry._1(k, /* Cons */{
                          _0: reader,
                          _1: readers_rest
                        });
            };
            return take_fmtty_format_readers(new_k, fmt_rest, fmt);
          }
          }(fmt_rest));
      case /* Ignored_reader_ty */14 :
          var fmt_rest$1 = fmtty._0;
          return (function(fmt_rest$1){
          return function (reader) {
            var new_k = function (readers_rest) {
              return Curry._1(k, /* Cons */{
                          _0: reader,
                          _1: readers_rest
                        });
            };
            return take_fmtty_format_readers(new_k, fmt_rest$1, fmt);
          }
          }(fmt_rest$1));
      default:
        _fmtty = fmtty._0;
        continue ;
    }
  };
}

function make_scanf(ib, _fmt, readers) {
  while(true) {
    var fmt = _fmt;
    if (typeof fmt === "number") {
      return /* Nil */0;
    }
    switch (fmt.TAG | 0) {
      case /* Char */0 :
          scan_char(0, ib);
          var c = Caml_string.get(token(ib), 0);
          return /* Cons */{
                  _0: c,
                  _1: make_scanf(ib, fmt._0, readers)
                };
      case /* Caml_char */1 :
          scan_caml_char(0, ib);
          var c$1 = Caml_string.get(token(ib), 0);
          return /* Cons */{
                  _0: c$1,
                  _1: make_scanf(ib, fmt._0, readers)
                };
      case /* String */2 :
          var pad = fmt._0;
          var match = fmt._1;
          if (typeof match !== "number") {
            switch (match.TAG | 0) {
              case /* Formatting_lit */17 :
                  var match$1 = stopper_of_formatting_lit(match._0);
                  var stp = match$1[0];
                  var scan = (function(stp){
                  return function scan(width, param, ib) {
                    return scan_string(stp, width, ib);
                  }
                  }(stp));
                  var str_rest_0 = match$1[1];
                  var str_rest_1 = match._1;
                  var str_rest = {
                    TAG: /* String_literal */11,
                    _0: str_rest_0,
                    _1: str_rest_1
                  };
                  return pad_prec_scanf(ib, str_rest, readers, pad, /* No_precision */0, scan, token);
              case /* Formatting_gen */18 :
                  var match$2 = match._0;
                  if (match$2.TAG === /* Open_tag */0) {
                    var scan$1 = function (width, param, ib) {
                      return scan_string(/* '{' */123, width, ib);
                    };
                    return pad_prec_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$2._0._0, match._1), readers, pad, /* No_precision */0, scan$1, token);
                  }
                  var scan$2 = function (width, param, ib) {
                    return scan_string(/* '[' */91, width, ib);
                  };
                  return pad_prec_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$2._0._0, match._1), readers, pad, /* No_precision */0, scan$2, token);
              default:
                
            }
          }
          var scan$3 = function (width, param, ib) {
            return scan_string(undefined, width, ib);
          };
          return pad_prec_scanf(ib, fmt._1, readers, pad, /* No_precision */0, scan$3, token);
      case /* Caml_string */3 :
          var scan$4 = function (width, param, ib) {
            return scan_caml_string(width, ib);
          };
          return pad_prec_scanf(ib, fmt._1, readers, fmt._0, /* No_precision */0, scan$4, token);
      case /* Int */4 :
          var c$2 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
          var scan$5 = (function(c$2){
          return function scan$5(width, param, ib) {
            return scan_int_conversion(c$2, width, ib);
          }
          }(c$2));
          return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$5, (function(c$2){
                    return function (param) {
                      return Caml_format.caml_int_of_string(token_int_literal(c$2, param));
                    }
                    }(c$2)));
      case /* Int32 */5 :
          var c$3 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
          var scan$6 = (function(c$3){
          return function scan$6(width, param, ib) {
            return scan_int_conversion(c$3, width, ib);
          }
          }(c$3));
          return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$6, (function(c$3){
                    return function (param) {
                      return Caml_format.caml_int32_of_string(token_int_literal(c$3, param));
                    }
                    }(c$3)));
      case /* Nativeint */6 :
          var c$4 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
          var scan$7 = (function(c$4){
          return function scan$7(width, param, ib) {
            return scan_int_conversion(c$4, width, ib);
          }
          }(c$4));
          return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$7, (function(c$4){
                    return function (param) {
                      return Caml_format.caml_nativeint_of_string(token_int_literal(c$4, param));
                    }
                    }(c$4)));
      case /* Int64 */7 :
          var c$5 = integer_conversion_of_char(CamlinternalFormat.char_of_iconv(fmt._0));
          var scan$8 = (function(c$5){
          return function scan$8(width, param, ib) {
            return scan_int_conversion(c$5, width, ib);
          }
          }(c$5));
          return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan$8, (function(c$5){
                    return function (param) {
                      return Caml_format.caml_int64_of_string(token_int_literal(c$5, param));
                    }
                    }(c$5)));
      case /* Float */8 :
          var exit = 0;
          switch (fmt._0[1]) {
            case /* Float_f */0 :
            case /* Float_e */1 :
            case /* Float_E */2 :
            case /* Float_g */3 :
            case /* Float_G */4 :
                exit = 2;
                break;
            case /* Float_h */6 :
            case /* Float_H */7 :
                exit = 3;
                break;
            case /* Float_F */5 :
            case /* Float_CF */8 :
                exit = 1;
                break;
            
          }
          switch (exit) {
            case 1 :
                return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_caml_float, token_float);
            case 2 :
                return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_float, token_float);
            case 3 :
                return pad_prec_scanf(ib, fmt._3, readers, fmt._1, fmt._2, scan_hex_float, token_float);
            
          }
          break;
      case /* Bool */9 :
          var scan$9 = function (param, param$1, ib) {
            var c = checked_peek_char(ib);
            var m;
            if (c !== 102) {
              if (c !== 116) {
                var s = Curry._1(Stdlib__Printf.sprintf(/* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "the character ",
                            _1: {
                              TAG: /* Caml_char */1,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: " cannot start a boolean",
                                _1: /* End_of_format */0
                              }
                            }
                          },
                          _1: "the character %C cannot start a boolean"
                        }), c);
                throw {
                      MEL_EXN_ID: Scan_failure,
                      _1: s,
                      Error: new Error()
                    };
              }
              m = 4;
            } else {
              m = 5;
            }
            return scan_string(undefined, m, ib);
          };
          return pad_prec_scanf(ib, fmt._1, readers, fmt._0, /* No_precision */0, scan$9, token_bool);
      case /* Flush */10 :
          if (end_of_input(ib)) {
            _fmt = fmt._0;
            continue ;
          }
          throw {
                MEL_EXN_ID: Scan_failure,
                _1: "end of input not found",
                Error: new Error()
              };
      case /* String_literal */11 :
          Stdlib__String.iter((function (param) {
                  return check_char(ib, param);
                }), fmt._0);
          _fmt = fmt._1;
          continue ;
      case /* Char_literal */12 :
          check_char(ib, fmt._0);
          _fmt = fmt._1;
          continue ;
      case /* Format_arg */13 :
          var pad_opt = fmt._0;
          scan_caml_string(pad_opt !== undefined ? pad_opt : Stdlib.max_int, ib);
          var s = token(ib);
          var fmt$1;
          try {
            fmt$1 = CamlinternalFormat.format_of_string_fmtty(s, fmt._1);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Failure) {
              throw {
                    MEL_EXN_ID: Scan_failure,
                    _1: exn._1,
                    Error: new Error()
                  };
            }
            throw exn;
          }
          return /* Cons */{
                  _0: fmt$1,
                  _1: make_scanf(ib, fmt._2, readers)
                };
      case /* Format_subst */14 :
          var fmtty = fmt._1;
          var pad_opt$1 = fmt._0;
          scan_caml_string(pad_opt$1 !== undefined ? pad_opt$1 : Stdlib.max_int, ib);
          var s$1 = token(ib);
          var match$3;
          try {
            var fmt$2 = CamlinternalFormat.fmt_ebb_of_string(undefined, s$1);
            var fmt$p = CamlinternalFormat.fmt_ebb_of_string(undefined, s$1);
            match$3 = [
              CamlinternalFormat.type_format(fmt$2._0, CamlinternalFormatBasics.erase_rel(fmtty)),
              CamlinternalFormat.type_format(fmt$p._0, CamlinternalFormatBasics.erase_rel(CamlinternalFormat.symm(fmtty)))
            ];
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.MEL_EXN_ID === Stdlib.Failure) {
              throw {
                    MEL_EXN_ID: Scan_failure,
                    _1: exn$1._1,
                    Error: new Error()
                  };
            }
            throw exn$1;
          }
          return /* Cons */{
                  _0: /* Format */{
                    _0: match$3[0],
                    _1: s$1
                  },
                  _1: make_scanf(ib, CamlinternalFormatBasics.concat_fmt(match$3[1], fmt._2), readers)
                };
      case /* Alpha */15 :
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: bad conversion \\"%a\\"",
                Error: new Error()
              };
      case /* Theta */16 :
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: bad conversion \\"%t\\"",
                Error: new Error()
              };
      case /* Formatting_lit */17 :
          Stdlib__String.iter((function (param) {
                  return check_char(ib, param);
                }), CamlinternalFormat.string_of_formatting_lit(fmt._0));
          _fmt = fmt._1;
          continue ;
      case /* Formatting_gen */18 :
          var match$4 = fmt._0;
          if (match$4.TAG === /* Open_tag */0) {
            check_char(ib, /* '@' */64);
            check_char(ib, /* '{' */123);
            _fmt = CamlinternalFormatBasics.concat_fmt(match$4._0._0, fmt._1);
            continue ;
          }
          check_char(ib, /* '@' */64);
          check_char(ib, /* '[' */91);
          _fmt = CamlinternalFormatBasics.concat_fmt(match$4._0._0, fmt._1);
          continue ;
      case /* Reader */19 :
          if (readers) {
            var x = Curry._1(readers._0, ib);
            return /* Cons */{
                    _0: x,
                    _1: make_scanf(ib, fmt._0, readers._1)
                  };
          }
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: missing reader",
                Error: new Error()
              };
      case /* Scan_char_set */20 :
          var width_opt = fmt._0;
          var match$5 = fmt._2;
          if (typeof match$5 !== "number" && match$5.TAG === /* Formatting_lit */17) {
            var match$6 = stopper_of_formatting_lit(match$5._0);
            var width = width_opt !== undefined ? width_opt : Stdlib.max_int;
            scan_chars_in_char_set(fmt._1, match$6[0], width, ib);
            var s$2 = token(ib);
            var str_rest_0$1 = match$6[1];
            var str_rest_1$1 = match$5._1;
            var str_rest$1 = {
              TAG: /* String_literal */11,
              _0: str_rest_0$1,
              _1: str_rest_1$1
            };
            return /* Cons */{
                    _0: s$2,
                    _1: make_scanf(ib, str_rest$1, readers)
                  };
          }
          var width$1 = width_opt !== undefined ? width_opt : Stdlib.max_int;
          scan_chars_in_char_set(fmt._1, undefined, width$1, ib);
          var s$3 = token(ib);
          return /* Cons */{
                  _0: s$3,
                  _1: make_scanf(ib, fmt._2, readers)
                };
      case /* Scan_get_counter */21 :
          var count = get_counter(ib, fmt._0);
          return /* Cons */{
                  _0: count,
                  _1: make_scanf(ib, fmt._1, readers)
                };
      case /* Scan_next_char */22 :
          var c$6 = checked_peek_char(ib);
          return /* Cons */{
                  _0: c$6,
                  _1: make_scanf(ib, fmt._0, readers)
                };
      case /* Ignored_param */23 :
          var fmt$p$1 = CamlinternalFormat.param_format_of_ignored_format(fmt._0, fmt._1);
          var match$7 = make_scanf(ib, fmt$p$1._0, readers);
          if (match$7) {
            return match$7._1;
          }
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/stdlib/scanf.ml",
                  1414,
                  13
                ],
                Error: new Error()
              };
      case /* Custom */24 :
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: bad conversion \\"%?\\" (custom converter)",
                Error: new Error()
              };
      
    }
  };
}

function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token) {
  if (typeof pad === "number") {
    if (typeof prec === "number") {
      if (prec) {
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "scanf: bad conversion \\"%*\\"",
              Error: new Error()
            };
      }
      Curry._3(scan, Stdlib.max_int, Stdlib.max_int, ib);
      var x = Curry._1(token, ib);
      return /* Cons */{
              _0: x,
              _1: make_scanf(ib, fmt, readers)
            };
    }
    Curry._3(scan, Stdlib.max_int, prec._0, ib);
    var x$1 = Curry._1(token, ib);
    return /* Cons */{
            _0: x$1,
            _1: make_scanf(ib, fmt, readers)
          };
  }
  if (pad.TAG === /* Lit_padding */0) {
    if (pad._0) {
      var w = pad._1;
      if (typeof prec === "number") {
        if (prec) {
          throw {
                MEL_EXN_ID: "Invalid_argument",
                _1: "scanf: bad conversion \\"%*\\"",
                Error: new Error()
              };
        }
        Curry._3(scan, w, Stdlib.max_int, ib);
        var x$2 = Curry._1(token, ib);
        return /* Cons */{
                _0: x$2,
                _1: make_scanf(ib, fmt, readers)
              };
      }
      Curry._3(scan, w, prec._0, ib);
      var x$3 = Curry._1(token, ib);
      return /* Cons */{
              _0: x$3,
              _1: make_scanf(ib, fmt, readers)
            };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "scanf: bad conversion \\"%-\\"",
          Error: new Error()
        };
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "scanf: bad conversion \\"%*\\"",
        Error: new Error()
      };
}

function kscanf_gen(ib, ef, af, param) {
  var str = param._1;
  var fmt = param._0;
  var apply = function (_f, _args) {
    while(true) {
      var args = _args;
      var f = _f;
      if (!args) {
        return f;
      }
      _args = args._1;
      _f = Curry._1(f, args._0);
      continue ;
    };
  };
  var k = function (readers, f) {
    Stdlib__Buffer.reset(ib.ic_token_buffer);
    var args;
    try {
      args = make_scanf(ib, fmt, readers);
    }
    catch (raw_exc){
      var exc = Caml_js_exceptions.internalToOCamlException(raw_exc);
      if (exc.MEL_EXN_ID === Scan_failure) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.Failure) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.End_of_file) {
        return Curry._2(ef, ib, exc);
      }
      if (exc.MEL_EXN_ID === Stdlib.Invalid_argument) {
        var s = exc._1 + (" in format \\"" + (Stdlib__String.escaped(str) + "\\""));
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: s,
              Error: new Error()
            };
      }
      throw exc;
    }
    return Curry._1(af, apply(f, args));
  };
  return take_format_readers(k, fmt);
}

function kscanf(ib, ef, fmt) {
  return kscanf_gen(ib, ef, (function (x) {
                return x;
              }), fmt);
}

function kscanf_opt(ib, fmt) {
  return kscanf_gen(ib, (function (param, param$1) {
                
              }), (function (x) {
                return Caml_option.some(x);
              }), fmt);
}

function bscanf(ib, fmt) {
  return kscanf(ib, scanf_bad_input, fmt);
}

var bscanf_opt = kscanf_opt;

function ksscanf(s, ef, fmt) {
  return kscanf(from_string(s), ef, fmt);
}

function sscanf(s, fmt) {
  return kscanf(from_string(s), scanf_bad_input, fmt);
}

function sscanf_opt(s, fmt) {
  return kscanf_opt(from_string(s), fmt);
}

function scanf(fmt) {
  return kscanf(stdin, scanf_bad_input, fmt);
}

function scanf_opt(fmt) {
  return kscanf_opt(stdin, fmt);
}

function bscanf_format(ib, format, f) {
  scan_caml_string(Stdlib.max_int, ib);
  var str = token(ib);
  var tmp;
  try {
    tmp = CamlinternalFormat.format_of_string_format(str, format);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      throw {
            MEL_EXN_ID: Scan_failure,
            _1: exn._1,
            Error: new Error()
          };
    }
    throw exn;
  }
  return Curry._1(f, tmp);
}

function sscanf_format(s, format, f) {
  return bscanf_format(from_string(s), format, f);
}

function format_from_string(s, fmt) {
  return sscanf_format("\\"" + (Stdlib__String.escaped(s) + "\\""), fmt, (function (x) {
                return x;
              }));
}

function unescaped(s) {
  return Curry._1(sscanf("\\"" + (s + "\\""), /* Format */{
                  _0: {
                    TAG: /* Caml_string */3,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Flush */10,
                      _0: /* End_of_format */0
                    }
                  },
                  _1: "%S%!"
                }), (function (x) {
                return x;
              }));
}

var Scanning = {
  stdin: stdin,
  open_in: open_in,
  open_in_bin: open_in_bin,
  close_in: close_in,
  from_file: open_in,
  from_file_bin: open_in_bin,
  from_string: from_string,
  from_function: from_function,
  from_channel: from_channel,
  end_of_input: end_of_input,
  beginning_of_input: beginning_of_input,
  name_of_input: name_of_input
};

export {
  Scanning ,
  Scan_failure ,
  bscanf ,
  bscanf_opt ,
  sscanf ,
  sscanf_opt ,
  scanf ,
  scanf_opt ,
  kscanf ,
  ksscanf ,
  bscanf_format ,
  sscanf_format ,
  format_from_string ,
  unescaped ,
}
/* stdin Not a pure module */
`,uf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Atomic from "./atomic.js";

function empty(param) {
  return /* Nil */0;
}

function $$return(x, param) {
  return /* Cons */{
          _0: x,
          _1: empty
        };
}

function cons(x, next, param) {
  return /* Cons */{
          _0: x,
          _1: next
        };
}

function append(seq1, seq2, param) {
  var match = Curry._1(seq1, undefined);
  if (!match) {
    return Curry._1(seq2, undefined);
  }
  var next = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return append(next, seq2, param);
            })
        };
}

function map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  return /* Cons */{
          _0: Curry._1(f, match._0),
          _1: (function (param) {
              return map(f, next, param);
            })
        };
}

function filter_map(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var y = Curry._1(f, match._0);
    if (y !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(y),
              _1: (function(next){
              return function (param) {
                return filter_map(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function filter(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var x = match._0;
    if (Curry._1(f, x)) {
      return /* Cons */{
              _0: x,
              _1: (function(next){
              return function (param) {
                return filter(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function concat(seq, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  return append(match._0, (function (param) {
                return concat(next, param);
              }), undefined);
}

function flat_map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  return append(Curry._1(f, match._0), (function (param) {
                return flat_map(f, next, param);
              }), undefined);
}

function fold_left(f, _acc, _seq) {
  while(true) {
    var seq = _seq;
    var acc = _acc;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return acc;
    }
    var acc$1 = Curry._2(f, acc, match._0);
    _seq = match._1;
    _acc = acc$1;
    continue ;
  };
}

function iter(f, _seq) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return ;
    }
    Curry._1(f, match._0);
    _seq = match._1;
    continue ;
  };
}

function unfold(f, u, param) {
  var match = Curry._1(f, u);
  if (match === undefined) {
    return /* Nil */0;
  }
  var u$p = match[1];
  return /* Cons */{
          _0: match[0],
          _1: (function (param) {
              return unfold(f, u$p, param);
            })
        };
}

function is_empty(xs) {
  var match = Curry._1(xs, undefined);
  if (match) {
    return false;
  } else {
    return true;
  }
}

function uncons(xs) {
  var match = Curry._1(xs, undefined);
  if (match) {
    return [
            match._0,
            match._1
          ];
  }
  
}

function length(xs) {
  var _accu = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var accu = _accu;
    var match = Curry._1(xs$1, undefined);
    if (!match) {
      return accu;
    }
    _xs = match._1;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function iteri(f, xs) {
  var _i = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    var match = Curry._1(xs$1, undefined);
    if (!match) {
      return ;
    }
    Curry._2(f, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_lefti(f, accu, xs) {
  var _accu = accu;
  var _i = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    var accu$1 = _accu;
    var match = Curry._1(xs$1, undefined);
    if (!match) {
      return accu$1;
    }
    var accu$2 = Curry._3(f, accu$1, i, match._0);
    _xs = match._1;
    _i = i + 1 | 0;
    _accu = accu$2;
    continue ;
  };
}

function for_all(p, _xs) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return true;
    }
    if (!Curry._1(p, match._0)) {
      return false;
    }
    _xs = match._1;
    continue ;
  };
}

function exists(p, _xs) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return false;
    }
    if (Curry._1(p, match._0)) {
      return true;
    }
    _xs = match._1;
    continue ;
  };
}

function find(p, _xs) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return ;
    }
    var x = match._0;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _xs = match._1;
    continue ;
  };
}

function find_index(p, xs) {
  var _i = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    var match = Curry._1(xs$1, undefined);
    if (!match) {
      return ;
    }
    if (Curry._1(p, match._0)) {
      return i;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue ;
  };
}

function find_map(f, _xs) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return ;
    }
    var result = Curry._1(f, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    continue ;
  };
}

function find_mapi(f, xs) {
  var _i = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    var match = Curry._1(xs$1, undefined);
    if (!match) {
      return ;
    }
    var result = Curry._2(f, i, match._0);
    if (result !== undefined) {
      return result;
    }
    _xs = match._1;
    _i = i + 1 | 0;
    continue ;
  };
}

function iter2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return ;
    }
    var match$1 = Curry._1(ys, undefined);
    if (!match$1) {
      return ;
    }
    Curry._2(f, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    continue ;
  };
}

function fold_left2(f, _accu, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var accu = _accu;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return accu;
    }
    var match$1 = Curry._1(ys, undefined);
    if (!match$1) {
      return accu;
    }
    var accu$1 = Curry._3(f, accu, match._0, match$1._0);
    _ys = match$1._1;
    _xs = match._1;
    _accu = accu$1;
    continue ;
  };
}

function for_all2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return true;
    }
    var match$1 = Curry._1(ys, undefined);
    if (!match$1) {
      return true;
    }
    if (!Curry._2(f, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue ;
  };
}

function exists2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return false;
    }
    var match$1 = Curry._1(ys, undefined);
    if (!match$1) {
      return false;
    }
    if (Curry._2(f, match._0, match$1._0)) {
      return true;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue ;
  };
}

function equal(eq, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    var match$1 = Curry._1(ys, undefined);
    if (!match) {
      if (match$1) {
        return false;
      } else {
        return true;
      }
    }
    if (!match$1) {
      return false;
    }
    if (!Curry._2(eq, match._0, match$1._0)) {
      return false;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue ;
  };
}

function compare(cmp, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    var match$1 = Curry._1(ys, undefined);
    if (!match) {
      if (match$1) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!match$1) {
      return 1;
    }
    var c = Curry._2(cmp, match._0, match$1._0);
    if (c !== 0) {
      return c;
    }
    _ys = match$1._1;
    _xs = match._1;
    continue ;
  };
}

function init_aux(f, i, j, param) {
  if (i >= j) {
    return /* Nil */0;
  }
  var partial_arg = i + 1 | 0;
  return /* Cons */{
          _0: Curry._1(f, i),
          _1: (function (param) {
              return init_aux(f, partial_arg, j, param);
            })
        };
}

function init(n, f) {
  if (n < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.init",
          Error: new Error()
        };
  }
  return function (param) {
    return init_aux(f, 0, n, param);
  };
}

function repeat(x, param) {
  return /* Cons */{
          _0: x,
          _1: (function (param) {
              return repeat(x, param);
            })
        };
}

function forever(f, param) {
  return /* Cons */{
          _0: Curry._1(f, undefined),
          _1: (function (param) {
              return forever(f, param);
            })
        };
}

function cycle_nonempty(xs, param) {
  return append(xs, (function (param) {
                return cycle_nonempty(xs, param);
              }), undefined);
}

function cycle(xs, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$p = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return append(xs$p, (function (param) {
                            return cycle_nonempty(xs, param);
                          }), param);
            })
        };
}

function iterate1(f, x, param) {
  var y = Curry._1(f, x);
  return /* Cons */{
          _0: y,
          _1: (function (param) {
              return iterate1(f, y, param);
            })
        };
}

function iterate(f, x) {
  return function (param) {
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return iterate1(f, x, param);
              })
          };
  };
}

function mapi_aux(f, i, xs, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var partial_arg = i + 1 | 0;
  return /* Cons */{
          _0: Curry._2(f, i, match._0),
          _1: (function (param) {
              return mapi_aux(f, partial_arg, xs$1, param);
            })
        };
}

function mapi(f, xs) {
  return function (param) {
    return mapi_aux(f, 0, xs, param);
  };
}

function tail_scan(f, s, xs, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var s$1 = Curry._2(f, s, match._0);
  return /* Cons */{
          _0: s$1,
          _1: (function (param) {
              return tail_scan(f, s$1, xs$1, param);
            })
        };
}

function scan(f, s, xs) {
  return function (param) {
    return /* Cons */{
            _0: s,
            _1: (function (param) {
                return tail_scan(f, s, xs, param);
              })
          };
  };
}

function take_aux(n, xs) {
  if (n === 0) {
    return empty;
  } else {
    return function (param) {
      var match = Curry._1(xs, undefined);
      if (match) {
        return /* Cons */{
                _0: match._0,
                _1: take_aux(n - 1 | 0, match._1)
              };
      } else {
        return /* Nil */0;
      }
    };
  }
}

function take(n, xs) {
  if (n < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.take",
          Error: new Error()
        };
  }
  return take_aux(n, xs);
}

function drop(n, xs) {
  if (n < 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Seq.drop",
          Error: new Error()
        };
  }
  if (n === 0) {
    return xs;
  } else {
    return function (param) {
      var _n = n;
      var _xs = xs;
      while(true) {
        var xs$1 = _xs;
        var n$1 = _n;
        var match = Curry._1(xs$1, undefined);
        if (!match) {
          return /* Nil */0;
        }
        var xs$2 = match._1;
        var n$2 = n$1 - 1 | 0;
        if (n$2 === 0) {
          return Curry._1(xs$2, undefined);
        }
        _xs = xs$2;
        _n = n$2;
        continue ;
      };
    };
  }
}

function take_while(p, xs, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var x = match._0;
  if (Curry._1(p, x)) {
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return take_while(p, xs$1, param);
              })
          };
  } else {
    return /* Nil */0;
  }
}

function drop_while(p, _xs, _param) {
  while(true) {
    var xs = _xs;
    var node = Curry._1(xs, undefined);
    if (!node) {
      return /* Nil */0;
    }
    if (!Curry._1(p, node._0)) {
      return node;
    }
    _param = undefined;
    _xs = node._1;
    continue ;
  };
}

function group(eq, xs, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var x = match._0;
  var partial_arg = Curry._1(eq, x);
  var partial_arg$1 = function (param) {
    return take_while(partial_arg, xs$1, param);
  };
  var partial_arg$2 = Curry._1(eq, x);
  var partial_arg$3 = function (param) {
    return drop_while(partial_arg$2, xs$1, param);
  };
  return /* Cons */{
          _0: (function (param) {
              return /* Cons */{
                      _0: x,
                      _1: partial_arg$1
                    };
            }),
          _1: (function (param) {
              return group(eq, partial_arg$3, param);
            })
        };
}

var Forced_twice = /* @__PURE__ */Caml_exceptions.create("Stdlib.Seq.Forced_twice");

function failure(param) {
  throw {
        MEL_EXN_ID: Forced_twice,
        Error: new Error()
      };
}

function memoize(xs) {
  var partial_arg = {
    LAZY_DONE: false,
    VAL: (function () {
        var match = Curry._1(xs, undefined);
        if (match) {
          return /* Cons */{
                  _0: match._0,
                  _1: memoize(match._1)
                };
        } else {
          return /* Nil */0;
        }
      })
  };
  return function (param) {
    return CamlinternalLazy.force(partial_arg);
  };
}

function once(xs) {
  var f = function (param) {
    var match = Curry._1(xs, undefined);
    if (match) {
      return /* Cons */{
              _0: match._0,
              _1: once(match._1)
            };
    } else {
      return /* Nil */0;
    }
  };
  var action = Stdlib__Atomic.make(f);
  return function (param) {
    var f = Stdlib__Atomic.exchange(action, failure);
    return Curry._1(f, undefined);
  };
}

function zip(xs, ys, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var match$1 = Curry._1(ys, undefined);
  if (!match$1) {
    return /* Nil */0;
  }
  var ys$1 = match$1._1;
  return /* Cons */{
          _0: [
            match._0,
            match$1._0
          ],
          _1: (function (param) {
              return zip(xs$1, ys$1, param);
            })
        };
}

function map2(f, xs, ys, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xs$1 = match._1;
  var match$1 = Curry._1(ys, undefined);
  if (!match$1) {
    return /* Nil */0;
  }
  var ys$1 = match$1._1;
  return /* Cons */{
          _0: Curry._2(f, match._0, match$1._0),
          _1: (function (param) {
              return map2(f, xs$1, ys$1, param);
            })
        };
}

function interleave(xs, ys, param) {
  var match = Curry._1(xs, undefined);
  if (!match) {
    return Curry._1(ys, undefined);
  }
  var xs$1 = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return interleave(ys, xs$1, param);
            })
        };
}

function sorted_merge1(cmp, x, xs, y, ys) {
  if (Curry._2(cmp, x, y) <= 0) {
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                var match = Curry._1(xs, undefined);
                if (match) {
                  return sorted_merge1(cmp, match._0, match._1, y, ys);
                } else {
                  return /* Cons */{
                          _0: y,
                          _1: ys
                        };
                }
              })
          };
  } else {
    return /* Cons */{
            _0: y,
            _1: (function (param) {
                var match = Curry._1(ys, undefined);
                if (match) {
                  return sorted_merge1(cmp, x, xs, match._0, match._1);
                } else {
                  return /* Cons */{
                          _0: x,
                          _1: xs
                        };
                }
              })
          };
  }
}

function sorted_merge(cmp, xs, ys, param) {
  var match = Curry._1(xs, undefined);
  var match$1 = Curry._1(ys, undefined);
  if (match) {
    if (match$1) {
      return sorted_merge1(cmp, match._0, match._1, match$1._0, match$1._1);
    } else {
      return match;
    }
  } else if (match$1) {
    return match$1;
  } else {
    return /* Nil */0;
  }
}

function map_fst(xys, param) {
  var match = Curry._1(xys, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xys$1 = match._1;
  return /* Cons */{
          _0: match._0[0],
          _1: (function (param) {
              return map_fst(xys$1, param);
            })
        };
}

function map_snd(xys, param) {
  var match = Curry._1(xys, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var xys$1 = match._1;
  return /* Cons */{
          _0: match._0[1],
          _1: (function (param) {
              return map_snd(xys$1, param);
            })
        };
}

function unzip(xys) {
  return [
          (function (param) {
              return map_fst(xys, param);
            }),
          (function (param) {
              return map_snd(xys, param);
            })
        ];
}

function filter_map_find_left_map(f, _xs, _param) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var xs$1 = match._1;
    var y = Curry._1(f, match._0);
    if (y.TAG === /* Left */0) {
      return /* Cons */{
              _0: y._0,
              _1: (function(xs$1){
              return function (param) {
                return filter_map_find_left_map(f, xs$1, param);
              }
              }(xs$1))
            };
    }
    _param = undefined;
    _xs = xs$1;
    continue ;
  };
}

function filter_map_find_right_map(f, _xs, _param) {
  while(true) {
    var xs = _xs;
    var match = Curry._1(xs, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var xs$1 = match._1;
    var z = Curry._1(f, match._0);
    if (z.TAG !== /* Left */0) {
      return /* Cons */{
              _0: z._0,
              _1: (function(xs$1){
              return function (param) {
                return filter_map_find_right_map(f, xs$1, param);
              }
              }(xs$1))
            };
    }
    _param = undefined;
    _xs = xs$1;
    continue ;
  };
}

function partition_map(f, xs) {
  return [
          (function (param) {
              return filter_map_find_left_map(f, xs, param);
            }),
          (function (param) {
              return filter_map_find_right_map(f, xs, param);
            })
        ];
}

function partition(p, xs) {
  return [
          (function (param) {
              return filter(p, xs, param);
            }),
          (function (param) {
              return filter((function (x) {
                            return !Curry._1(p, x);
                          }), xs, param);
            })
        ];
}

function transpose(xss, param) {
  var match = unzip(function (param) {
        return filter_map(uncons, xss, param);
      });
  var tails = match[1];
  var heads = match[0];
  if (!is_empty(heads)) {
    return /* Cons */{
            _0: heads,
            _1: (function (param) {
                return transpose(tails, param);
              })
          };
  }
  if (!is_empty(tails)) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/seq.ml",
            616,
            4
          ],
          Error: new Error()
        };
  }
  return /* Nil */0;
}

function diagonals(remainders, xss, param) {
  var match = Curry._1(xss, undefined);
  if (!match) {
    return transpose(remainders, undefined);
  }
  var xss$1 = match._1;
  var match$1 = Curry._1(match._0, undefined);
  if (match$1) {
    var xs = match$1._1;
    var x = match$1._0;
    var match$2 = unzip(function (param) {
          return filter_map(uncons, remainders, param);
        });
    var tails = match$2[1];
    var heads = match$2[0];
    return /* Cons */{
            _0: (function (param) {
                return /* Cons */{
                        _0: x,
                        _1: heads
                      };
              }),
            _1: (function (param) {
                return diagonals((function (param) {
                              return /* Cons */{
                                      _0: xs,
                                      _1: tails
                                    };
                            }), xss$1, param);
              })
          };
  }
  var match$3 = unzip(function (param) {
        return filter_map(uncons, remainders, param);
      });
  var tails$1 = match$3[1];
  return /* Cons */{
          _0: match$3[0],
          _1: (function (param) {
              return diagonals(tails$1, xss$1, param);
            })
        };
}

function map_product(f, xs, ys) {
  return function (param) {
    return concat((function (param) {
                  return diagonals(empty, (function (param) {
                                return map((function (x) {
                                              return function (param) {
                                                return map((function (y) {
                                                              return Curry._2(f, x, y);
                                                            }), ys, param);
                                              };
                                            }), xs, param);
                              }), param);
                }), param);
  };
}

function product(xs, ys) {
  return map_product((function (x, y) {
                return [
                        x,
                        y
                      ];
              }), xs, ys);
}

function of_dispenser(it) {
  var c = function (param) {
    var x = Curry._1(it, undefined);
    if (x !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(x),
              _1: c
            };
    } else {
      return /* Nil */0;
    }
  };
  return c;
}

function to_dispenser(xs) {
  var s = {
    contents: xs
  };
  return function (param) {
    var match = Curry._1(s.contents, undefined);
    if (match) {
      s.contents = match._1;
      return Caml_option.some(match._0);
    }
    
  };
}

function ints(i, param) {
  var partial_arg = i + 1 | 0;
  return /* Cons */{
          _0: i,
          _1: (function (param) {
              return ints(partial_arg, param);
            })
        };
}

var concat_map = flat_map;

var split = unzip;

export {
  is_empty ,
  uncons ,
  length ,
  iter ,
  fold_left ,
  iteri ,
  fold_lefti ,
  for_all ,
  exists ,
  find ,
  find_index ,
  find_map ,
  find_mapi ,
  iter2 ,
  fold_left2 ,
  for_all2 ,
  exists2 ,
  equal ,
  compare ,
  empty ,
  $$return ,
  cons ,
  init ,
  unfold ,
  repeat ,
  forever ,
  cycle ,
  iterate ,
  map ,
  mapi ,
  filter ,
  filter_map ,
  scan ,
  take ,
  drop ,
  take_while ,
  drop_while ,
  group ,
  memoize ,
  Forced_twice ,
  once ,
  transpose ,
  append ,
  concat ,
  flat_map ,
  concat_map ,
  zip ,
  map2 ,
  interleave ,
  sorted_merge ,
  product ,
  map_product ,
  unzip ,
  split ,
  partition_map ,
  partition ,
  of_dispenser ,
  to_dispenser ,
  ints ,
}
/* No side effect */
`,ff=`// Generated by Melange

import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

function Make(funarg) {
  var height = function (param) {
    if (param) {
      return param.h;
    } else {
      return 0;
    }
  };
  var create = function (l, v, r) {
    var hl = l ? l.h : 0;
    var hr = r ? r.h : 0;
    return /* Node */{
            l: l,
            v: v,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  };
  var bal = function (l, v, r) {
    var hl = l ? l.h : 0;
    var hr = r ? r.h : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l.r;
        var lv = l.v;
        var ll = l.l;
        if (height(ll) >= height(lr)) {
          return create(ll, lv, create(lr, v, r));
        }
        if (lr) {
          return create(create(ll, lv, lr.l), lr.v, create(lr.r, v, r));
        }
        throw {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Set.bal",
              Error: new Error()
            };
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal",
            Error: new Error()
          };
    }
    if (hr <= (hl + 2 | 0)) {
      return /* Node */{
              l: l,
              v: v,
              r: r,
              h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            };
    }
    if (r) {
      var rr = r.r;
      var rv = r.v;
      var rl = r.l;
      if (height(rr) >= height(rl)) {
        return create(create(l, v, rl), rv, rr);
      }
      if (rl) {
        return create(create(l, v, rl.l), rl.v, create(rl.r, rv, rr));
      }
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Set.bal",
            Error: new Error()
          };
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Set.bal",
          Error: new Error()
        };
  };
  var add = function (x, t) {
    if (!t) {
      return /* Node */{
              l: /* Empty */0,
              v: x,
              r: /* Empty */0,
              h: 1
            };
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return t;
    }
    if (c < 0) {
      var ll = add(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    var rr = add(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  var singleton = function (x) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            r: /* Empty */0,
            h: 1
          };
  };
  var add_min_element = function (x, param) {
    if (param) {
      return bal(add_min_element(x, param.l), param.v, param.r);
    } else {
      return singleton(x);
    }
  };
  var add_max_element = function (x, param) {
    if (param) {
      return bal(param.l, param.v, add_max_element(x, param.r));
    } else {
      return singleton(x);
    }
  };
  var join = function (l, v, r) {
    if (!l) {
      return add_min_element(v, r);
    }
    if (!r) {
      return add_max_element(v, l);
    }
    var rh = r.h;
    var lh = l.h;
    if (lh > (rh + 2 | 0)) {
      return bal(l.l, l.v, join(l.r, v, r));
    } else if (rh > (lh + 2 | 0)) {
      return bal(join(l, v, r.l), r.v, r.r);
    } else {
      return create(l, v, r);
    }
  };
  var min_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param.l;
        if (!l) {
          return param.v;
        }
        _param = l;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var min_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var l = param.l;
      if (!l) {
        return Caml_option.some(param.v);
      }
      _param = l;
      continue ;
    };
  };
  var max_elt = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        if (!param.r) {
          return param.v;
        }
        _param = param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var max_elt_opt = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (!param.r) {
        return Caml_option.some(param.v);
      }
      _param = param.r;
      continue ;
    };
  };
  var remove_min_elt = function (param) {
    if (param) {
      var l = param.l;
      if (l) {
        return bal(remove_min_elt(l), param.v, param.r);
      } else {
        return param.r;
      }
    }
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Set.remove_min_elt",
          Error: new Error()
        };
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        return join(t1, min_elt(t2), remove_min_elt(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var split = function (x, param) {
    if (!param) {
      return [
              /* Empty */0,
              false,
              /* Empty */0
            ];
    }
    var r = param.r;
    var v = param.v;
    var l = param.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return [
              l,
              true,
              r
            ];
    }
    if (c < 0) {
      var match = split(x, l);
      return [
              match[0],
              match[1],
              join(match[2], v, r)
            ];
    }
    var match$1 = split(x, r);
    return [
            join(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  };
  var is_empty = function (param) {
    if (param) {
      return false;
    } else {
      return true;
    }
  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      var c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return true;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    };
  };
  var remove = function (x, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      if (l) {
        if (r) {
          return bal(l, min_elt(r), remove_min_elt(r));
        } else {
          return l;
        }
      } else {
        return r;
      }
    }
    if (c < 0) {
      var ll = remove(x, l);
      if (l === ll) {
        return t;
      } else {
        return bal(ll, v, r);
      }
    }
    var rr = remove(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal(l, v, rr);
    }
  };
  var union = function (s1, s2) {
    if (!s1) {
      return s2;
    }
    if (!s2) {
      return s1;
    }
    var h2 = s2.h;
    var v2 = s2.v;
    var h1 = s1.h;
    var v1 = s1.v;
    if (h1 >= h2) {
      if (h2 === 1) {
        return add(v2, s1);
      }
      var match = split(v1, s2);
      return join(union(s1.l, match[0]), v1, union(s1.r, match[2]));
    }
    if (h1 === 1) {
      return add(v1, s2);
    }
    var match$1 = split(v2, s1);
    return join(union(match$1[0], s2.l), v2, union(match$1[2], s2.r));
  };
  var inter = function (s1, s2) {
    if (!s1) {
      return /* Empty */0;
    }
    if (!s2) {
      return /* Empty */0;
    }
    var r1 = s1.r;
    var v1 = s1.v;
    var l1 = s1.l;
    var match = split(v1, s2);
    var l2 = match[0];
    if (match[1]) {
      return join(inter(l1, l2), v1, inter(r1, match[2]));
    } else {
      return concat(inter(l1, l2), inter(r1, match[2]));
    }
  };
  var split_bis = function (x, param) {
    if (!param) {
      return /* NotFound */{
              _0: /* Empty */0,
              _1: (function (param) {
                  return /* Empty */0;
                })
            };
    }
    var r = param.r;
    var v = param.v;
    var l = param.l;
    var c = Curry._2(funarg.compare, x, v);
    if (c === 0) {
      return /* Found */0;
    }
    if (c < 0) {
      var match = split_bis(x, l);
      if (!match) {
        return /* Found */0;
      }
      var rl = match._1;
      return /* NotFound */{
              _0: match._0,
              _1: (function (param) {
                  return join(Curry._1(rl, undefined), v, r);
                })
            };
    }
    var match$1 = split_bis(x, r);
    if (match$1) {
      return /* NotFound */{
              _0: join(l, v, match$1._0),
              _1: match$1._1
            };
    } else {
      return /* Found */0;
    }
  };
  var disjoint = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (!s1) {
        return true;
      }
      if (!s2) {
        return true;
      }
      if (s1 === s2) {
        return false;
      }
      var match = split_bis(s1.v, s2);
      if (!match) {
        return false;
      }
      if (!disjoint(s1.l, match._0)) {
        return false;
      }
      _s2 = Curry._1(match._1, undefined);
      _s1 = s1.r;
      continue ;
    };
  };
  var diff = function (s1, s2) {
    if (!s1) {
      return /* Empty */0;
    }
    if (!s2) {
      return s1;
    }
    var r1 = s1.r;
    var v1 = s1.v;
    var l1 = s1.l;
    var match = split(v1, s2);
    var l2 = match[0];
    if (match[1]) {
      return concat(diff(l1, l2), diff(r1, match[2]));
    } else {
      return join(diff(l1, l2), v1, diff(r1, match[2]));
    }
  };
  var cons_enum = function (_s, _e) {
    while(true) {
      var e = _e;
      var s = _s;
      if (!s) {
        return e;
      }
      _e = /* More */{
        _0: s.v,
        _1: s.r,
        _2: e
      };
      _s = s.l;
      continue ;
    };
  };
  var compare = function (s1, s2) {
    var _e1 = cons_enum(s1, /* End */0);
    var _e2 = cons_enum(s2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (!e1) {
        if (e2) {
          return -1;
        } else {
          return 0;
        }
      }
      if (!e2) {
        return 1;
      }
      var c = Curry._2(funarg.compare, e1._0, e2._0);
      if (c !== 0) {
        return c;
      }
      _e2 = cons_enum(e2._1, e2._2);
      _e1 = cons_enum(e1._1, e1._2);
      continue ;
    };
  };
  var equal = function (s1, s2) {
    return compare(s1, s2) === 0;
  };
  var subset = function (_s1, _s2) {
    while(true) {
      var s2 = _s2;
      var s1 = _s1;
      if (!s1) {
        return true;
      }
      if (!s2) {
        return false;
      }
      var r2 = s2.r;
      var l2 = s2.l;
      var r1 = s1.r;
      var v1 = s1.v;
      var l1 = s1.l;
      var c = Curry._2(funarg.compare, v1, s2.v);
      if (c === 0) {
        if (!subset(l1, l2)) {
          return false;
        }
        _s2 = r2;
        _s1 = r1;
        continue ;
      }
      if (c < 0) {
        if (!subset(/* Node */{
                l: l1,
                v: v1,
                r: /* Empty */0,
                h: 0
              }, l2)) {
          return false;
        }
        _s1 = r1;
        continue ;
      }
      if (!subset(/* Node */{
              l: /* Empty */0,
              v: v1,
              r: r1,
              h: 0
            }, r2)) {
        return false;
      }
      _s1 = l1;
      continue ;
    };
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      iter(f, param.l);
      Curry._1(f, param.v);
      _param = param.r;
      continue ;
    };
  };
  var fold = function (f, _s, _accu) {
    while(true) {
      var accu = _accu;
      var s = _s;
      if (!s) {
        return accu;
      }
      _accu = Curry._2(f, s.v, fold(f, s.l, accu));
      _s = s.r;
      continue ;
    };
  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return true;
      }
      if (!Curry._1(p, param.v)) {
        return false;
      }
      if (!for_all(p, param.l)) {
        return false;
      }
      _param = param.r;
      continue ;
    };
  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (Curry._1(p, param.v)) {
        return true;
      }
      if (exists(p, param.l)) {
        return true;
      }
      _param = param.r;
      continue ;
    };
  };
  var filter = function (p, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var l$p = filter(p, l);
    var pv = Curry._1(p, v);
    var r$p = filter(p, r);
    if (pv) {
      if (l === l$p && r === r$p) {
        return t;
      } else {
        return join(l$p, v, r$p);
      }
    } else {
      return concat(l$p, r$p);
    }
  };
  var partition = function (p, param) {
    if (!param) {
      return [
              /* Empty */0,
              /* Empty */0
            ];
    }
    var v = param.v;
    var match = partition(p, param.l);
    var lf = match[1];
    var lt = match[0];
    var pv = Curry._1(p, v);
    var match$1 = partition(p, param.r);
    var rf = match$1[1];
    var rt = match$1[0];
    if (pv) {
      return [
              join(lt, v, rt),
              concat(lf, rf)
            ];
    } else {
      return [
              concat(lt, rt),
              join(lf, v, rf)
            ];
    }
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param.l) + 1 | 0) + cardinal(param.r) | 0;
    } else {
      return 0;
    }
  };
  var elements_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param.l;
      _accu = {
        hd: param.v,
        tl: elements_aux(accu, param.r)
      };
      continue ;
    };
  };
  var elements = function (s) {
    return elements_aux(/* [] */0, s);
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        var c = Curry._2(funarg.compare, x, v);
        if (c === 0) {
          return v;
        }
        _param = c < 0 ? param.l : param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_first = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (Curry._1(f, v)) {
          var _v0 = v;
          var _param$1 = param.l;
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (!param$1) {
              return v0;
            }
            var v$1 = param$1.v;
            if (Curry._1(f, v$1)) {
              _param$1 = param$1.l;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.r;
            continue ;
          };
        }
        _param = param.r;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_first_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _param$1 = param.l;
        while(true) {
          var param$1 = _param$1;
          var v0 = _v0;
          if (!param$1) {
            return Caml_option.some(v0);
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.l;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.r;
          continue ;
        };
      }
      _param = param.r;
      continue ;
    };
  };
  var find_last = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var v = param.v;
        if (Curry._1(f, v)) {
          var _v0 = v;
          var _param$1 = param.r;
          while(true) {
            var param$1 = _param$1;
            var v0 = _v0;
            if (!param$1) {
              return v0;
            }
            var v$1 = param$1.v;
            if (Curry._1(f, v$1)) {
              _param$1 = param$1.r;
              _v0 = v$1;
              continue ;
            }
            _param$1 = param$1.l;
            continue ;
          };
        }
        _param = param.l;
        continue ;
      }
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_last_opt = function (f, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      if (Curry._1(f, v)) {
        var _v0 = v;
        var _param$1 = param.r;
        while(true) {
          var param$1 = _param$1;
          var v0 = _v0;
          if (!param$1) {
            return Caml_option.some(v0);
          }
          var v$1 = param$1.v;
          if (Curry._1(f, v$1)) {
            _param$1 = param$1.r;
            _v0 = v$1;
            continue ;
          }
          _param$1 = param$1.l;
          continue ;
        };
      }
      _param = param.l;
      continue ;
    };
  };
  var find_opt = function (x, _param) {
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      var v = param.v;
      var c = Curry._2(funarg.compare, x, v);
      if (c === 0) {
        return Caml_option.some(v);
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    };
  };
  var try_join = function (l, v, r) {
    if ((Caml_obj.caml_equal(l, /* Empty */0) || Curry._2(funarg.compare, max_elt(l), v) < 0) && (Caml_obj.caml_equal(r, /* Empty */0) || Curry._2(funarg.compare, v, min_elt(r)) < 0)) {
      return join(l, v, r);
    } else {
      return union(l, add(v, r));
    }
  };
  var map = function (f, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var l$p = map(f, l);
    var v$p = Curry._1(f, v);
    var r$p = map(f, r);
    if (l === l$p && v === v$p && r === r$p) {
      return t;
    } else {
      return try_join(l$p, v$p, r$p);
    }
  };
  var filter_map = function (f, t) {
    if (!t) {
      return /* Empty */0;
    }
    var r = t.r;
    var v = t.v;
    var l = t.l;
    var l$p = filter_map(f, l);
    var v$p = Curry._1(f, v);
    var r$p = filter_map(f, r);
    if (v$p === undefined) {
      if (l$p) {
        if (r$p) {
          return try_join(l$p, min_elt(r$p), remove_min_elt(r$p));
        } else {
          return l$p;
        }
      } else {
        return r$p;
      }
    }
    var v$p$1 = Caml_option.valFromOption(v$p);
    if (l === l$p && v === v$p$1 && r === r$p) {
      return t;
    } else {
      return try_join(l$p, v$p$1, r$p);
    }
  };
  var of_list = function (l) {
    if (!l) {
      return /* Empty */0;
    }
    var match = l.tl;
    var x0 = l.hd;
    if (!match) {
      return singleton(x0);
    }
    var match$1 = match.tl;
    var x1 = match.hd;
    if (!match$1) {
      return add(x1, singleton(x0));
    }
    var match$2 = match$1.tl;
    var x2 = match$1.hd;
    if (!match$2) {
      return add(x2, add(x1, singleton(x0)));
    }
    var match$3 = match$2.tl;
    var x3 = match$2.hd;
    if (match$3) {
      if (match$3.tl) {
        var l$1 = Stdlib__List.sort_uniq(funarg.compare, l);
        var sub = function (n, l) {
          switch (n) {
            case 0 :
                return [
                        /* Empty */0,
                        l
                      ];
            case 1 :
                if (l) {
                  return [
                          /* Node */{
                            l: /* Empty */0,
                            v: l.hd,
                            r: /* Empty */0,
                            h: 1
                          },
                          l.tl
                        ];
                }
                break;
            case 2 :
                if (l) {
                  var match = l.tl;
                  if (match) {
                    return [
                            /* Node */{
                              l: /* Node */{
                                l: /* Empty */0,
                                v: l.hd,
                                r: /* Empty */0,
                                h: 1
                              },
                              v: match.hd,
                              r: /* Empty */0,
                              h: 2
                            },
                            match.tl
                          ];
                  }
                  
                }
                break;
            case 3 :
                if (l) {
                  var match$1 = l.tl;
                  if (match$1) {
                    var match$2 = match$1.tl;
                    if (match$2) {
                      return [
                              /* Node */{
                                l: /* Node */{
                                  l: /* Empty */0,
                                  v: l.hd,
                                  r: /* Empty */0,
                                  h: 1
                                },
                                v: match$1.hd,
                                r: /* Node */{
                                  l: /* Empty */0,
                                  v: match$2.hd,
                                  r: /* Empty */0,
                                  h: 1
                                },
                                h: 2
                              },
                              match$2.tl
                            ];
                    }
                    
                  }
                  
                }
                break;
            default:
              
          }
          var nl = n / 2 | 0;
          var match$3 = sub(nl, l);
          var l$1 = match$3[1];
          if (l$1) {
            var match$4 = sub((n - nl | 0) - 1 | 0, l$1.tl);
            return [
                    create(match$3[0], l$1.hd, match$4[0]),
                    match$4[1]
                  ];
          }
          throw {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "jscomp/stdlib/set.ml",
                  571,
                  18
                ],
                Error: new Error()
              };
        };
        return sub(Stdlib__List.length(l$1), l$1)[0];
      } else {
        return add(match$3.hd, add(x3, add(x2, add(x1, singleton(x0)))));
      }
    } else {
      return add(x3, add(x2, add(x1, singleton(x0))));
    }
  };
  var add_seq = function (i, m) {
    return Stdlib__Seq.fold_left((function (s, x) {
                  return add(x, s);
                }), m, i);
  };
  var of_seq = function (i) {
    return add_seq(i, /* Empty */0);
  };
  var seq_of_enum_ = function (c, param) {
    if (!c) {
      return /* Nil */0;
    }
    var partial_arg = cons_enum(c._1, c._2);
    return /* Cons */{
            _0: c._0,
            _1: (function (param) {
                return seq_of_enum_(partial_arg, param);
              })
          };
  };
  var to_seq = function (c) {
    var partial_arg = cons_enum(c, /* End */0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  var snoc_enum = function (_s, _e) {
    while(true) {
      var e = _e;
      var s = _s;
      if (!s) {
        return e;
      }
      _e = /* More */{
        _0: s.v,
        _1: s.l,
        _2: e
      };
      _s = s.r;
      continue ;
    };
  };
  var rev_seq_of_enum_ = function (c, param) {
    if (!c) {
      return /* Nil */0;
    }
    var partial_arg = snoc_enum(c._1, c._2);
    return /* Cons */{
            _0: c._0,
            _1: (function (param) {
                return rev_seq_of_enum_(partial_arg, param);
              })
          };
  };
  var to_rev_seq = function (c) {
    var partial_arg = snoc_enum(c, /* End */0);
    return function (param) {
      return rev_seq_of_enum_(partial_arg, param);
    };
  };
  var to_seq_from = function (low, s) {
    var aux = function (low, _s, _c) {
      while(true) {
        var c = _c;
        var s = _s;
        if (!s) {
          return c;
        }
        var r = s.r;
        var v = s.v;
        var n = Curry._2(funarg.compare, v, low);
        if (n === 0) {
          return /* More */{
                  _0: v,
                  _1: r,
                  _2: c
                };
        }
        if (n < 0) {
          _s = r;
          continue ;
        }
        _c = /* More */{
          _0: v,
          _1: r,
          _2: c
        };
        _s = s.l;
        continue ;
      };
    };
    var partial_arg = aux(low, s, /* End */0);
    return function (param) {
      return seq_of_enum_(partial_arg, param);
    };
  };
  return {
          empty: /* Empty */0,
          add: add,
          singleton: singleton,
          remove: remove,
          union: union,
          inter: inter,
          disjoint: disjoint,
          diff: diff,
          cardinal: cardinal,
          elements: elements,
          min_elt: min_elt,
          min_elt_opt: min_elt_opt,
          max_elt: max_elt,
          max_elt_opt: max_elt_opt,
          choose: min_elt,
          choose_opt: min_elt_opt,
          find: find,
          find_opt: find_opt,
          find_first: find_first,
          find_first_opt: find_first_opt,
          find_last: find_last,
          find_last_opt: find_last_opt,
          iter: iter,
          fold: fold,
          map: map,
          filter: filter,
          filter_map: filter_map,
          partition: partition,
          split: split,
          is_empty: is_empty,
          mem: mem,
          equal: equal,
          compare: compare,
          subset: subset,
          for_all: for_all,
          exists: exists,
          to_list: elements,
          of_list: of_list,
          to_seq_from: to_seq_from,
          to_seq: to_seq,
          to_rev_seq: to_rev_seq,
          add_seq: add_seq,
          of_seq: of_seq
        };
}

export {
  Make ,
}
/* No side effect */
`,mf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

var Empty = /* @__PURE__ */Caml_exceptions.create("Stdlib.Stack.Empty");

function create(param) {
  return {
          c: /* [] */0,
          len: 0
        };
}

function clear(s) {
  s.c = /* [] */0;
  s.len = 0;
}

function copy(s) {
  return {
          c: s.c,
          len: s.len
        };
}

function push(x, s) {
  s.c = {
    hd: x,
    tl: s.c
  };
  s.len = s.len + 1 | 0;
}

function pop(s) {
  var match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return match.hd;
  }
  throw {
        MEL_EXN_ID: Empty,
        Error: new Error()
      };
}

function pop_opt(s) {
  var match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return Caml_option.some(match.hd);
  }
  
}

function drop(s) {
  var match = s.c;
  if (match) {
    s.c = match.tl;
    s.len = s.len - 1 | 0;
    return ;
  }
  throw {
        MEL_EXN_ID: Empty,
        Error: new Error()
      };
}

function top(s) {
  var match = s.c;
  if (match) {
    return match.hd;
  }
  throw {
        MEL_EXN_ID: Empty,
        Error: new Error()
      };
}

function top_opt(s) {
  var match = s.c;
  if (match) {
    return Caml_option.some(match.hd);
  }
  
}

function is_empty(s) {
  return Caml_obj.caml_equal(s.c, /* [] */0);
}

function length(s) {
  return s.len;
}

function iter(f, s) {
  Stdlib__List.iter(f, s.c);
}

function fold(f, acc, s) {
  return Stdlib__List.fold_left(f, acc, s.c);
}

function to_seq(s) {
  return Stdlib__List.to_seq(s.c);
}

function add_seq(q, i) {
  Stdlib__Seq.iter((function (x) {
          push(x, q);
        }), i);
}

function of_seq(g) {
  var s = {
    c: /* [] */0,
    len: 0
  };
  add_seq(s, g);
  return s;
}

export {
  Empty ,
  create ,
  push ,
  pop ,
  pop_opt ,
  drop ,
  top ,
  top_opt ,
  clear ,
  copy ,
  is_empty ,
  length ,
  iter ,
  fold ,
  to_seq ,
  add_seq ,
  of_seq ,
}
/* No side effect */
`,pf=`// Generated by Melange
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
`,df=`// Generated by Melange

import * as Stdlib from "./stdlib.js";

Stdlib.do_at_exit(undefined);

export {
  
}
/*  Not a pure module */
`,hf=`// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as CamlinternalFormatBasics from "./camlinternalFormatBasics.js";
import * as Curry from "melange.js/curry.js";

function failwith(s) {
  throw {
        MEL_EXN_ID: "Failure",
        _1: s,
        Error: new Error()
      };
}

function invalid_arg(s) {
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: s,
        Error: new Error()
      };
}

var Exit = /* @__PURE__ */Caml_exceptions.create("Stdlib.Exit");

var Failure = "Failure";

var Sys_error = "Sys_error";

var End_of_file = "End_of_file";

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int = -2147483648;

function classify_float(x) {
  if (isFinite(x)) {
    if (Math.abs(x) >= 2.22507385850720138e-308) {
      return /* FP_normal */0;
    } else if (x !== 0) {
      return /* FP_subnormal */1;
    } else {
      return /* FP_zero */2;
    }
  } else if (isNaN(x)) {
    return /* FP_nan */4;
  } else {
    return /* FP_infinite */3;
  }
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "char_of_int",
          Error: new Error()
        };
  }
  return n;
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      throw {
            MEL_EXN_ID: "Invalid_argument",
            _1: "bool_of_string",
            Error: new Error()
          };
  }
}

function bool_of_string_opt(param) {
  switch (param) {
    case "false" :
        return false;
    case "true" :
        return true;
    default:
      return ;
  }
}

function int_of_string_opt(s) {
  try {
    return Caml_format.caml_int_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return ;
    }
    throw exn;
  }
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return s + ".";
    }
    var match = Caml_string.get(s, i);
    if (match >= 48) {
      if (match >= 58) {
        return s;
      }
      _i = i + 1 | 0;
      continue ;
    }
    if (match !== 45) {
      return s;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
}

function float_of_string_opt(s) {
  try {
    return Caml_format.caml_float_of_string(s);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Failure) {
      return ;
    }
    throw exn;
  }
}

function $at_dps(_dst, _offset, _l1, l2) {
  while(true) {
    var dst = _dst;
    var offset = _offset;
    var l1 = _l1;
    if (!l1) {
      dst[offset] = l2;
      return ;
    }
    var match = l1.tl;
    var h1 = l1.hd;
    if (!match) {
      dst[offset] = {
        hd: h1,
        tl: l2
      };
      return ;
    }
    var match$1 = match.tl;
    var h2 = match.hd;
    if (!match$1) {
      dst[offset] = {
        hd: h1,
        tl: {
          hd: h2,
          tl: l2
        }
      };
      return ;
    }
    var block = {
      hd: match$1.hd,
      tl: 24029
    };
    dst[offset] = {
      hd: h1,
      tl: {
        hd: h2,
        tl: block
      }
    };
    _l1 = match$1.tl;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function $at(l1, l2) {
  if (!l1) {
    return l2;
  }
  var match = l1.tl;
  var h1 = l1.hd;
  if (!match) {
    return {
            hd: h1,
            tl: l2
          };
  }
  var match$1 = match.tl;
  var h2 = match.hd;
  if (!match$1) {
    return {
            hd: h1,
            tl: {
              hd: h2,
              tl: l2
            }
          };
  }
  var block = {
    hd: match$1.hd,
    tl: 24029
  };
  return {
          hd: h1,
          tl: {
            hd: h2,
            tl: ($at_dps(block, "tl", match$1.tl, l2), block)
          }
        };
}

var stdin = Caml_io.stdin;

var stdout = Caml_io.stdout;

var stderr = Caml_io.stderr;

function open_out_gen(mode, perm, name) {
  var c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_out")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_out(name) {
  return open_out_gen({
              hd: /* Open_wronly */1,
              tl: {
                hd: /* Open_creat */3,
                tl: {
                  hd: /* Open_trunc */4,
                  tl: {
                    hd: /* Open_text */7,
                    tl: /* [] */0
                  }
                }
              }
            }, 438, name);
}

function open_out_bin(name) {
  return open_out_gen({
              hd: /* Open_wronly */1,
              tl: {
                hd: /* Open_creat */3,
                tl: {
                  hd: /* Open_trunc */4,
                  tl: {
                    hd: /* Open_binary */6,
                    tl: /* [] */0
                  }
                }
              }
            }, 438, name);
}

function flush_all(param) {
  var _param = Caml_io.caml_ml_out_channels_list(undefined);
  while(true) {
    var param$1 = _param;
    if (!param$1) {
      return ;
    }
    try {
      Caml_io.caml_ml_flush(param$1.hd);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID !== Sys_error) {
        throw exn;
      }
      
    }
    _param = param$1.tl;
    continue ;
  };
}

function output_bytes(oc, s) {
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, 0, s.length);
}

function output_string(oc, s) {
  Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "output",
          Error: new Error()
        };
  }
  Caml_external_polyfill.resolve("caml_ml_output_bytes")(oc, s, ofs, len);
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "output_substring",
          Error: new Error()
        };
  }
  Caml_io.caml_ml_output(oc, s, ofs, len);
}

function output_value(chan, v) {
  Caml_external_polyfill.resolve("caml_output_value")(chan, v, /* [] */0);
}

function close_out(oc) {
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function close_out_noerr(oc) {
  try {
    Caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
  }
  catch (exn$1){
    return ;
  }
}

function open_in_gen(mode, perm, name) {
  var c = Caml_external_polyfill.resolve("caml_ml_open_descriptor_in")(Caml_external_polyfill.resolve("caml_sys_open")(name, mode, perm));
  Caml_external_polyfill.resolve("caml_ml_set_channel_name")(c, name);
  return c;
}

function open_in(name) {
  return open_in_gen({
              hd: /* Open_rdonly */0,
              tl: {
                hd: /* Open_text */7,
                tl: /* [] */0
              }
            }, 0, name);
}

function open_in_bin(name) {
  return open_in_gen({
              hd: /* Open_rdonly */0,
              tl: {
                hd: /* Open_binary */6,
                tl: /* [] */0
              }
            }, 0, name);
}

function input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "input",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
}

function unsafe_really_input(ic, s, _ofs, _len) {
  while(true) {
    var len = _len;
    var ofs = _ofs;
    if (len <= 0) {
      return ;
    }
    var r = Caml_external_polyfill.resolve("caml_ml_input")(ic, s, ofs, len);
    if (r === 0) {
      throw {
            MEL_EXN_ID: End_of_file,
            Error: new Error()
          };
    }
    _len = len - r | 0;
    _ofs = ofs + r | 0;
    continue ;
  };
}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "really_input",
          Error: new Error()
        };
  }
  unsafe_really_input(ic, s, ofs, len);
}

function really_input_string(ic, len) {
  var s = Caml_bytes.caml_create_bytes(len);
  really_input(ic, s, 0, len);
  return Caml_bytes.bytes_to_string(s);
}

function input_line(chan) {
  var build_result = function (buf, _pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (!param) {
        return buf;
      }
      var hd = param.hd;
      var len = hd.length;
      Caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
      _param = param.tl;
      _pos = pos - len | 0;
      continue ;
    };
  };
  var scan = function (_accu, _len) {
    while(true) {
      var len = _len;
      var accu = _accu;
      var n = Caml_external_polyfill.resolve("caml_ml_input_scan_line")(chan);
      if (n === 0) {
        if (accu) {
          return build_result(Caml_bytes.caml_create_bytes(len), len, accu);
        }
        throw {
              MEL_EXN_ID: End_of_file,
              Error: new Error()
            };
      }
      if (n > 0) {
        var res = Caml_bytes.caml_create_bytes(n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input")(chan, res, 0, n - 1 | 0);
        Caml_external_polyfill.resolve("caml_ml_input_char")(chan);
        if (!accu) {
          return res;
        }
        var len$1 = (len + n | 0) - 1 | 0;
        return build_result(Caml_bytes.caml_create_bytes(len$1), len$1, {
                    hd: res,
                    tl: accu
                  });
      }
      var beg = Caml_bytes.caml_create_bytes(-n | 0);
      Caml_external_polyfill.resolve("caml_ml_input")(chan, beg, 0, -n | 0);
      _len = len - n | 0;
      _accu = {
        hd: beg,
        tl: accu
      };
      continue ;
    };
  };
  return Caml_bytes.bytes_to_string(scan(/* [] */0, 0));
}

function close_in_noerr(ic) {
  try {
    return Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  }
  catch (exn){
    return ;
  }
}

function print_char(c) {
  Caml_io.caml_ml_output_char(stdout, c);
}

function print_string(s) {
  output_string(stdout, s);
}

function print_bytes(s) {
  output_bytes(stdout, s);
}

function print_int(i) {
  output_string(stdout, String(i));
}

function print_float(f) {
  output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function print_newline(param) {
  Caml_io.caml_ml_output_char(stdout, /* '\\n' */10);
  Caml_io.caml_ml_flush(stdout);
}

function prerr_char(c) {
  Caml_io.caml_ml_output_char(stderr, c);
}

function prerr_string(s) {
  output_string(stderr, s);
}

function prerr_bytes(s) {
  output_bytes(stderr, s);
}

function prerr_int(i) {
  output_string(stderr, String(i));
}

function prerr_float(f) {
  output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function prerr_newline(param) {
  Caml_io.caml_ml_output_char(stderr, /* '\\n' */10);
  Caml_io.caml_ml_flush(stderr);
}

function read_line(param) {
  Caml_io.caml_ml_flush(stdout);
  return input_line(stdin);
}

function read_int(param) {
  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_int_opt(param) {
  return int_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float(param) {
  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float_opt(param) {
  return float_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function string_of_format(param) {
  return param._1;
}

function $caret$caret(param, param$1) {
  return /* Format */{
          _0: CamlinternalFormatBasics.concat_fmt(param._0, param$1._0),
          _1: param._1 + ("%," + param$1._1)
        };
}

var exit_function = {
  contents: flush_all
};

function at_exit(f) {
  var f_yet_to_run = {
    contents: true
  };
  var old_exit = exit_function.contents;
  var new_exit = function (param) {
    if (!f_yet_to_run.contents) {
      f_yet_to_run.contents = false;
      Curry._1(f, undefined);
    }
    Curry._1(old_exit, undefined);
  };
  exit_function.contents = new_exit;
}

var do_domain_local_at_exit = {
  contents: (function (param) {
      
    })
};

function do_at_exit(param) {
  Curry._1(do_domain_local_at_exit.contents, undefined);
  Curry._1(exit_function.contents, undefined);
}

function exit(retcode) {
  do_at_exit(undefined);
  return Caml_sys.caml_sys_exit(retcode);
}

var Match_failure = "Match_failure";

var Assert_failure = "Assert_failure";

var Invalid_argument = "Invalid_argument";

var Not_found = "Not_found";

var Out_of_memory = "Out_of_memory";

var Stack_overflow = "Stack_overflow";

var Division_by_zero = "Division_by_zero";

var Sys_blocked_io = "Sys_blocked_io";

var Undefined_recursive_module = "Undefined_recursive_module";

var max_int = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var max_float = 1.79769313486231571e+308;

var min_float = 2.22507385850720138e-308;

var epsilon_float = 2.22044604925031308e-16;

var flush = Caml_io.caml_ml_flush;

var output_char = Caml_io.caml_ml_output_char;

var output_byte = Caml_io.caml_ml_output_char;

function output_binary_int(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_output_int")(prim0, prim1);
}

function seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out")(prim0, prim1);
}

function pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out")(prim);
}

function out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function set_binary_mode_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function input_char(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_byte(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_char")(prim);
}

function input_binary_int(prim) {
  return Caml_external_polyfill.resolve("caml_ml_input_int")(prim);
}

function input_value(prim) {
  return Caml_external_polyfill.resolve("caml_input_value")(prim);
}

function seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in")(prim0, prim1);
}

function pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in")(prim);
}

function in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size")(prim);
}

function close_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_close_channel")(prim);
}

function set_binary_mode_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_set_binary_mode")(prim0, prim1);
}

function LargeFile_seek_out(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_out_64")(prim0, prim1);
}

function LargeFile_pos_out(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_out_64")(prim);
}

function LargeFile_out_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

function LargeFile_seek_in(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_ml_seek_in_64")(prim0, prim1);
}

function LargeFile_pos_in(prim) {
  return Caml_external_polyfill.resolve("caml_ml_pos_in_64")(prim);
}

function LargeFile_in_channel_length(prim) {
  return Caml_external_polyfill.resolve("caml_ml_channel_size_64")(prim);
}

var LargeFile = {
  seek_out: LargeFile_seek_out,
  pos_out: LargeFile_pos_out,
  out_channel_length: LargeFile_out_channel_length,
  seek_in: LargeFile_seek_in,
  pos_in: LargeFile_pos_in,
  in_channel_length: LargeFile_in_channel_length
};

export {
  invalid_arg ,
  failwith ,
  Exit ,
  Match_failure ,
  Assert_failure ,
  Invalid_argument ,
  Failure ,
  Not_found ,
  Out_of_memory ,
  Stack_overflow ,
  Sys_error ,
  End_of_file ,
  Division_by_zero ,
  Sys_blocked_io ,
  Undefined_recursive_module ,
  abs ,
  max_int ,
  min_int ,
  lnot ,
  infinity ,
  neg_infinity ,
  max_float ,
  min_float ,
  epsilon_float ,
  classify_float ,
  char_of_int ,
  string_of_bool ,
  bool_of_string_opt ,
  bool_of_string ,
  int_of_string_opt ,
  string_of_float ,
  float_of_string_opt ,
  $at ,
  stdin ,
  stdout ,
  stderr ,
  print_char ,
  print_string ,
  print_bytes ,
  print_int ,
  print_float ,
  print_newline ,
  prerr_char ,
  prerr_string ,
  prerr_bytes ,
  prerr_int ,
  prerr_float ,
  prerr_newline ,
  read_line ,
  read_int_opt ,
  read_int ,
  read_float_opt ,
  read_float ,
  open_out ,
  open_out_bin ,
  open_out_gen ,
  flush ,
  flush_all ,
  output_char ,
  output_string ,
  output_bytes ,
  output ,
  output_substring ,
  output_byte ,
  output_binary_int ,
  output_value ,
  seek_out ,
  pos_out ,
  out_channel_length ,
  close_out ,
  close_out_noerr ,
  set_binary_mode_out ,
  open_in ,
  open_in_bin ,
  open_in_gen ,
  input_char ,
  input_line ,
  input ,
  really_input ,
  really_input_string ,
  input_byte ,
  input_binary_int ,
  input_value ,
  seek_in ,
  pos_in ,
  in_channel_length ,
  close_in ,
  close_in_noerr ,
  set_binary_mode_in ,
  LargeFile ,
  string_of_format ,
  $caret$caret ,
  exit ,
  at_exit ,
  valid_float_lexem ,
  unsafe_really_input ,
  do_at_exit ,
  do_domain_local_at_exit ,
}
/* No side effect */
`,gf=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";

function make(n, c) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, c));
}

function init(n, f) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.init(n, f));
}

function sub(s, ofs, len) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.sub(Caml_bytes.bytes_of_string(s), ofs, len));
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: "String.concat",
        Error: new Error()
      };
}

function sum_lengths(_acc, seplen, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    var hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue ;
  };
}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while(true) {
    var param = _param;
    var pos = _pos;
    if (!param) {
      return dst;
    }
    var hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue ;
    }
    Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function concat(sep, l) {
  if (!l) {
    return "";
  }
  var seplen = sep.length;
  return Caml_bytes.bytes_to_string(unsafe_blits(Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l));
}

function cat(prim0, prim1) {
  return prim0 + prim1;
}

function iter(f, s) {
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    Curry._1(f, s.charCodeAt(i));
  }
}

function iteri(f, s) {
  for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
    Curry._2(f, i, s.charCodeAt(i));
  }
}

function map(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.map(f, Caml_bytes.bytes_of_string(s)));
}

function mapi(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.mapi(f, Caml_bytes.bytes_of_string(s)));
}

function fold_right(f, x, a) {
  return Stdlib__Bytes.fold_right(f, Caml_bytes.bytes_of_string(x), a);
}

function fold_left(f, a, x) {
  return Stdlib__Bytes.fold_left(f, a, Caml_bytes.bytes_of_string(x));
}

function exists(f, s) {
  return Stdlib__Bytes.exists(f, Caml_bytes.bytes_of_string(s));
}

function for_all(f, s) {
  return Stdlib__Bytes.for_all(f, Caml_bytes.bytes_of_string(s));
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(Stdlib__Bytes.trim(Caml_bytes.bytes_of_string(s)));
  }
}

function escaped(s) {
  var b = Caml_bytes.bytes_of_string(s);
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.unsafe_escape(b));
}

function index_rec(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from / Bytes.index_from",
          Error: new Error()
        };
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.index_from_opt / Bytes.index_from_opt",
          Error: new Error()
        };
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw {
            MEL_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from / Bytes.rindex_from",
          Error: new Error()
        };
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rindex_from_opt / Bytes.rindex_from_opt",
          Error: new Error()
        };
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.contains_from / Bytes.contains_from",
          Error: new Error()
        };
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "String.rcontains_from / Bytes.rcontains_from",
          Error: new Error()
        };
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw exn;
  }
}

function uppercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.capitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uncapitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function starts_with(prefix, s) {
  var len_s = s.length;
  var len_pre = prefix.length;
  if (len_s >= len_pre) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s.charCodeAt(i) !== prefix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  var len_s = s.length;
  var len_suf = suffix.length;
  var diff = len_s - len_suf | 0;
  if (diff >= 0) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s.charCodeAt(diff + i | 0) !== suffix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function hash(x) {
  return Caml_external_polyfill.resolve("caml_string_hash")(0, x);
}

function split_on_char(sep, s) {
  var r = /* [] */0;
  var j = s.length;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
          hd: sub(s, 0, j),
          tl: r
        };
}

var compare = Caml.caml_string_compare;

function to_seq(s) {
  return Stdlib__Bytes.to_seq(Caml_bytes.bytes_of_string(s));
}

function to_seqi(s) {
  return Stdlib__Bytes.to_seqi(Caml_bytes.bytes_of_string(s));
}

function of_seq(g) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.of_seq(g));
}

var empty = "";

var of_bytes = Stdlib__Bytes.to_string;

var to_bytes = Stdlib__Bytes.of_string;

function equal(prim0, prim1) {
  return prim0 === prim1;
}

var blit = Stdlib__Bytes.blit_string;

function seeded_hash(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_string_hash")(prim0, prim1);
}

export {
  make ,
  init ,
  empty ,
  of_bytes ,
  to_bytes ,
  concat ,
  cat ,
  equal ,
  compare ,
  starts_with ,
  ends_with ,
  contains_from ,
  rcontains_from ,
  contains ,
  sub ,
  split_on_char ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  for_all ,
  exists ,
  trim ,
  escaped ,
  uppercase_ascii ,
  lowercase_ascii ,
  capitalize_ascii ,
  uncapitalize_ascii ,
  iter ,
  iteri ,
  index_from ,
  index_from_opt ,
  rindex_from ,
  rindex_from_opt ,
  index ,
  index_opt ,
  rindex ,
  rindex_opt ,
  to_seq ,
  to_seqi ,
  of_seq ,
  blit ,
  hash ,
  seeded_hash ,
}
/* No side effect */
`,bf=`// Generated by Melange

import * as Stdlib__String from "./string.js";

var make = Stdlib__String.make;

var init = Stdlib__String.init;

var empty = Stdlib__String.empty;

var of_bytes = Stdlib__String.of_bytes;

var to_bytes = Stdlib__String.to_bytes;

var concat = Stdlib__String.concat;

var cat = Stdlib__String.cat;

var equal = Stdlib__String.equal;

var compare = Stdlib__String.compare;

var starts_with = Stdlib__String.starts_with;

var ends_with = Stdlib__String.ends_with;

var contains_from = Stdlib__String.contains_from;

var rcontains_from = Stdlib__String.rcontains_from;

var contains = Stdlib__String.contains;

var sub = Stdlib__String.sub;

var split_on_char = Stdlib__String.split_on_char;

var map = Stdlib__String.map;

var mapi = Stdlib__String.mapi;

var fold_left = Stdlib__String.fold_left;

var fold_right = Stdlib__String.fold_right;

var for_all = Stdlib__String.for_all;

var exists = Stdlib__String.exists;

var trim = Stdlib__String.trim;

var escaped = Stdlib__String.escaped;

var uppercase_ascii = Stdlib__String.uppercase_ascii;

var lowercase_ascii = Stdlib__String.lowercase_ascii;

var capitalize_ascii = Stdlib__String.capitalize_ascii;

var uncapitalize_ascii = Stdlib__String.uncapitalize_ascii;

var iter = Stdlib__String.iter;

var iteri = Stdlib__String.iteri;

var index_from = Stdlib__String.index_from;

var index_from_opt = Stdlib__String.index_from_opt;

var rindex_from = Stdlib__String.rindex_from;

var rindex_from_opt = Stdlib__String.rindex_from_opt;

var index = Stdlib__String.index;

var index_opt = Stdlib__String.index_opt;

var rindex = Stdlib__String.rindex;

var rindex_opt = Stdlib__String.rindex_opt;

var to_seq = Stdlib__String.to_seq;

var to_seqi = Stdlib__String.to_seqi;

var of_seq = Stdlib__String.of_seq;

var blit = Stdlib__String.blit;

export {
  make ,
  init ,
  empty ,
  of_bytes ,
  to_bytes ,
  concat ,
  cat ,
  equal ,
  compare ,
  starts_with ,
  ends_with ,
  contains_from ,
  rcontains_from ,
  contains ,
  sub ,
  split_on_char ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  for_all ,
  exists ,
  trim ,
  escaped ,
  uppercase_ascii ,
  lowercase_ascii ,
  capitalize_ascii ,
  uncapitalize_ascii ,
  iter ,
  iteri ,
  index_from ,
  index_from_opt ,
  rindex_from ,
  rindex_from_opt ,
  index ,
  index_opt ,
  rindex ,
  rindex_opt ,
  to_seq ,
  to_seqi ,
  of_seq ,
  blit ,
}
/* No side effect */
`,vf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_sys from "melange.js/caml_sys.js";

var executable_name = Caml_sys.caml_sys_executable_name(undefined);

var os_type = Caml_sys.os_type(undefined);

var backend_type = /* Other */{
  _0: "BS"
};

var big_endian = false;

var unix = Caml_sys.os_type(undefined) === "Unix";

var win32 = Caml_sys.os_type(undefined) === "Win32";

function getenv_opt(s) {
  var x = typeof process === "undefined" ? undefined : process;
  if (x !== undefined) {
    return x.env[s];
  }
  
}

var interactive = {
  contents: false
};

function set_signal(sig_num, sig_beh) {
  
}

var Break = /* @__PURE__ */Caml_exceptions.create("Stdlib.Sys.Break");

function catch_break(on) {
  
}

function Make(Immediate, Non_immediate) {
  var repr = /* Non_immediate */1;
  return {
          repr: repr
        };
}

var Immediate64 = {
  Make: Make
};

var cygwin = false;

var word_size = 32;

var int_size = 32;

var max_string_length = 2147483647;

var max_array_length = 2147483647;

var max_floatarray_length = 2147483647;

var sigabrt = -1;

var sigalrm = -2;

var sigfpe = -3;

var sighup = -4;

var sigill = -5;

var sigint = -6;

var sigkill = -7;

var sigpipe = -8;

var sigquit = -9;

var sigsegv = -10;

var sigterm = -11;

var sigusr1 = -12;

var sigusr2 = -13;

var sigchld = -14;

var sigcont = -15;

var sigstop = -16;

var sigtstp = -17;

var sigttin = -18;

var sigttou = -19;

var sigvtalrm = -20;

var sigprof = -21;

var sigbus = -22;

var sigpoll = -23;

var sigsys = -24;

var sigtrap = -25;

var sigurg = -26;

var sigxcpu = -27;

var sigxfsz = -28;

var ocaml_version = "4.14.0+mel";

var development_version = false;

var ocaml_release = {
  major: 4,
  minor: 14,
  patchlevel: 0,
  extra: [
    /* Plus */0,
    "mel"
  ]
};

function enable_runtime_warnings(prim) {
  return Caml_external_polyfill.resolve("caml_ml_enable_runtime_warnings")(prim);
}

function runtime_warnings_enabled(prim) {
  return Caml_external_polyfill.resolve("caml_ml_runtime_warnings_enabled")(prim);
}

export {
  executable_name ,
  getenv_opt ,
  interactive ,
  os_type ,
  backend_type ,
  unix ,
  win32 ,
  cygwin ,
  word_size ,
  int_size ,
  big_endian ,
  max_string_length ,
  max_array_length ,
  max_floatarray_length ,
  set_signal ,
  sigabrt ,
  sigalrm ,
  sigfpe ,
  sighup ,
  sigill ,
  sigint ,
  sigkill ,
  sigpipe ,
  sigquit ,
  sigsegv ,
  sigterm ,
  sigusr1 ,
  sigusr2 ,
  sigchld ,
  sigcont ,
  sigstop ,
  sigtstp ,
  sigttin ,
  sigttou ,
  sigvtalrm ,
  sigprof ,
  sigbus ,
  sigpoll ,
  sigsys ,
  sigtrap ,
  sigurg ,
  sigxcpu ,
  sigxfsz ,
  Break ,
  catch_break ,
  ocaml_version ,
  development_version ,
  ocaml_release ,
  enable_runtime_warnings ,
  runtime_warnings_enabled ,
  Immediate64 ,
}
/* No side effect */
`,yf=`// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Stdlib__Obj from "./obj.js";

function make(param) {
  var Id = /* @__PURE__ */Caml_exceptions.create("Id");
  return {
          Id: Id
        };
}

function uid(A) {
  return Stdlib__Obj.Extension_constructor.id(Stdlib__Obj.Extension_constructor.of_val({
                  MEL_EXN_ID: A.Id
                }));
}

function provably_equal(A, B) {
  if (A.Id === B.Id) {
    return /* Equal */0;
  }
  
}

var Id = {
  make: make,
  uid: uid,
  provably_equal: provably_equal
};

export {
  Id ,
}
/* No side effect */
`,xf=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_format from "melange.js/caml_format.js";

function err_not_sv(i) {
  return Caml_format.caml_format_int("%X", i) + " is not an Unicode scalar value";
}

function err_not_latin1(u) {
  return "U+" + (Caml_format.caml_format_int("%04X", u) + " is not a latin1 character");
}

function succ(u) {
  if (u === 55295) {
    return 57344;
  }
  if (u === 1114111) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "U+10FFFF has no successor",
          Error: new Error()
        };
  }
  return u + 1 | 0;
}

function pred(u) {
  if (u === 57344) {
    return 55295;
  }
  if (u === 0) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "U+0000 has no predecessor",
          Error: new Error()
        };
  }
  return u - 1 | 0;
}

function is_valid(i) {
  if (0 <= i && i <= 55295) {
    return true;
  } else if (57344 <= i) {
    return i <= 1114111;
  } else {
    return false;
  }
}

function of_int(i) {
  if (is_valid(i)) {
    return i;
  }
  var s = err_not_sv(i);
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: s,
        Error: new Error()
      };
}

function is_char(u) {
  return u < 256;
}

function of_char(c) {
  return c;
}

function to_char(u) {
  if (u <= 255) {
    return u;
  }
  var s = err_not_latin1(u);
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: s,
        Error: new Error()
      };
}

function unsafe_to_char(prim) {
  return prim;
}

function equal(prim0, prim1) {
  return prim0 === prim1;
}

var compare = Caml.caml_int_compare;

function hash(prim) {
  return prim;
}

function utf_decode_is_valid(d) {
  return (d >>> 27) === 1;
}

function utf_decode_length(d) {
  return (d >>> 24) & 7;
}

function utf_decode_uchar(d) {
  return d & 16777215;
}

function utf_decode(n, u) {
  return ((8 | n) << 24) | u;
}

function utf_decode_invalid(n) {
  return (n << 24) | 65533;
}

function utf_8_byte_length(u) {
  if (u < 0) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/uchar.ml",
            80,
            18
          ],
          Error: new Error()
        };
  }
  if (u <= 127) {
    return 1;
  }
  if (u <= 2047) {
    return 2;
  }
  if (u <= 65535) {
    return 3;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          85,
          7
        ],
        Error: new Error()
      };
}

function utf_16_byte_length(u) {
  if (u < 0) {
    throw {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "jscomp/stdlib/uchar.ml",
            88,
            18
          ],
          Error: new Error()
        };
  }
  if (u <= 65535) {
    return 2;
  }
  if (u <= 1114111) {
    return 4;
  }
  throw {
        MEL_EXN_ID: "Assert_failure",
        _1: [
          "jscomp/stdlib/uchar.ml",
          91,
          7
        ],
        Error: new Error()
      };
}

var min = 0;

var max = 1114111;

var bom = 65279;

var rep = 65533;

function unsafe_of_int(prim) {
  return prim;
}

function to_int(prim) {
  return prim;
}

export {
  min ,
  max ,
  bom ,
  rep ,
  succ ,
  pred ,
  is_valid ,
  of_int ,
  unsafe_of_int ,
  to_int ,
  is_char ,
  of_char ,
  to_char ,
  unsafe_to_char ,
  equal ,
  compare ,
  hash ,
  utf_decode_is_valid ,
  utf_decode_uchar ,
  utf_decode_length ,
  utf_decode ,
  utf_decode_invalid ,
  utf_8_byte_length ,
  utf_16_byte_length ,
}
/* No side effect */
`,$f=`// Generated by Melange


function equal(param, param$1) {
  return true;
}

function compare(param, param$1) {
  return 0;
}

function to_string(param) {
  return "()";
}

export {
  equal ,
  compare ,
  to_string ,
}
/* No side effect */
`,Ef=`// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Sys from "./sys.js";

function create(l) {
  if (!(0 <= l && l <= Stdlib__Obj.Ephemeron.max_ephe_length)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Weak.create",
          Error: new Error()
        };
  }
  return Caml_external_polyfill.resolve("caml_weak_create")(l);
}

function length(x) {
  return (x.length | 0) - 2 | 0;
}

function raise_if_invalid_offset(e, o, msg) {
  if (0 <= o && o < length(e)) {
    return ;
  }
  throw {
        MEL_EXN_ID: "Invalid_argument",
        _1: msg,
        Error: new Error()
      };
}

function set(e, o, x) {
  raise_if_invalid_offset(e, o, "Weak.set");
  if (x !== undefined) {
    return Caml_external_polyfill.resolve("caml_ephe_set_key")(e, o, Caml_option.valFromOption(x));
  } else {
    return Caml_external_polyfill.resolve("caml_ephe_unset_key")(e, o);
  }
}

function get(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get");
  return Caml_external_polyfill.resolve("caml_weak_get")(e, o);
}

function get_copy(e, o) {
  raise_if_invalid_offset(e, o, "Weak.get_copy");
  return Caml_external_polyfill.resolve("caml_weak_get_copy")(e, o);
}

function check(e, o) {
  raise_if_invalid_offset(e, o, "Weak.check");
  return Caml_external_polyfill.resolve("caml_weak_check")(e, o);
}

function blit(e1, o1, e2, o2, l) {
  if (l < 0 || o1 < 0 || o1 > (length(e1) - l | 0) || o2 < 0 || o2 > (length(e2) - l | 0)) {
    throw {
          MEL_EXN_ID: "Invalid_argument",
          _1: "Weak.blit",
          Error: new Error()
        };
  }
  if (l !== 0) {
    return Caml_external_polyfill.resolve("caml_weak_blit")(e1, o1, e2, o2, l);
  }
  
}

function fill(ar, ofs, len, x) {
  if (ofs < 0 || len < 0 || ofs > (length(ar) - len | 0)) {
    throw {
          MEL_EXN_ID: Stdlib.Invalid_argument,
          _1: "Weak.fill",
          Error: new Error()
        };
  }
  for(var i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    set(ar, i, x);
  }
}

function Make(H) {
  var emptybucket = create(0);
  var get_index = function (t, h) {
    return (h & Stdlib.max_int) % t.table.length;
  };
  var create$1 = function (sz) {
    var sz$1 = sz < 7 ? 7 : sz;
    var sz$2 = sz$1 > Stdlib__Sys.max_array_length ? Stdlib__Sys.max_array_length : sz$1;
    return {
            table: Caml_array.make(sz$2, emptybucket),
            hashes: Caml_array.make(sz$2, []),
            limit: 7,
            oversize: 0,
            rover: 0
          };
  };
  var clear = function (t) {
    for(var i = 0 ,i_finish = t.table.length; i < i_finish; ++i){
      Caml_array.set(t.table, i, emptybucket);
      Caml_array.set(t.hashes, i, []);
    }
    t.limit = 7;
    t.oversize = 0;
  };
  var fold = function (f, t, init) {
    return Stdlib__Array.fold_right((function (param, param$1) {
                  var _i = 0;
                  var _accu = param$1;
                  while(true) {
                    var accu = _accu;
                    var i = _i;
                    if (i >= length(param)) {
                      return accu;
                    }
                    var v = get(param, i);
                    if (v !== undefined) {
                      _accu = Curry._2(f, Caml_option.valFromOption(v), accu);
                      _i = i + 1 | 0;
                      continue ;
                    }
                    _i = i + 1 | 0;
                    continue ;
                  };
                }), t.table, init);
  };
  var iter = function (f, t) {
    Stdlib__Array.iter((function (param) {
            var _i = 0;
            while(true) {
              var i = _i;
              if (i >= length(param)) {
                return ;
              }
              var v = get(param, i);
              if (v !== undefined) {
                Curry._1(f, Caml_option.valFromOption(v));
                _i = i + 1 | 0;
                continue ;
              }
              _i = i + 1 | 0;
              continue ;
            };
          }), t.table);
  };
  var iter_weak = function (f, t) {
    Stdlib__Array.iteri((function (param, param$1) {
            var _i = 0;
            while(true) {
              var i = _i;
              if (i >= length(param$1)) {
                return ;
              }
              if (check(param$1, i)) {
                Curry._3(f, param$1, Caml_array.get(t.hashes, param), i);
                _i = i + 1 | 0;
                continue ;
              }
              _i = i + 1 | 0;
              continue ;
            };
          }), t.table);
  };
  var count_bucket = function (_i, b, _accu) {
    while(true) {
      var accu = _accu;
      var i = _i;
      if (i >= length(b)) {
        return accu;
      }
      _accu = accu + (
        check(b, i) ? 1 : 0
      ) | 0;
      _i = i + 1 | 0;
      continue ;
    };
  };
  var count = function (t) {
    return Stdlib__Array.fold_right((function (param, param$1) {
                  return count_bucket(0, param, param$1);
                }), t.table, 0);
  };
  var next_sz = function (n) {
    return Stdlib__Int.min((Math.imul(3, n) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length);
  };
  var prev_sz = function (n) {
    return (((n - 3 | 0) << 1) + 2 | 0) / 3 | 0;
  };
  var test_shrink_bucket = function (t) {
    var bucket = Caml_array.get(t.table, t.rover);
    var hbucket = Caml_array.get(t.hashes, t.rover);
    var len = length(bucket);
    var prev_len = prev_sz(len);
    var live = count_bucket(0, bucket, 0);
    if (live <= prev_len) {
      var loop = function (_i, _j) {
        while(true) {
          var j = _j;
          var i = _i;
          if (j < prev_len) {
            return ;
          }
          if (check(bucket, i)) {
            _i = i + 1 | 0;
            continue ;
          }
          if (check(bucket, j)) {
            blit(bucket, j, bucket, i, 1);
            Caml_array.set(hbucket, i, Caml_array.get(hbucket, j));
            _j = j - 1 | 0;
            _i = i + 1 | 0;
            continue ;
          }
          _j = j - 1 | 0;
          continue ;
        };
      };
      loop(0, length(bucket) - 1 | 0);
      if (prev_len === 0) {
        Caml_array.set(t.table, t.rover, emptybucket);
        Caml_array.set(t.hashes, t.rover, []);
      } else {
        var newbucket = create(prev_len);
        blit(bucket, 0, newbucket, 0, prev_len);
        Caml_array.set(t.table, t.rover, newbucket);
        Caml_array.set(t.hashes, t.rover, Stdlib__Array.sub(hbucket, 0, prev_len));
      }
      if (len > t.limit && prev_len <= t.limit) {
        t.oversize = t.oversize - 1 | 0;
      }
      
    }
    t.rover = (t.rover + 1 | 0) % t.table.length;
  };
  var add_aux = function (t, setter, d, h, index) {
    var bucket = Caml_array.get(t.table, index);
    var hashes = Caml_array.get(t.hashes, index);
    var sz = length(bucket);
    var _i = 0;
    while(true) {
      var i = _i;
      if (i >= sz) {
        var newsz = Stdlib__Int.min((Math.imul(3, sz) / 2 | 0) + 3 | 0, Stdlib__Sys.max_array_length - 2 | 0);
        if (newsz <= sz) {
          throw {
                MEL_EXN_ID: "Failure",
                _1: "Weak.Make: hash bucket cannot grow more",
                Error: new Error()
              };
        }
        var newbucket = create(newsz);
        var newhashes = Caml_array.make(newsz, 0);
        blit(bucket, 0, newbucket, 0, sz);
        Stdlib__Array.blit(hashes, 0, newhashes, 0, sz);
        Curry._3(setter, newbucket, sz, d);
        Caml_array.set(newhashes, sz, h);
        Caml_array.set(t.table, index, newbucket);
        Caml_array.set(t.hashes, index, newhashes);
        if (sz <= t.limit && newsz > t.limit) {
          t.oversize = t.oversize + 1 | 0;
          for(var _i$1 = 0; _i$1 <= 2; ++_i$1){
            test_shrink_bucket(t);
          }
        }
        if (t.oversize > (t.table.length >> 1)) {
          var oldlen = t.table.length;
          var newlen = next_sz(oldlen);
          if (newlen > oldlen) {
            var newt = create$1(newlen);
            var add_weak = (function(newt){
            return function add_weak(ob, oh, oi) {
              var setter = function (nb, ni, param) {
                blit(ob, oi, nb, ni, 1);
              };
              var h = Caml_array.get(oh, oi);
              add_aux(newt, setter, undefined, h, get_index(newt, h));
            }
            }(newt));
            iter_weak(add_weak, t);
            t.table = newt.table;
            t.hashes = newt.hashes;
            t.limit = newt.limit;
            t.oversize = newt.oversize;
            t.rover = t.rover % newt.table.length;
            return ;
          }
          t.limit = Stdlib.max_int;
          t.oversize = 0;
          return ;
        } else {
          return ;
        }
      }
      if (check(bucket, i)) {
        _i = i + 1 | 0;
        continue ;
      }
      Curry._3(setter, bucket, i, d);
      return Caml_array.set(hashes, i, h);
    };
  };
  var add = function (t, d) {
    var h = Curry._1(H.hash, d);
    add_aux(t, set, Caml_option.some(d), h, get_index(t, h));
  };
  var find_aux = function (t, d, found, notfound) {
    var h = Curry._1(H.hash, d);
    var index = get_index(t, h);
    var bucket = Caml_array.get(t.table, index);
    var hashes = Caml_array.get(t.hashes, index);
    var sz = length(bucket);
    var _i = 0;
    while(true) {
      var i = _i;
      if (i >= sz) {
        return Curry._2(notfound, h, index);
      }
      if (h === Caml_array.get(hashes, i)) {
        var opt = get(bucket, i);
        if (opt !== undefined) {
          var v = Caml_option.valFromOption(opt);
          if (Curry._2(H.equal, v, d)) {
            return Curry._4(found, bucket, i, opt, v);
          }
          _i = i + 1 | 0;
          continue ;
        }
        _i = i + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var find_opt = function (t, d) {
    return find_aux(t, d, (function (_b, _i, o, _v) {
                  return o;
                }), (function (_h, _i) {
                  
                }));
  };
  var merge = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
                  return v;
                }), (function (h, i) {
                  add_aux(t, set, Caml_option.some(d), h, i);
                  return d;
                }));
  };
  var find = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, v) {
                  return v;
                }), (function (_h, _i) {
                  throw {
                        MEL_EXN_ID: Stdlib.Not_found,
                        Error: new Error()
                      };
                }));
  };
  var remove = function (t, d) {
    find_aux(t, d, (function (b, i, _o, _v) {
            set(b, i, undefined);
          }), (function (_h, _i) {
            
          }));
  };
  var mem = function (t, d) {
    return find_aux(t, d, (function (_b, _i, _o, _v) {
                  return true;
                }), (function (_h, _i) {
                  return false;
                }));
  };
  var find_all = function (t, d) {
    var h = Curry._1(H.hash, d);
    var index = get_index(t, h);
    var bucket = Caml_array.get(t.table, index);
    var hashes = Caml_array.get(t.hashes, index);
    var sz = length(bucket);
    var _i = 0;
    var _accu = /* [] */0;
    while(true) {
      var accu = _accu;
      var i = _i;
      if (i >= sz) {
        return accu;
      }
      if (h === Caml_array.get(hashes, i)) {
        var v = get(bucket, i);
        if (v !== undefined) {
          var v$1 = Caml_option.valFromOption(v);
          if (Curry._2(H.equal, v$1, d)) {
            _accu = {
              hd: v$1,
              tl: accu
            };
            _i = i + 1 | 0;
            continue ;
          }
          _i = i + 1 | 0;
          continue ;
        }
        _i = i + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var stats = function (t) {
    var len = t.table.length;
    var lens = Stdlib__Array.map(length, t.table);
    Stdlib__Array.sort(Caml.caml_int_compare, lens);
    var totlen = Stdlib__Array.fold_left((function (prim0, prim1) {
            return prim0 + prim1 | 0;
          }), 0, lens);
    return [
            len,
            count(t),
            totlen,
            Caml_array.get(lens, 0),
            Caml_array.get(lens, len / 2 | 0),
            Caml_array.get(lens, len - 1 | 0)
          ];
  };
  return {
          create: create$1,
          clear: clear,
          merge: merge,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          mem: mem,
          iter: iter,
          fold: fold,
          count: count,
          stats: stats
        };
}

export {
  create ,
  length ,
  set ,
  get ,
  get_copy ,
  check ,
  fill ,
  blit ,
  Make ,
}
/* No side effect */
`;function An(t){for(var n=arguments.length,e=Array(n>1?n-1:0),r=1;r<n;r++)e[r-1]=arguments[r];throw Error("[Immer] minified error nr: "+t+(e.length?" "+e.map(function(a){return"'"+a+"'"}).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function Tt(t){return!!t&&!!t[tn]}function nt(t){return!!t&&(function(n){if(!n||typeof n!="object")return!1;var e=Object.getPrototypeOf(n);if(e===null)return!0;var r=Object.hasOwnProperty.call(e,"constructor")&&e.constructor;return r===Object||typeof r=="function"&&Function.toString.call(r)===jf}(t)||Array.isArray(t)||!!t[ye]||!!t.constructor[ye]||ir(t)||sr(t))}function jt(t,n,e){e===void 0&&(e=!1),bt(t)===0?(e?Object.keys:Sa)(t).forEach(function(r){e&&typeof r=="symbol"||n(r,t[r],t)}):t.forEach(function(r,a){return n(a,r,t)})}function bt(t){var n=t[tn];return n?n.i>3?n.i-4:n.i:Array.isArray(t)?1:ir(t)?2:sr(t)?3:0}function ge(t,n){return bt(t)===2?t.has(n):Object.prototype.hasOwnProperty.call(t,n)}function ar(t,n){return bt(t)===2?t.get(n):t[n]}function ds(t,n,e){var r=bt(t);r===2?t.set(n,e):r===3?(t.delete(n),t.add(e)):t[n]=e}function kf(t,n){return t===n?t!==0||1/t==1/n:t!=t&&n!=n}function ir(t){return Nf&&t instanceof Map}function sr(t){return Tf&&t instanceof Set}function kn(t){return t.o||t.t}function ga(t){if(Array.isArray(t))return Array.prototype.slice.call(t);var n=Lf(t);delete n[tn];for(var e=Sa(n),r=0;r<e.length;r++){var a=e[r],i=n[a];i.writable===!1&&(i.writable=!0,i.configurable=!0),(i.get||i.set)&&(n[a]={configurable:!0,writable:!0,enumerable:i.enumerable,value:t[a]})}return Object.create(Object.getPrototypeOf(t),n)}function ba(t,n){return n===void 0&&(n=!1),va(t)||Tt(t)||!nt(t)||(bt(t)>1&&(t.set=t.add=t.clear=t.delete=wf),Object.freeze(t),n&&jt(t,function(e,r){return ba(r,!0)},!0)),t}function wf(){An(2)}function va(t){return t==null||typeof t!="object"||Object.isFrozen(t)}function tt(t){var n=Aa[t];return n||An(18,t),n}function hs(t,n){Aa[t]||(Aa[t]=n)}function or(){return ve}function ya(t,n){n&&(tt("Patches"),t.u=[],t.s=[],t.v=n)}function _r(t){xa(t),t.p.forEach(Cf),t.p=null}function xa(t){t===ve&&(ve=t.l)}function gs(t){return ve={p:[],l:ve,h:t,m:!0,_:0}}function Cf(t){var n=t[tn];n.i===0||n.i===1?n.j():n.O=!0}function $a(t,n){n._=n.p.length;var e=n.p[0],r=t!==void 0&&t!==e;return n.h.g||tt("ES5").S(n,t,r),r?(e[tn].P&&(_r(n),An(4)),nt(t)&&(t=lr(n,t),n.l||cr(n,t)),n.u&&tt("Patches").M(e[tn].t,t,n.u,n.s)):t=lr(n,e,[]),_r(n),n.u&&n.v(n.u,n.s),t!==Ca?t:void 0}function lr(t,n,e){if(va(n))return n;var r=n[tn];if(!r)return jt(n,function(i,s){return bs(t,r,n,i,s,e)},!0),n;if(r.A!==t)return n;if(!r.P)return cr(t,r.t,!0),r.t;if(!r.I){r.I=!0,r.A._--;var a=r.i===4||r.i===5?r.o=ga(r.k):r.o;jt(r.i===3?new Set(a):a,function(i,s){return bs(t,r,a,i,s,e)}),cr(t,a,!1),e&&t.u&&tt("Patches").R(r,e,t.u,t.s)}return r.o}function bs(t,n,e,r,a,i){if(Tt(a)){var s=lr(t,a,i&&n&&n.i!==3&&!ge(n.D,r)?i.concat(r):void 0);if(ds(e,r,s),!Tt(s))return;t.m=!1}if(nt(a)&&!va(a)){if(!t.h.F&&t._<1)return;lr(t,a),n&&n.A.l||cr(t,a)}}function cr(t,n,e){e===void 0&&(e=!1),t.h.F&&t.m&&ba(n,e)}function Ea(t,n){var e=t[tn];return(e?kn(e):t)[n]}function vs(t,n){if(n in t)for(var e=Object.getPrototypeOf(t);e;){var r=Object.getOwnPropertyDescriptor(e,n);if(r)return r;e=Object.getPrototypeOf(e)}}function ut(t){t.P||(t.P=!0,t.l&&ut(t.l))}function ka(t){t.o||(t.o=ga(t.t))}function be(t,n,e){var r=ir(n)?tt("MapSet").N(n,e):sr(n)?tt("MapSet").T(n,e):t.g?function(a,i){var s=Array.isArray(a),o={i:s?1:0,A:i?i.A:or(),P:!1,I:!1,D:{},l:i,t:a,k:null,o:null,j:null,C:!1},_=o,l=Ia;s&&(_=[o],l=xe);var u=Proxy.revocable(_,l),f=u.revoke,m=u.proxy;return o.k=m,o.j=f,m}(n,e):tt("ES5").J(n,e);return(e?e.A:or()).p.push(r),r}function Sf(t){return Tt(t)||An(22,t),function n(e){if(!nt(e))return e;var r,a=e[tn],i=bt(e);if(a){if(!a.P&&(a.i<4||!tt("ES5").K(a)))return a.t;a.I=!0,r=ys(e,i),a.I=!1}else r=ys(e,i);return jt(r,function(s,o){a&&ar(a.t,s)===o||ds(r,s,n(o))}),i===3?new Set(r):r}(t)}function ys(t,n){switch(n){case 2:return new Map(t);case 3:return Array.from(t)}return ga(t)}function Af(){function t(r){if(!nt(r))return r;if(Array.isArray(r))return r.map(t);if(ir(r))return new Map(Array.from(r.entries()).map(function(s){return[s[0],t(s[1])]}));if(sr(r))return new Set(Array.from(r).map(t));var a=Object.create(Object.getPrototypeOf(r));for(var i in r)a[i]=t(r[i]);return ge(r,ye)&&(a[ye]=r[ye]),a}function n(r){return Tt(r)?t(r):r}var e="add";hs("Patches",{$:function(r,a){return a.forEach(function(i){for(var s=i.path,o=i.op,_=r,l=0;l<s.length-1;l++){var u=bt(_),f=""+s[l];u!==0&&u!==1||f!=="__proto__"&&f!=="constructor"||An(24),typeof _=="function"&&f==="prototype"&&An(24),typeof(_=ar(_,f))!="object"&&An(15,s.join("/"))}var m=bt(_),h=t(i.value),v=s[s.length-1];switch(o){case"replace":switch(m){case 2:return _.set(v,h);case 3:An(16);default:return _[v]=h}case e:switch(m){case 1:return v==="-"?_.push(h):_.splice(v,0,h);case 2:return _.set(v,h);case 3:return _.add(h);default:return _[v]=h}case"remove":switch(m){case 1:return _.splice(v,1);case 2:return _.delete(v);case 3:return _.delete(i.value);default:return delete _[v]}default:An(17,o)}}),r},R:function(r,a,i,s){switch(r.i){case 0:case 4:case 2:return function(o,_,l,u){var f=o.t,m=o.o;jt(o.D,function(h,v){var d=ar(f,h),g=ar(m,h),y=v?ge(f,h)?"replace":e:"remove";if(d!==g||y!=="replace"){var E=_.concat(h);l.push(y==="remove"?{op:y,path:E}:{op:y,path:E,value:g}),u.push(y===e?{op:"remove",path:E}:y==="remove"?{op:e,path:E,value:n(d)}:{op:"replace",path:E,value:n(d)})}})}(r,a,i,s);case 5:case 1:return function(o,_,l,u){var f=o.t,m=o.D,h=o.o;if(h.length<f.length){var v=[h,f];f=v[0],h=v[1];var d=[u,l];l=d[0],u=d[1]}for(var g=0;g<f.length;g++)if(m[g]&&h[g]!==f[g]){var y=_.concat([g]);l.push({op:"replace",path:y,value:n(h[g])}),u.push({op:"replace",path:y,value:n(f[g])})}for(var E=f.length;E<h.length;E++){var b=_.concat([E]);l.push({op:e,path:b,value:n(h[E])})}f.length<h.length&&u.push({op:"replace",path:_.concat(["length"]),value:f.length})}(r,a,i,s);case 3:return function(o,_,l,u){var f=o.t,m=o.o,h=0;f.forEach(function(v){if(!m.has(v)){var d=_.concat([h]);l.push({op:"remove",path:d,value:v}),u.unshift({op:e,path:d,value:v})}h++}),h=0,m.forEach(function(v){if(!f.has(v)){var d=_.concat([h]);l.push({op:e,path:d,value:v}),u.unshift({op:"remove",path:d,value:v})}h++})}(r,a,i,s)}},M:function(r,a,i,s){i.push({op:"replace",path:[],value:a===Ca?void 0:a}),s.push({op:"replace",path:[],value:r})}})}function If(){function t(o,_){function l(){this.constructor=o}a(o,_),o.prototype=(l.prototype=_.prototype,new l)}function n(o){o.o||(o.D=new Map,o.o=new Map(o.t))}function e(o){o.o||(o.o=new Set,o.t.forEach(function(_){if(nt(_)){var l=be(o.A.h,_,o);o.p.set(_,l),o.o.add(l)}else o.o.add(_)}))}function r(o){o.O&&An(3,JSON.stringify(kn(o)))}var a=function(o,_){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(l,u){l.__proto__=u}||function(l,u){for(var f in u)u.hasOwnProperty(f)&&(l[f]=u[f])})(o,_)},i=function(){function o(l,u){return this[tn]={i:2,l:u,A:u?u.A:or(),P:!1,I:!1,o:void 0,D:void 0,t:l,k:this,C:!1,O:!1},this}t(o,Map);var _=o.prototype;return Object.defineProperty(_,"size",{get:function(){return kn(this[tn]).size}}),_.has=function(l){return kn(this[tn]).has(l)},_.set=function(l,u){var f=this[tn];return r(f),kn(f).has(l)&&kn(f).get(l)===u||(n(f),ut(f),f.D.set(l,!0),f.o.set(l,u),f.D.set(l,!0)),this},_.delete=function(l){if(!this.has(l))return!1;var u=this[tn];return r(u),n(u),ut(u),u.t.has(l)?u.D.set(l,!1):u.D.delete(l),u.o.delete(l),!0},_.clear=function(){var l=this[tn];r(l),kn(l).size&&(n(l),ut(l),l.D=new Map,jt(l.t,function(u){l.D.set(u,!1)}),l.o.clear())},_.forEach=function(l,u){var f=this;kn(this[tn]).forEach(function(m,h){l.call(u,f.get(h),h,f)})},_.get=function(l){var u=this[tn];r(u);var f=kn(u).get(l);if(u.I||!nt(f)||f!==u.t.get(l))return f;var m=be(u.A.h,f,u);return n(u),u.o.set(l,m),m},_.keys=function(){return kn(this[tn]).keys()},_.values=function(){var l,u=this,f=this.keys();return(l={})[ur]=function(){return u.values()},l.next=function(){var m=f.next();return m.done?m:{done:!1,value:u.get(m.value)}},l},_.entries=function(){var l,u=this,f=this.keys();return(l={})[ur]=function(){return u.entries()},l.next=function(){var m=f.next();if(m.done)return m;var h=u.get(m.value);return{done:!1,value:[m.value,h]}},l},_[ur]=function(){return this.entries()},o}(),s=function(){function o(l,u){return this[tn]={i:3,l:u,A:u?u.A:or(),P:!1,I:!1,o:void 0,t:l,k:this,p:new Map,O:!1,C:!1},this}t(o,Set);var _=o.prototype;return Object.defineProperty(_,"size",{get:function(){return kn(this[tn]).size}}),_.has=function(l){var u=this[tn];return r(u),u.o?!!u.o.has(l)||!(!u.p.has(l)||!u.o.has(u.p.get(l))):u.t.has(l)},_.add=function(l){var u=this[tn];return r(u),this.has(l)||(e(u),ut(u),u.o.add(l)),this},_.delete=function(l){if(!this.has(l))return!1;var u=this[tn];return r(u),e(u),ut(u),u.o.delete(l)||!!u.p.has(l)&&u.o.delete(u.p.get(l))},_.clear=function(){var l=this[tn];r(l),kn(l).size&&(e(l),ut(l),l.o.clear())},_.values=function(){var l=this[tn];return r(l),e(l),l.o.values()},_.entries=function(){var l=this[tn];return r(l),e(l),l.o.entries()},_.keys=function(){return this.values()},_[ur]=function(){return this.values()},_.forEach=function(l,u){for(var f=this.values(),m=f.next();!m.done;)l.call(u,m.value,m.value,this),m=f.next()},o}();hs("MapSet",{N:function(o,_){return new i(o,_)},T:function(o,_){return new s(o,_)}})}var xs,ve,wa=typeof Symbol<"u"&&typeof Symbol("x")=="symbol",Nf=typeof Map<"u",Tf=typeof Set<"u",$s=typeof Proxy<"u"&&Proxy.revocable!==void 0&&typeof Reflect<"u",Ca=wa?Symbol.for("immer-nothing"):((xs={})["immer-nothing"]=!0,xs),ye=wa?Symbol.for("immer-draftable"):"__$immer_draftable",tn=wa?Symbol.for("immer-state"):"__$immer_state",ur=typeof Symbol<"u"&&Symbol.iterator||"@@iterator",jf=""+Object.prototype.constructor,Sa=typeof Reflect<"u"&&Reflect.ownKeys?Reflect.ownKeys:Object.getOwnPropertySymbols!==void 0?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Lf=Object.getOwnPropertyDescriptors||function(t){var n={};return Sa(t).forEach(function(e){n[e]=Object.getOwnPropertyDescriptor(t,e)}),n},Aa={},Ia={get:function(t,n){if(n===tn)return t;var e=kn(t);if(!ge(e,n))return function(a,i,s){var o,_=vs(i,s);return _?"value"in _?_.value:(o=_.get)===null||o===void 0?void 0:o.call(a.k):void 0}(t,e,n);var r=e[n];return t.I||!nt(r)?r:r===Ea(t.t,n)?(ka(t),t.o[n]=be(t.A.h,r,t)):r},has:function(t,n){return n in kn(t)},ownKeys:function(t){return Reflect.ownKeys(kn(t))},set:function(t,n,e){var r=vs(kn(t),n);if(r!=null&&r.set)return r.set.call(t.k,e),!0;if(!t.P){var a=Ea(kn(t),n),i=a==null?void 0:a[tn];if(i&&i.t===e)return t.o[n]=e,t.D[n]=!1,!0;if(kf(e,a)&&(e!==void 0||ge(t.t,n)))return!0;ka(t),ut(t)}return t.o[n]===e&&typeof e!="number"&&(e!==void 0||n in t.o)||(t.o[n]=e,t.D[n]=!0,!0)},deleteProperty:function(t,n){return Ea(t.t,n)!==void 0||n in t.t?(t.D[n]=!1,ka(t),ut(t)):delete t.D[n],t.o&&delete t.o[n],!0},getOwnPropertyDescriptor:function(t,n){var e=kn(t),r=Reflect.getOwnPropertyDescriptor(e,n);return r&&{writable:!0,configurable:t.i!==1||n!=="length",enumerable:r.enumerable,value:e[n]}},defineProperty:function(){An(11)},getPrototypeOf:function(t){return Object.getPrototypeOf(t.t)},setPrototypeOf:function(){An(12)}},xe={};jt(Ia,function(t,n){xe[t]=function(){return arguments[0]=arguments[0][0],n.apply(this,arguments)}}),xe.deleteProperty=function(t,n){return xe.set.call(this,t,n,void 0)},xe.set=function(t,n,e){return Ia.set.call(this,t[0],n,e,t[0])};var Mf=function(){function t(e){var r=this;this.g=$s,this.F=!0,this.produce=function(a,i,s){if(typeof a=="function"&&typeof i!="function"){var o=i;i=a;var _=r;return function(d){var g=this;d===void 0&&(d=o);for(var y=arguments.length,E=Array(y>1?y-1:0),b=1;b<y;b++)E[b-1]=arguments[b];return _.produce(d,function(x){var $;return($=i).call.apply($,[g,x].concat(E))})}}var l;if(typeof i!="function"&&An(6),s!==void 0&&typeof s!="function"&&An(7),nt(a)){var u=gs(r),f=be(r,a,void 0),m=!0;try{l=i(f),m=!1}finally{m?_r(u):xa(u)}return typeof Promise<"u"&&l instanceof Promise?l.then(function(d){return ya(u,s),$a(d,u)},function(d){throw _r(u),d}):(ya(u,s),$a(l,u))}if(!a||typeof a!="object"){if((l=i(a))===void 0&&(l=a),l===Ca&&(l=void 0),r.F&&ba(l,!0),s){var h=[],v=[];tt("Patches").M(a,l,h,v),s(h,v)}return l}An(21,a)},this.produceWithPatches=function(a,i){if(typeof a=="function")return function(l){for(var u=arguments.length,f=Array(u>1?u-1:0),m=1;m<u;m++)f[m-1]=arguments[m];return r.produceWithPatches(l,function(h){return a.apply(void 0,[h].concat(f))})};var s,o,_=r.produce(a,i,function(l,u){s=l,o=u});return typeof Promise<"u"&&_ instanceof Promise?_.then(function(l){return[l,s,o]}):[_,s,o]},typeof(e==null?void 0:e.useProxies)=="boolean"&&this.setUseProxies(e.useProxies),typeof(e==null?void 0:e.autoFreeze)=="boolean"&&this.setAutoFreeze(e.autoFreeze)}var n=t.prototype;return n.createDraft=function(e){nt(e)||An(8),Tt(e)&&(e=Sf(e));var r=gs(this),a=be(this,e,void 0);return a[tn].C=!0,xa(r),a},n.finishDraft=function(e,r){var a=e&&e[tn],i=a.A;return ya(i,r),$a(void 0,i)},n.setAutoFreeze=function(e){this.F=e},n.setUseProxies=function(e){e&&!$s&&An(20),this.g=e},n.applyPatches=function(e,r){var a;for(a=r.length-1;a>=0;a--){var i=r[a];if(i.path.length===0&&i.op==="replace"){e=i.value;break}}a>-1&&(r=r.slice(a+1));var s=tt("Patches").$;return Tt(e)?s(e,r):this.produce(e,function(o){return s(o,r)})},t}(),On=new Mf,Df=On.produce;On.produceWithPatches.bind(On),On.setAutoFreeze.bind(On),On.setUseProxies.bind(On),On.applyPatches.bind(On),On.createDraft.bind(On),On.finishDraft.bind(On),Af(),If();function Pf(t,n,e=()=>({})){const r=new Map;function a(o,_){postMessage({__uwrType:"patch",id:o,patches:_})}function i(){let o,_=null;return new WritableStream({async write(l,u){switch(l.__uwrType){case"init":{const{id:f,initialState:m}=l;_=m,o=e(_),a(f,[])}break;case"dispatch":{const{id:f,action:m}=l;_=await Df(_,async h=>{await n(h,m,o)},h=>a(f,h))}break;case"destroy":{const{name:f}=l;r.delete(f),u.error()}break}}})}function s(o){if(typeof o.data!="object"||!("__uwrType"in o.data))return;const _=o.data;if(_.__uwrType==="init"){const{name:m}=_,[h,v]=JSON.parse(m);if(v!==t||r.has(m))return;const d=i();r.set(m,d)}const{name:l}=_,u=r.get(l);if(!u)return;const f=u.getWriter();f.write(_),f.releaseLock()}addEventListener("message",s)}/*
    @license
  	Rollup.js v3.25.1
  	Mon, 12 Jun 2023 04:38:12 GMT - commit b1341bf9cd719670a670905e0308418b37621d70

  	https://github.com/rollup/rollup

  	Released under the MIT License.
  */var Na="3.25.1";function Es(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var ks={exports:{}};(function(t){const n=",".charCodeAt(0),e=";".charCodeAt(0),r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=new Uint8Array(64),i=new Uint8Array(128);for(let d=0;d<r.length;d++){const g=r.charCodeAt(d);a[d]=g,i[g]=d}const s=typeof TextDecoder<"u"?new TextDecoder:typeof Buffer<"u"?{decode:d=>Buffer.from(d.buffer,d.byteOffset,d.byteLength).toString()}:{decode(d){let g="";for(let y=0;y<d.length;y++)g+=String.fromCharCode(d[y]);return g}};function o(d){const g=new Int32Array(5),y=[];let E=0;do{const b=_(d,E),x=[];let $=!0,S=0;g[0]=0;for(let A=E;A<b;A++){let N;A=l(d,A,g,0);const k=g[0];k<S&&($=!1),S=k,u(d,A,b)?(A=l(d,A,g,1),A=l(d,A,g,2),A=l(d,A,g,3),u(d,A,b)?(A=l(d,A,g,4),N=[k,g[1],g[2],g[3],g[4]]):N=[k,g[1],g[2],g[3]]):N=[k],x.push(N)}$||f(x),y.push(x),E=b+1}while(E<=d.length);return y}function _(d,g){const y=d.indexOf(";",g);return y===-1?d.length:y}function l(d,g,y,E){let b=0,x=0,$=0;do{const A=d.charCodeAt(g++);$=i[A],b|=(31&$)<<x,x+=5}while(32&$);const S=1&b;return b>>>=1,S&&(b=-2147483648|-b),y[E]+=b,g}function u(d,g,y){return!(g>=y)&&d.charCodeAt(g)!==n}function f(d){d.sort(m)}function m(d,g){return d[0]-g[0]}function h(d){const g=new Int32Array(5),y=16384,E=y-36,b=new Uint8Array(y),x=b.subarray(0,E);let $=0,S="";for(let A=0;A<d.length;A++){const N=d[A];if(A>0&&($===y&&(S+=s.decode(b),$=0),b[$++]=e),N.length!==0){g[0]=0;for(let k=0;k<N.length;k++){const I=N[k];$>E&&(S+=s.decode(x),b.copyWithin(0,E,$),$-=E),k>0&&(b[$++]=n),$=v(b,$,g,I,0),I.length!==1&&($=v(b,$,g,I,1),$=v(b,$,g,I,2),$=v(b,$,g,I,3),I.length!==4&&($=v(b,$,g,I,4)))}}}return S+s.decode(b.subarray(0,$))}function v(d,g,y,E,b){const x=E[b];let $=x-y[b];y[b]=x,$=$<0?-$<<1|1:$<<1;do{let S=31&$;$>>>=5,$>0&&(S|=32),d[g++]=a[S]}while($>0);return g}t.decode=o,t.encode=h,Object.defineProperty(t,"__esModule",{value:!0})})(ks.exports);var ws=ks.exports;class fr{constructor(n){this.bits=n instanceof fr?n.bits.slice():[]}add(n){this.bits[n>>5]|=1<<(31&n)}has(n){return!!(this.bits[n>>5]&1<<(31&n))}}let Cs=class ps{constructor(n,e,r){this.start=n,this.end=e,this.original=r,this.intro="",this.outro="",this.content=r,this.storeName=!1,this.edited=!1,this.previous=null,this.next=null}appendLeft(n){this.outro+=n}appendRight(n){this.intro=this.intro+n}clone(){const n=new ps(this.start,this.end,this.original);return n.intro=this.intro,n.outro=this.outro,n.content=this.content,n.storeName=this.storeName,n.edited=this.edited,n}contains(n){return this.start<n&&n<this.end}eachNext(n){let e=this;for(;e;)n(e),e=e.next}eachPrevious(n){let e=this;for(;e;)n(e),e=e.previous}edit(n,e,r){return this.content=n,r||(this.intro="",this.outro=""),this.storeName=e,this.edited=!0,this}prependLeft(n){this.outro=n+this.outro}prependRight(n){this.intro=n+this.intro}split(n){const e=n-this.start,r=this.original.slice(0,e),a=this.original.slice(e);this.original=r;const i=new ps(n,this.end,a);return i.outro=this.outro,this.outro="",this.end=n,this.edited?(i.edit("",!1),this.content=""):this.content=r,i.next=this.next,i.next&&(i.next.previous=i),i.previous=this,this.next=i,i}toString(){return this.intro+this.content+this.outro}trimEnd(n){if(this.outro=this.outro.replace(n,""),this.outro.length)return!0;const e=this.content.replace(n,"");return e.length?(e!==this.content&&this.split(this.start+e.length).edit("",void 0,!0),!0):(this.edit("",void 0,!0),this.intro=this.intro.replace(n,""),!!this.intro.length||void 0)}trimStart(n){if(this.intro=this.intro.replace(n,""),this.intro.length)return!0;const e=this.content.replace(n,"");return e.length?(e!==this.content&&(this.split(this.end-e.length),this.edit("",void 0,!0)),!0):(this.edit("",void 0,!0),this.outro=this.outro.replace(n,""),!!this.outro.length||void 0)}};function Of(){return typeof window<"u"&&typeof window.btoa=="function"?t=>window.btoa(unescape(encodeURIComponent(t))):typeof Buffer=="function"?t=>Buffer.from(t,"utf-8").toString("base64"):()=>{throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")}}const zf=Of();class mr{constructor(n){this.version=3,this.file=n.file,this.sources=n.sources,this.sourcesContent=n.sourcesContent,this.names=n.names,this.mappings=ws.encode(n.mappings),n.x_google_ignoreList!==void 0&&(this.x_google_ignoreList=n.x_google_ignoreList)}toString(){return JSON.stringify(this)}toUrl(){return"data:application/json;charset=utf-8;base64,"+zf(this.toString())}}function Ss(t,n){const e=t.split(/[/\\]/),r=n.split(/[/\\]/);for(e.pop();e[0]===r[0];)e.shift(),r.shift();if(e.length){let a=e.length;for(;a--;)e[a]=".."}return e.concat(r).join("/")}const Ff=Object.prototype.toString;function As(t){return Ff.call(t)==="[object Object]"}function Ta(t){const n=t.split(`
`),e=[];for(let r=0,a=0;r<n.length;r++)e.push(a),a+=n[r].length+1;return function(r){let a=0,i=e.length;for(;a<i;){const o=a+i>>1;r<e[o]?i=o:a=o+1}const s=a-1;return{line:s,column:r-e[s]}}}class Is{constructor(n){this.hires=n,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null}addEdit(n,e,r,a){if(e.length){const i=[this.generatedCodeColumn,n,r.line,r.column];a>=0&&i.push(a),this.rawSegments.push(i)}else this.pending&&this.rawSegments.push(this.pending);this.advance(e),this.pending=null}addUneditedChunk(n,e,r,a,i){let s=e.start,o=!0;for(;s<e.end;)(this.hires||o||i.has(s))&&this.rawSegments.push([this.generatedCodeColumn,n,a.line,a.column]),r[s]===`
`?(a.line+=1,a.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,o=!0):(a.column+=1,this.generatedCodeColumn+=1,o=!1),s+=1;this.pending=null}advance(n){if(!n)return;const e=n.split(`
`);if(e.length>1){for(let r=0;r<e.length-1;r++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=e[e.length-1].length}}const $e=`
`,Zt={insertLeft:!1,insertRight:!1,storeName:!1};class Lt{constructor(n,e={}){const r=new Cs(0,n.length,n);Object.defineProperties(this,{original:{writable:!0,value:n},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:r},lastChunk:{writable:!0,value:r},lastSearchedChunk:{writable:!0,value:r},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:e.filename},indentExclusionRanges:{writable:!0,value:e.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new fr},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:void 0},ignoreList:{writable:!0,value:e.ignoreList}}),this.byStart[0]=r,this.byEnd[n.length]=r}addSourcemapLocation(n){this.sourcemapLocations.add(n)}append(n){if(typeof n!="string")throw new TypeError("outro content must be a string");return this.outro+=n,this}appendLeft(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byEnd[n];return r?r.appendLeft(e):this.intro+=e,this}appendRight(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byStart[n];return r?r.appendRight(e):this.outro+=e,this}clone(){const n=new Lt(this.original,{filename:this.filename});let e=this.firstChunk,r=n.firstChunk=n.lastSearchedChunk=e.clone();for(;e;){n.byStart[r.start]=r,n.byEnd[r.end]=r;const a=e.next,i=a&&a.clone();i&&(r.next=i,i.previous=r,r=i),e=a}return n.lastChunk=r,this.indentExclusionRanges&&(n.indentExclusionRanges=this.indentExclusionRanges.slice()),n.sourcemapLocations=new fr(this.sourcemapLocations),n.intro=this.intro,n.outro=this.outro,n}generateDecodedMap(n){n=n||{};const e=Object.keys(this.storedNames),r=new Is(n.hires),a=Ta(this.original);return this.intro&&r.advance(this.intro),this.firstChunk.eachNext(i=>{const s=a(i.start);i.intro.length&&r.advance(i.intro),i.edited?r.addEdit(0,i.content,s,i.storeName?e.indexOf(i.original):-1):r.addUneditedChunk(0,i,this.original,s,this.sourcemapLocations),i.outro.length&&r.advance(i.outro)}),{file:n.file?n.file.split(/[/\\]/).pop():void 0,sources:[n.source?Ss(n.file||"",n.source):n.file||""],sourcesContent:n.includeContent?[this.original]:void 0,names:e,mappings:r.raw,x_google_ignoreList:this.ignoreList?[0]:void 0}}generateMap(n){return new mr(this.generateDecodedMap(n))}_ensureindentStr(){this.indentStr===void 0&&(this.indentStr=function(n){const e=n.split(`
`),r=e.filter(s=>/^\t+/.test(s)),a=e.filter(s=>/^ {2,}/.test(s));if(r.length===0&&a.length===0)return null;if(r.length>=a.length)return"	";const i=a.reduce((s,o)=>{const _=/^ +/.exec(o)[0].length;return Math.min(_,s)},1/0);return new Array(i+1).join(" ")}(this.original))}_getRawIndentString(){return this._ensureindentStr(),this.indentStr}getIndentString(){return this._ensureindentStr(),this.indentStr===null?"	":this.indentStr}indent(n,e){const r=/^[^\r\n]/gm;if(As(n)&&(e=n,n=void 0),n===void 0&&(this._ensureindentStr(),n=this.indentStr||"	"),n==="")return this;const a={};(e=e||{}).exclude&&(typeof e.exclude[0]=="number"?[e.exclude]:e.exclude).forEach(l=>{for(let u=l[0];u<l[1];u+=1)a[u]=!0});let i=e.indentStart!==!1;const s=l=>i?`${n}${l}`:(i=!0,l);this.intro=this.intro.replace(r,s);let o=0,_=this.firstChunk;for(;_;){const l=_.end;if(_.edited)a[o]||(_.content=_.content.replace(r,s),_.content.length&&(i=_.content[_.content.length-1]===`
`));else for(o=_.start;o<l;){if(!a[o]){const u=this.original[o];u===`
`?i=!0:u!=="\r"&&i&&(i=!1,o===_.start||(this._splitChunk(_,o),_=_.next),_.prependRight(n))}o+=1}o=_.end,_=_.next}return this.outro=this.outro.replace(r,s),this}insert(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")}insertLeft(n,e){return Zt.insertLeft||(console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),Zt.insertLeft=!0),this.appendLeft(n,e)}insertRight(n,e){return Zt.insertRight||(console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),Zt.insertRight=!0),this.prependRight(n,e)}move(n,e,r){if(r>=n&&r<=e)throw new Error("Cannot move a selection inside itself");this._split(n),this._split(e),this._split(r);const a=this.byStart[n],i=this.byEnd[e],s=a.previous,o=i.next,_=this.byStart[r];if(!_&&i===this.lastChunk)return this;const l=_?_.previous:this.lastChunk;return s&&(s.next=o),o&&(o.previous=s),l&&(l.next=a),_&&(_.previous=i),a.previous||(this.firstChunk=i.next),i.next||(this.lastChunk=a.previous,this.lastChunk.next=null),a.previous=l,i.next=_||null,l||(this.firstChunk=a),_||(this.lastChunk=i),this}overwrite(n,e,r,a){return a=a||{},this.update(n,e,r,{...a,overwrite:!a.contentOnly})}update(n,e,r,a){if(typeof r!="string")throw new TypeError("replacement content must be a string");for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;if(e>this.original.length)throw new Error("end is out of bounds");if(n===e)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");this._split(n),this._split(e),a===!0&&(Zt.storeName||(console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),Zt.storeName=!0),a={storeName:!0});const i=a!==void 0&&a.storeName,s=a!==void 0&&a.overwrite;if(i){const l=this.original.slice(n,e);Object.defineProperty(this.storedNames,l,{writable:!0,value:!0,enumerable:!0})}const o=this.byStart[n],_=this.byEnd[e];if(o){let l=o;for(;l!==_;){if(l.next!==this.byStart[l.end])throw new Error("Cannot overwrite across a split point");l=l.next,l.edit("",!1)}o.edit(r,i,!s)}else{const l=new Cs(n,e,"").edit(r,i);_.next=l,l.previous=_}return this}prepend(n){if(typeof n!="string")throw new TypeError("outro content must be a string");return this.intro=n+this.intro,this}prependLeft(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byEnd[n];return r?r.prependLeft(e):this.intro=e+this.intro,this}prependRight(n,e){if(typeof e!="string")throw new TypeError("inserted content must be a string");this._split(n);const r=this.byStart[n];return r?r.prependRight(e):this.outro=e+this.outro,this}remove(n,e){for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;if(n===e)return this;if(n<0||e>this.original.length)throw new Error("Character is out of bounds");if(n>e)throw new Error("end must be greater than start");this._split(n),this._split(e);let r=this.byStart[n];for(;r;)r.intro="",r.outro="",r.edit(""),r=e>r.end?this.byStart[r.end]:null;return this}lastChar(){if(this.outro.length)return this.outro[this.outro.length-1];let n=this.lastChunk;do{if(n.outro.length)return n.outro[n.outro.length-1];if(n.content.length)return n.content[n.content.length-1];if(n.intro.length)return n.intro[n.intro.length-1]}while(n=n.previous);return this.intro.length?this.intro[this.intro.length-1]:""}lastLine(){let n=this.outro.lastIndexOf($e);if(n!==-1)return this.outro.substr(n+1);let e=this.outro,r=this.lastChunk;do{if(r.outro.length>0){if(n=r.outro.lastIndexOf($e),n!==-1)return r.outro.substr(n+1)+e;e=r.outro+e}if(r.content.length>0){if(n=r.content.lastIndexOf($e),n!==-1)return r.content.substr(n+1)+e;e=r.content+e}if(r.intro.length>0){if(n=r.intro.lastIndexOf($e),n!==-1)return r.intro.substr(n+1)+e;e=r.intro+e}}while(r=r.previous);return n=this.intro.lastIndexOf($e),n!==-1?this.intro.substr(n+1)+e:this.intro+e}slice(n=0,e=this.original.length){for(;n<0;)n+=this.original.length;for(;e<0;)e+=this.original.length;let r="",a=this.firstChunk;for(;a&&(a.start>n||a.end<=n);){if(a.start<e&&a.end>=e)return r;a=a.next}if(a&&a.edited&&a.start!==n)throw new Error(`Cannot use replaced character ${n} as slice start anchor.`);const i=a;for(;a;){!a.intro||i===a&&a.start!==n||(r+=a.intro);const s=a.start<e&&a.end>=e;if(s&&a.edited&&a.end!==e)throw new Error(`Cannot use replaced character ${e} as slice end anchor.`);const o=i===a?n-a.start:0,_=s?a.content.length+e-a.end:a.content.length;if(r+=a.content.slice(o,_),!a.outro||s&&a.end!==e||(r+=a.outro),s)break;a=a.next}return r}snip(n,e){const r=this.clone();return r.remove(0,n),r.remove(e,r.original.length),r}_split(n){if(this.byStart[n]||this.byEnd[n])return;let e=this.lastSearchedChunk;const r=n>e.end;for(;e;){if(e.contains(n))return this._splitChunk(e,n);e=r?this.byStart[e.end]:this.byEnd[e.start]}}_splitChunk(n,e){if(n.edited&&n.content.length){const a=Ta(this.original)(e);throw new Error(`Cannot split a chunk that has already been edited (${a.line}:${a.column} – "${n.original}")`)}const r=n.split(e);return this.byEnd[e]=n,this.byStart[e]=r,this.byEnd[r.end]=r,n===this.lastChunk&&(this.lastChunk=r),this.lastSearchedChunk=n,!0}toString(){let n=this.intro,e=this.firstChunk;for(;e;)n+=e.toString(),e=e.next;return n+this.outro}isEmpty(){let n=this.firstChunk;do if(n.intro.length&&n.intro.trim()||n.content.length&&n.content.trim()||n.outro.length&&n.outro.trim())return!1;while(n=n.next);return!0}length(){let n=this.firstChunk,e=0;do e+=n.intro.length+n.content.length+n.outro.length;while(n=n.next);return e}trimLines(){return this.trim("[\\r\\n]")}trim(n){return this.trimStart(n).trimEnd(n)}trimEndAborted(n){const e=new RegExp((n||"\\s")+"+$");if(this.outro=this.outro.replace(e,""),this.outro.length)return!0;let r=this.lastChunk;do{const a=r.end,i=r.trimEnd(e);if(r.end!==a&&(this.lastChunk===r&&(this.lastChunk=r.next),this.byEnd[r.end]=r,this.byStart[r.next.start]=r.next,this.byEnd[r.next.end]=r.next),i)return!0;r=r.previous}while(r);return!1}trimEnd(n){return this.trimEndAborted(n),this}trimStartAborted(n){const e=new RegExp("^"+(n||"\\s")+"+");if(this.intro=this.intro.replace(e,""),this.intro.length)return!0;let r=this.firstChunk;do{const a=r.end,i=r.trimStart(e);if(r.end!==a&&(r===this.lastChunk&&(this.lastChunk=r.next),this.byEnd[r.end]=r,this.byStart[r.next.start]=r.next,this.byEnd[r.next.end]=r.next),i)return!0;r=r.next}while(r);return!1}trimStart(n){return this.trimStartAborted(n),this}hasChanged(){return this.original!==this.toString()}_replaceRegexp(n,e){function r(a,i){return typeof e=="string"?e.replace(/\$(\$|&|\d+)/g,(s,o)=>o==="$"?"$":o==="&"?a[0]:+o<a.length?a[+o]:`$${o}`):e(...a,a.index,i,a.groups)}if(n.global)(function(a,i){let s;const o=[];for(;s=a.exec(i);)o.push(s);return o})(n,this.original).forEach(a=>{a.index!=null&&this.overwrite(a.index,a.index+a[0].length,r(a,this.original))});else{const a=this.original.match(n);a&&a.index!=null&&this.overwrite(a.index,a.index+a[0].length,r(a,this.original))}return this}_replaceString(n,e){const{original:r}=this,a=r.indexOf(n);return a!==-1&&this.overwrite(a,a+n.length,e),this}replace(n,e){return typeof n=="string"?this._replaceString(n,e):this._replaceRegexp(n,e)}_replaceAllString(n,e){const{original:r}=this,a=n.length;for(let i=r.indexOf(n);i!==-1;i=r.indexOf(n,i+a))this.overwrite(i,i+a,e);return this}replaceAll(n,e){if(typeof n=="string")return this._replaceAllString(n,e);if(!n.global)throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");return this._replaceRegexp(n,e)}}const Ns=Object.prototype.hasOwnProperty,Bf=/^(?:\/|(?:[A-Za-z]:)?[/\\|])/,Gf=/^\.?\.\//,Rf=/\\/g,Qt=/[/\\]/,qf=/\.[^.]+$/;function vt(t){return Bf.test(t)}function ja(t){return Gf.test(t)}function Ee(t){return t.replace(Rf,"/")}function ft(t){return t.split(Qt).pop()||""}function Mt(t){const n=/[/\\][^/\\]*$/.exec(t);return n?t.slice(0,-n[0].length)||"/":"."}function yt(t){const n=qf.exec(ft(t));return n?n[0]:""}function ne(t,n){const e=t.split(Qt).filter(Boolean),r=n.split(Qt).filter(Boolean);for(e[0]==="."&&e.shift(),r[0]==="."&&r.shift();e[0]&&r[0]&&e[0]===r[0];)e.shift(),r.shift();for(;r[0]===".."&&e.length>0;)r.shift(),e.pop();for(;e.pop();)r.unshift("..");return r.join("/")}function Jn(...t){const n=t.shift();if(!n)return"/";let e=n.split(Qt);for(const r of t)if(vt(r))e=r.split(Qt);else{const a=r.split(Qt);for(;a[0]==="."||a[0]==="..";)a.shift()===".."&&e.pop();e.push(...a)}return e.join("/")}const Vf=/[\n\r'\\\u2028\u2029]/,Xf=/([\n\r'\u2028\u2029])/g,Uf=/\\/g;function pr(t){return Vf.test(t)?t.replace(Uf,"\\\\").replace(Xf,"\\$1"):t}function La(t){const n=ft(t);return n.slice(0,Math.max(0,n.length-yt(t).length))}function H(t){return vt(t)?ne(Jn(),t):t}function dr(t){return t[0]==="/"||t[0]==="."&&(t[1]==="/"||t[1]===".")||vt(t)}const Hf=/^(\.\.\/)*\.\.$/;function Ts(t,n,e,r){let a=Ee(ne(Mt(t),n));if(e&&a.endsWith(".js")&&(a=a.slice(0,-3)),r){if(a==="")return"../"+ft(n);if(Hf.test(a))return[...a.split("/"),"..",ft(n)].join("/")}return a?a.startsWith("..")?a:"./"+a:"."}class te{constructor(n,e,r){this.options=e,this.inputBase=r,this.defaultVariableName="",this.namespaceVariableName="",this.variableName="",this.fileName=null,this.importAssertions=null,this.id=n.id,this.moduleInfo=n.info,this.renormalizeRenderPath=n.renormalizeRenderPath,this.suggestedVariableName=n.suggestedVariableName}getFileName(){if(this.fileName)return this.fileName;const{paths:n}=this.options;return this.fileName=(typeof n=="function"?n(this.id):n[this.id])||(this.renormalizeRenderPath?Ee(ne(this.inputBase,this.id)):this.id)}getImportAssertions(n){return this.importAssertions||(this.importAssertions=function(e,{getObject:r}){if(!e)return null;const a=Object.entries(e).map(([i,s])=>[i,`'${s}'`]);return a.length>0?r(a,{lineBreakIndent:null}):null}(this.options.format==="es"&&this.options.externalImportAssertions&&this.moduleInfo.assertions,n))}getImportPath(n){return pr(this.renormalizeRenderPath?Ts(n,this.getFileName(),this.options.format==="amd",!1):this.getFileName())}}function zn(t,n,e){const r=t.get(n);if(r!==void 0)return r;const a=e();return t.set(n,a),a}function Dt(){return new Set}function js(){return[]}const on=Symbol("Unknown Key"),hr=Symbol("Unknown Non-Accessor Key"),ke=Symbol("Unknown Integer"),Ma=Symbol("Symbol.toStringTag"),X=[],nn=[on],Wf=[hr],Da=[ke],ee=Symbol("Entities");class re{constructor(){this.entityPaths=Object.create(null,{[ee]:{value:new Set}})}trackEntityAtPathAndGetIfTracked(n,e){const r=this.getEntities(n);return!!r.has(e)||(r.add(e),!1)}withTrackedEntityAtPath(n,e,r,a){const i=this.getEntities(n);if(i.has(e))return a;i.add(e);const s=r();return i.delete(e),s}getEntities(n){let e=this.entityPaths;for(const r of n)e=e[r]=e[r]||Object.create(null,{[ee]:{value:new Set}});return e[ee]}}const xn=new re;class Ls{constructor(){this.entityPaths=Object.create(null,{[ee]:{value:new Map}})}trackEntityAtPathAndGetIfTracked(n,e,r){let a=this.entityPaths;for(const s of n)a=a[s]=a[s]||Object.create(null,{[ee]:{value:new Map}});const i=zn(a[ee],e,Dt);return!!i.has(r)||(i.add(r),!1)}}const mn=Symbol("Unknown Value"),Ms=Symbol("Unknown Truthy Value");class qn{constructor(){this.included=!1}deoptimizeArgumentsOnInteractionAtPath(n,e,r){xt(n)}deoptimizePath(n){}getLiteralValueAtPath(n,e,r){return mn}getReturnExpressionWhenCalledAtPath(n,e,r,a){return gn}hasEffectsOnInteractionAtPath(n,e,r){return!0}include(n,e,r){this.included=!0}includeCallArguments(n,e){for(const r of e)r.include(n,!1)}shouldBeIncluded(n){return!0}}const U=new class extends qn{},gn=[U,!1],xt=t=>{for(const n of t.args)n==null||n.deoptimizePath(nn)},Pa={args:[null],type:0},Oa={args:[null,U],type:1},gr={args:[null],type:2,withNew:!1};class Pt extends qn{constructor(n){super(),this.name=n,this.alwaysRendered=!1,this.forbiddenNames=null,this.initReached=!1,this.isId=!1,this.isReassigned=!1,this.kind=null,this.renderBaseName=null,this.renderName=null}addReference(n){}forbidName(n){(this.forbiddenNames||(this.forbiddenNames=new Set)).add(n)}getBaseVariableName(){return this.renderBaseName||this.renderName||this.name}getName(n,e){if(e!=null&&e(this))return this.name;const r=this.renderName||this.name;return this.renderBaseName?`${this.renderBaseName}${n(r)}`:r}hasEffectsOnInteractionAtPath(n,{type:e},r){return e!==0||n.length>0}include(){this.included=!0}markCalledFromTryStatement(){}setRenderNames(n,e){this.renderBaseName=n,this.renderName=e}}class br extends Pt{constructor(n,e){super(e),this.referenced=!1,this.module=n,this.isNamespace=e==="*"}addReference(n){this.referenced=!0,this.name!=="default"&&this.name!=="*"||this.module.suggestName(n.name)}hasEffectsOnInteractionAtPath(n,{type:e}){return e!==0||n.length>(this.isNamespace?1:0)}include(){this.included||(this.included=!0,this.module.used=!0)}}const In=Object.freeze(Object.create(null)),Fn=Object.freeze({}),bn=Object.freeze([]),Ds=Object.freeze(new class extends Set{add(){throw new Error("Cannot add to empty set")}});var vr=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","eval","export","extends","false","finally","for","function","if","implements","import","in","instanceof","interface","let","NaN","new","null","package","private","protected","public","return","static","super","switch","this","throw","true","try","typeof","undefined","var","void","while","with","yield"]);const Ps=/[^\w$]/g,Os=t=>(n=>/\d/.test(n[0]))(t)||vr.has(t)||t==="arguments";function za(t){return t=t.replace(/-(\w)/g,(n,e)=>e.toUpperCase()).replace(Ps,"_"),Os(t)&&(t=`_${t}`),t||"_"}const V="warn",Ot="info",we="debug",zt={[we]:0,[Ot]:1,silent:3,[V]:2};function Fa(t,n,e){if(typeof e=="number")throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");return function(r,a){a===void 0&&(a={});var i=a.offsetLine||0,s=a.offsetColumn||0,o=r.split(`
`),_=0,l=o.map(function(h,v){var d=_+h.length+1,g={start:_,end:d,line:v};return _=d,g}),u=0;function f(h,v){return h.start<=v&&v<h.end}function m(h,v){return{line:i+h.line,column:s+v-h.start,character:v}}return function(h,v){typeof h=="string"&&(h=r.indexOf(h,v||0));for(var d=l[u],g=h>=d.end?1:-1;d;){if(f(d,h))return m(d,h);d=l[u+=g]}}}(t,e)(n,e&&e.startIndex)}function Ba(t){return t.replace(/^\t+/,n=>n.split("	").join("  "))}const Jf=120,Kf=10,Ga="...";function zs(t,n,e){let r=t.split(`
`);if(n>r.length)return"";const a=Math.max(Ba(r[n-1].slice(0,e)).length+Kf+Ga.length,Jf),i=Math.max(0,n-3);let s=Math.min(n+2,r.length);for(r=r.slice(i,s);!/\S/.test(r[r.length-1]);)r.pop(),s-=1;const o=String(s).length;return r.map((_,l)=>{const u=i+l+1===n;let f=String(l+i+1);for(;f.length<o;)f=` ${f}`;let m=Ba(_);if(m.length>a&&(m=`${m.slice(0,a-Ga.length)}${Ga}`),u){const h=function(v){let d="";for(;v--;)d+=" ";return d}(o+2+Ba(_.slice(0,e)).length)+"^";return`${f}: ${m}
${h}`}return`${f}: ${m}`}).join(`
`)}function mt(t,n){const e=t.length<=1,r=t.map(i=>`"${i}"`);let a=e?r[0]:`${r.slice(0,-1).join(", ")} and ${r.slice(-1)[0]}`;return n&&(a+=` ${e?n[0]:n[1]}`),a}function wn(t){return`https://rollupjs.org/${t}`}const Yf="troubleshooting/#error-name-is-not-exported-by-module",Zf="troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect",Fs="configuration-options/#output-amd-id",Ce="configuration-options/#output-dir",Ra="configuration-options/#output-exports",Qf="configuration-options/#output-extend",Bs="configuration-options/#output-format",nm="configuration-options/#output-experimentaldeepdynamicchunkoptimization",tm="configuration-options/#output-globals",qa="configuration-options/#output-inlinedynamicimports",Va="configuration-options/#output-interop",Xa="configuration-options/#output-manualchunks",Gs="configuration-options/#output-name",em="configuration-options/#output-sourcemapfile",Rs="plugin-development/#this-getmoduleinfo";function L(t){throw t instanceof Error||(t=Object.assign(new Error(t.message),t),Object.defineProperty(t,"name",{value:"RollupError"})),t}function yr(t,n,e,r){if(typeof n=="object"){const{line:a,column:i}=n;t.loc={column:i,file:r,line:a}}else{t.pos=n;const{line:a,column:i}=Fa(e,n,{offsetLine:1});t.loc={column:i,file:r,line:a}}if(t.frame===void 0){const{line:a,column:i}=t.loc;t.frame=zs(e,a,i)}}const rm="ADDON_ERROR",am="ALREADY_CLOSED",im="ANONYMOUS_PLUGIN_CACHE",sm="ASSET_NOT_FINALISED",om="CANNOT_EMIT_FROM_OPTIONS_HOOK",_m="CHUNK_NOT_GENERATED",lm="CIRCULAR_REEXPORT",cm="DEPRECATED_FEATURE",um="DUPLICATE_PLUGIN_NAME",fm="FILE_NAME_CONFLICT",mm="ILLEGAL_IDENTIFIER_AS_NAME",pm="INVALID_CHUNK",qs="INVALID_EXPORT_OPTION",dm="INVALID_LOG_POSITION",hm="INVALID_OPTION",Vs="INVALID_PLUGIN_HOOK",Xs="INVALID_ROLLUP_PHASE",gm="INVALID_SETASSETSOURCE",bm="MISSING_EXPORT",vm="MISSING_GLOBAL_NAME",Ua="MISSING_IMPLICIT_DEPENDANT",Us="MISSING_NAME_OPTION_FOR_IIFE_EXPORT",ym="MISSING_NODE_BUILTINS",xm="MISSING_OPTION",$m="MIXED_EXPORTS",Em="NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE",km="OPTIMIZE_CHUNK_STATUS",wm="PLUGIN_ERROR",Hs="SOURCEMAP_BROKEN",Ws="UNEXPECTED_NAMED_IMPORT",Cm="UNKNOWN_OPTION",Js="UNRESOLVED_ENTRY",Ks="UNRESOLVED_IMPORT",Sm="VALIDATION_ERROR";function Ys(){return{code:am,message:'Bundle is already closed, no more calls to "generate" or "write" are allowed.'}}function Zs(t){return{code:"CANNOT_CALL_NAMESPACE",message:`Cannot call a namespace ("${t}").`}}function Am({fileName:t,code:n},e){const r={code:"CHUNK_INVALID",message:`Chunk "${t}" is not valid JavaScript: ${e.message}.`};return yr(r,e.loc,n,t),r}function Im(t){return{code:"CIRCULAR_DEPENDENCY",ids:t,message:`Circular dependency: ${t.map(H).join(" -> ")}`}}function Nm(t,n,{line:e,column:r}){return{code:"FIRST_SIDE_EFFECT",message:`First side effect in ${H(n)} is at (${e}:${r})
${zs(t,e,r)}`}}function Qs(t,n){return{code:"ILLEGAL_REASSIGNMENT",message:`Illegal reassignment of import "${t}" in "${H(n)}".`}}function xr(t,n,e,r){return{code:"INCONSISTENT_IMPORT_ASSERTIONS",message:`Module "${H(r)}" tried to import "${H(e)}" with ${no(n)} assertions, but it was already imported elsewhere with ${no(t)} assertions. Please ensure that import assertions for the same module are always consistent.`}}const no=t=>{const n=Object.entries(t);return n.length===0?"no":n.map(([e,r])=>`"${e}": "${r}"`).join(", ")};function to(t,n,e){return{code:qs,message:`"${t}" was specified for "output.exports", but entry module "${H(e)}" has the following exports: ${mt(n)}`,url:wn(Ra)}}function vn(t,n,e,r){return{code:hm,message:`Invalid value ${r===void 0?"":`${JSON.stringify(r)} `}for option "${t}" - ${e}.`,url:wn(n)}}function $r(t,n,e){const r=yt(e)===".json";return{binding:t,code:bm,exporter:e,id:n,message:`"${t}" is not exported by "${H(e)}", imported by "${H(n)}".${r?" (Note that you need @rollup/plugin-json to import JSON files)":""}`,url:wn(Yf)}}function Tm(t){const n=[...t.implicitlyLoadedBefore].map(e=>H(e.id)).sort();return{code:Ua,message:`Module "${H(t.id)}" that should be implicitly loaded before ${mt(n)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`}}function eo(t,n,e){return{code:km,message:`${e}, there are
${t} chunks, of which
${n} are below minChunkSize.`}}function Se(t,n,{hook:e,id:r}={}){return!t.code||t.code.startsWith("PLUGIN_")||t.pluginCode||(t.pluginCode=t.code),t.code=wm,t.plugin=n,e&&(t.hook=e),r&&(t.id=r),t}function jm(t){return{code:Hs,message:`Multiple conflicting contents for sourcemap source ${t}`}}function ro(t,n,e){const r=e?"reexport":"import";return{code:Ws,exporter:t,message:`The named export "${n}" was ${r}ed from the external module "${H(t)}" even though its interop type is "defaultOnly". Either remove or change this ${r} or change the value of the "output.interop" option.`,url:wn(Va)}}function Lm(t){return{code:Ws,exporter:t,message:`There was a namespace "*" reexport from the external module "${H(t)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,url:wn(Va)}}function Mn(t){return{code:Sm,message:t}}function Ft(t,n,e,r,a){Ae(t,n,e,r.onLog,r.strictDeprecations,a)}function Ae(t,n,e,r,a,i){if(e||a){const s=function(o,_,l){return{code:cm,message:o,url:wn(_),...l?{plugin:l}:{}}}(t,n,i);if(a)return L(s);r(V,s)}}class fn{constructor(n,e,r,a,i,s){this.options=n,this.id=e,this.renormalizeRenderPath=i,this.dynamicImporters=[],this.execIndex=1/0,this.exportedVariables=new Map,this.importers=[],this.reexported=!1,this.used=!1,this.declarations=new Map,this.mostCommonSuggestion=0,this.nameSuggestions=new Map,this.suggestedVariableName=za(e.split(/[/\\]/).pop());const{importers:o,dynamicImporters:_}=this,l=this.info={assertions:s,ast:null,code:null,dynamicallyImportedIdResolutions:bn,dynamicallyImportedIds:bn,get dynamicImporters(){return _.sort()},exportedBindings:null,exports:null,hasDefaultExport:null,get hasModuleSideEffects(){return Ft("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.",Rs,!0,n),l.moduleSideEffects},id:e,implicitlyLoadedAfterOneOf:bn,implicitlyLoadedBefore:bn,importedIdResolutions:bn,importedIds:bn,get importers(){return o.sort()},isEntry:!1,isExternal:!0,isIncluded:null,meta:a,moduleSideEffects:r,syntheticNamedExports:!1};Object.defineProperty(this.info,"hasModuleSideEffects",{enumerable:!1})}getVariableForExportName(n){const e=this.declarations.get(n);if(e)return[e];const r=new br(this,n);return this.declarations.set(n,r),this.exportedVariables.set(r,n),[r]}suggestName(n){const e=(this.nameSuggestions.get(n)??0)+1;this.nameSuggestions.set(n,e),e>this.mostCommonSuggestion&&(this.mostCommonSuggestion=e,this.suggestedVariableName=n)}warnUnusedImports(){const n=[...this.declarations].filter(([o,_])=>o!=="*"&&!_.included&&!this.reexported&&!_.referenced).map(([o])=>o);if(n.length===0)return;const e=new Set;for(const o of n)for(const _ of this.declarations.get(o).module.importers)e.add(_);const r=[...e];var a,i,s;this.options.onLog(V,{code:"UNUSED_EXTERNAL_IMPORT",exporter:a=this.id,ids:s=r,message:`${mt(i=n,["is","are"])} imported from external module "${a}" but never used in ${mt(s.map(o=>H(o)))}.`,names:i})}}const ae={ArrayPattern(t,n){for(const e of n.elements)e&&ae[e.type](t,e)},AssignmentPattern(t,n){ae[n.left.type](t,n.left)},Identifier(t,n){t.push(n.name)},MemberExpression(){},ObjectPattern(t,n){for(const e of n.properties)e.type==="RestElement"?ae.RestElement(t,e):ae[e.value.type](t,e.value)},RestElement(t,n){ae[n.argument.type](t,n.argument)}},Mm=function(t){const n=[];return ae[t.type](n,t),n};function Ha(){return{brokenFlow:!1,hasBreak:!1,hasContinue:!1,includedCallArguments:new Set,includedLabels:new Set}}function Er(){return{accessed:new re,assigned:new re,brokenFlow:!1,called:new Ls,hasBreak:!1,hasContinue:!1,ignore:{breaks:!1,continues:!1,labels:new Set,returnYield:!1,this:!1},includedLabels:new Set,instantiated:new Ls,replacedVariableInits:new Map}}function Ie(t,n=null){return Object.create(n,t)}new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");const ie=new class extends qn{getLiteralValueAtPath(){}},Bt={value:{hasEffectsWhenCalled:null,returns:U}},Wa=new class extends qn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?je(Ka,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||Te(Ka,t[0],n,e)}},$t={value:{hasEffectsWhenCalled:null,returns:Wa}},se=new class extends qn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?je(Ya,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||Te(Ya,t[0],n,e)}},oe={value:{hasEffectsWhenCalled:null,returns:se}},Ja=new class extends qn{getReturnExpressionWhenCalledAtPath(t){return t.length===1?je(Ne,t[0]):gn}hasEffectsOnInteractionAtPath(t,n,e){return n.type===0?t.length>1:n.type!==2||t.length!==1||Te(Ne,t[0],n,e)}},J={value:{hasEffectsWhenCalled:null,returns:Ja}},ao={value:{hasEffectsWhenCalled({args:t},n){const e=t[2];return t.length<3||typeof e.getLiteralValueAtPath(X,xn,{deoptimizeCache(){}})=="symbol"&&e.hasEffectsOnInteractionAtPath(X,gr,n)},returns:Ja}},kr=Ie({hasOwnProperty:$t,isPrototypeOf:$t,propertyIsEnumerable:$t,toLocaleString:J,toString:J,valueOf:Bt}),Ka=Ie({valueOf:$t},kr),Ya=Ie({toExponential:J,toFixed:J,toLocaleString:J,toPrecision:J,valueOf:oe},kr),Dm=Ie({exec:Bt,test:$t},kr),Ne=Ie({anchor:J,at:Bt,big:J,blink:J,bold:J,charAt:J,charCodeAt:oe,codePointAt:Bt,concat:J,endsWith:$t,fixed:J,fontcolor:J,fontsize:J,includes:$t,indexOf:oe,italics:J,lastIndexOf:oe,link:J,localeCompare:oe,match:Bt,matchAll:Bt,normalize:J,padEnd:J,padStart:J,repeat:J,replace:ao,replaceAll:ao,search:oe,slice:J,small:J,split:Bt,startsWith:$t,strike:J,sub:J,substr:J,substring:J,sup:J,toLocaleLowerCase:J,toLocaleUpperCase:J,toLowerCase:J,toString:J,toUpperCase:J,trim:J,trimEnd:J,trimLeft:J,trimRight:J,trimStart:J,valueOf:J},kr);function Te(t,n,e,r){var a,i;return typeof n!="string"||!t[n]||((i=(a=t[n]).hasEffectsWhenCalled)==null?void 0:i.call(a,e,r))||!1}function je(t,n){return typeof n=="string"&&t[n]?[t[n].returns,!1]:gn}function Za(t,n,e){e(t,n)}function Gt(t,n,e){}var j={};j.Program=j.BlockStatement=j.StaticBlock=function(t,n,e){for(var r=0,a=t.body;r<a.length;r+=1)e(a[r],n,"Statement")},j.Statement=Za,j.EmptyStatement=Gt,j.ExpressionStatement=j.ParenthesizedExpression=j.ChainExpression=function(t,n,e){return e(t.expression,n,"Expression")},j.IfStatement=function(t,n,e){e(t.test,n,"Expression"),e(t.consequent,n,"Statement"),t.alternate&&e(t.alternate,n,"Statement")},j.LabeledStatement=function(t,n,e){return e(t.body,n,"Statement")},j.BreakStatement=j.ContinueStatement=Gt,j.WithStatement=function(t,n,e){e(t.object,n,"Expression"),e(t.body,n,"Statement")},j.SwitchStatement=function(t,n,e){e(t.discriminant,n,"Expression");for(var r=0,a=t.cases;r<a.length;r+=1){var i=a[r];i.test&&e(i.test,n,"Expression");for(var s=0,o=i.consequent;s<o.length;s+=1)e(o[s],n,"Statement")}},j.SwitchCase=function(t,n,e){t.test&&e(t.test,n,"Expression");for(var r=0,a=t.consequent;r<a.length;r+=1)e(a[r],n,"Statement")},j.ReturnStatement=j.YieldExpression=j.AwaitExpression=function(t,n,e){t.argument&&e(t.argument,n,"Expression")},j.ThrowStatement=j.SpreadElement=function(t,n,e){return e(t.argument,n,"Expression")},j.TryStatement=function(t,n,e){e(t.block,n,"Statement"),t.handler&&e(t.handler,n),t.finalizer&&e(t.finalizer,n,"Statement")},j.CatchClause=function(t,n,e){t.param&&e(t.param,n,"Pattern"),e(t.body,n,"Statement")},j.WhileStatement=j.DoWhileStatement=function(t,n,e){e(t.test,n,"Expression"),e(t.body,n,"Statement")},j.ForStatement=function(t,n,e){t.init&&e(t.init,n,"ForInit"),t.test&&e(t.test,n,"Expression"),t.update&&e(t.update,n,"Expression"),e(t.body,n,"Statement")},j.ForInStatement=j.ForOfStatement=function(t,n,e){e(t.left,n,"ForInit"),e(t.right,n,"Expression"),e(t.body,n,"Statement")},j.ForInit=function(t,n,e){t.type==="VariableDeclaration"?e(t,n):e(t,n,"Expression")},j.DebuggerStatement=Gt,j.FunctionDeclaration=function(t,n,e){return e(t,n,"Function")},j.VariableDeclaration=function(t,n,e){for(var r=0,a=t.declarations;r<a.length;r+=1)e(a[r],n)},j.VariableDeclarator=function(t,n,e){e(t.id,n,"Pattern"),t.init&&e(t.init,n,"Expression")},j.Function=function(t,n,e){t.id&&e(t.id,n,"Pattern");for(var r=0,a=t.params;r<a.length;r+=1)e(a[r],n,"Pattern");e(t.body,n,t.expression?"Expression":"Statement")},j.Pattern=function(t,n,e){t.type==="Identifier"?e(t,n,"VariablePattern"):t.type==="MemberExpression"?e(t,n,"MemberPattern"):e(t,n)},j.VariablePattern=Gt,j.MemberPattern=Za,j.RestElement=function(t,n,e){return e(t.argument,n,"Pattern")},j.ArrayPattern=function(t,n,e){for(var r=0,a=t.elements;r<a.length;r+=1){var i=a[r];i&&e(i,n,"Pattern")}},j.ObjectPattern=function(t,n,e){for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];i.type==="Property"?(i.computed&&e(i.key,n,"Expression"),e(i.value,n,"Pattern")):i.type==="RestElement"&&e(i.argument,n,"Pattern")}},j.Expression=Za,j.ThisExpression=j.Super=j.MetaProperty=Gt,j.ArrayExpression=function(t,n,e){for(var r=0,a=t.elements;r<a.length;r+=1){var i=a[r];i&&e(i,n,"Expression")}},j.ObjectExpression=function(t,n,e){for(var r=0,a=t.properties;r<a.length;r+=1)e(a[r],n)},j.FunctionExpression=j.ArrowFunctionExpression=j.FunctionDeclaration,j.SequenceExpression=function(t,n,e){for(var r=0,a=t.expressions;r<a.length;r+=1)e(a[r],n,"Expression")},j.TemplateLiteral=function(t,n,e){for(var r=0,a=t.quasis;r<a.length;r+=1)e(a[r],n);for(var i=0,s=t.expressions;i<s.length;i+=1)e(s[i],n,"Expression")},j.TemplateElement=Gt,j.UnaryExpression=j.UpdateExpression=function(t,n,e){e(t.argument,n,"Expression")},j.BinaryExpression=j.LogicalExpression=function(t,n,e){e(t.left,n,"Expression"),e(t.right,n,"Expression")},j.AssignmentExpression=j.AssignmentPattern=function(t,n,e){e(t.left,n,"Pattern"),e(t.right,n,"Expression")},j.ConditionalExpression=function(t,n,e){e(t.test,n,"Expression"),e(t.consequent,n,"Expression"),e(t.alternate,n,"Expression")},j.NewExpression=j.CallExpression=function(t,n,e){if(e(t.callee,n,"Expression"),t.arguments)for(var r=0,a=t.arguments;r<a.length;r+=1)e(a[r],n,"Expression")},j.MemberExpression=function(t,n,e){e(t.object,n,"Expression"),t.computed&&e(t.property,n,"Expression")},j.ExportNamedDeclaration=j.ExportDefaultDeclaration=function(t,n,e){t.declaration&&e(t.declaration,n,t.type==="ExportNamedDeclaration"||t.declaration.id?"Statement":"Expression"),t.source&&e(t.source,n,"Expression")},j.ExportAllDeclaration=function(t,n,e){t.exported&&e(t.exported,n),e(t.source,n,"Expression")},j.ImportDeclaration=function(t,n,e){for(var r=0,a=t.specifiers;r<a.length;r+=1)e(a[r],n);e(t.source,n,"Expression")},j.ImportExpression=function(t,n,e){e(t.source,n,"Expression")},j.ImportSpecifier=j.ImportDefaultSpecifier=j.ImportNamespaceSpecifier=j.Identifier=j.PrivateIdentifier=j.Literal=Gt,j.TaggedTemplateExpression=function(t,n,e){e(t.tag,n,"Expression"),e(t.quasi,n,"Expression")},j.ClassDeclaration=j.ClassExpression=function(t,n,e){return e(t,n,"Class")},j.Class=function(t,n,e){t.id&&e(t.id,n,"Pattern"),t.superClass&&e(t.superClass,n,"Expression"),e(t.body,n)},j.ClassBody=function(t,n,e){for(var r=0,a=t.body;r<a.length;r+=1)e(a[r],n)},j.MethodDefinition=j.PropertyDefinition=j.Property=function(t,n,e){t.computed&&e(t.key,n,"Expression"),t.value&&e(t.value,n,"Expression")};const Qa="ArrowFunctionExpression",Pm="BinaryExpression",io="BlockStatement",so="CallExpression",Om="ChainExpression",zm="ConditionalExpression",Fm="ExportDefaultDeclaration",Bm="ExportNamedDeclaration",Vn="ExpressionStatement",Gm="FunctionDeclaration",oo="Identifier",Rm="LogicalExpression",qm="NewExpression",wr="Program",Vm="SequenceExpression",Xm="VariableDeclarator",Um="VariableDeclaration";let ni="sourceMa";ni+="ppingURL";const Hm=new RegExp(`^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+${ni}=.+`),_o="_rollupAnnotations",lo="_rollupRemoved";function co(t,n,e=t.type){const{annotations:r,code:a}=n;let i=r[n.annotationIndex];for(;i&&t.start>=i.end;)Jm(t,i,a),i=r[++n.annotationIndex];if(i&&i.end<=t.end)for(j[e](t,n,co);(i=r[n.annotationIndex])&&i.end<=t.end;)++n.annotationIndex,Sr(t,i,!1)}const Wm=/[^\s(]/g,ti=/\S/g;function Jm(t,n,e){const r=[];let a;if(Cr(e.slice(n.end,t.start),Wm)){const i=t.start;for(;;){switch(r.push(t),t.type){case Vn:case Om:t=t.expression;continue;case Vm:if(Cr(e.slice(i,t.start),ti)){t=t.expressions[0];continue}a=!0;break;case zm:if(Cr(e.slice(i,t.start),ti)){t=t.test;continue}a=!0;break;case Rm:case Pm:if(Cr(e.slice(i,t.start),ti)){t=t.left;continue}a=!0;break;case Bm:case Fm:t=t.declaration;continue;case Um:{const s=t;if(s.kind==="const"){t=s.declarations[0].init;continue}a=!0;break}case Xm:t=t.init;continue;case Gm:case Qa:case so:case qm:break;default:a=!0}break}}else a=!0;if(a)Sr(t,n,!1);else for(const i of r)Sr(i,n,!0)}function Cr(t,n){let e;for(;(e=n.exec(t))!==null;){if(e[0]==="/"){const r=t.charCodeAt(n.lastIndex);if(r===42){n.lastIndex=t.indexOf("*/",n.lastIndex+1)+2;continue}if(r===47){n.lastIndex=t.indexOf(`
`,n.lastIndex+1)+1;continue}}return n.lastIndex=0,!1}return!0}const Km=[["pure",/[#@]__PURE__/],["noSideEffects",/[#@]__NO_SIDE_EFFECTS__/]];function Sr(t,n,e){const r=e?_o:lo,a=t[r];a?a.push(n):t[r]=[n]}const ei={ImportExpression:["arguments"],Literal:[],Program:["body"]},uo="variables";class O extends qn{constructor(n,e,r,a=!1){super(),this.deoptimized=!1,this.esTreeNode=a?n:null,this.keys=ei[n.type]||function(i){return ei[i.type]=Object.keys(i).filter(s=>typeof i[s]=="object"&&s.charCodeAt(0)!==95),ei[i.type]}(n),this.parent=e,this.context=e.context,this.createScope(r),this.parseNode(n),this.initialise(),this.context.magicString.addSourcemapLocation(this.start),this.context.magicString.addSourcemapLocation(this.end)}addExportedVariables(n,e){}bind(){for(const n of this.keys){const e=this[n];if(Array.isArray(e))for(const r of e)r==null||r.bind();else e&&e.bind()}}createScope(n){this.scope=n}hasEffects(n){this.deoptimized||this.applyDeoptimizations();for(const e of this.keys){const r=this[e];if(r!==null){if(Array.isArray(r)){for(const a of r)if(a!=null&&a.hasEffects(n))return!0}else if(r.hasEffects(n))return!0}}return!1}hasEffectsAsAssignmentTarget(n,e){return this.hasEffects(n)||this.hasEffectsOnInteractionAtPath(X,this.assignmentInteraction,n)}include(n,e,r){this.deoptimized||this.applyDeoptimizations(),this.included=!0;for(const a of this.keys){const i=this[a];if(i!==null)if(Array.isArray(i))for(const s of i)s==null||s.include(n,e);else i.include(n,e)}}includeAsAssignmentTarget(n,e,r){this.include(n,e)}initialise(){}insertSemicolon(n){n.original[this.end-1]!==";"&&n.appendLeft(this.end,";")}parseNode(n,e){for(const[r,a]of Object.entries(n))if(!this.hasOwnProperty(r))if(r.charCodeAt(0)===95){if(r===_o){const i=a;this.annotations=i,this.context.options.treeshake.annotations&&(this.annotationNoSideEffects=i.some(s=>s.annotationType==="noSideEffects"),this.annotationPure=i.some(s=>s.annotationType==="pure"))}else if(r===lo)for(const{start:i,end:s}of a)this.context.magicString.remove(i,s)}else if(typeof a!="object"||a===null)this[r]=a;else if(Array.isArray(a)){this[r]=[];for(const i of a)this[r].push(i===null?null:new(this.context.getNodeConstructor(i.type))(i,this,this.scope,e==null?void 0:e.includes(r)))}else this[r]=new(this.context.getNodeConstructor(a.type))(a,this,this.scope,e==null?void 0:e.includes(r))}render(n,e){for(const r of this.keys){const a=this[r];if(a!==null)if(Array.isArray(a))for(const i of a)i==null||i.render(n,e);else a.render(n,e)}}setAssignedValue(n){this.assignmentInteraction={args:[null,n],type:1}}shouldBeIncluded(n){return this.included||!n.brokenFlow&&this.hasEffects(Er())}applyDeoptimizations(){this.deoptimized=!0;for(const n of this.keys){const e=this[n];if(e!==null)if(Array.isArray(e))for(const r of e)r==null||r.deoptimizePath(nn);else e.deoptimizePath(nn)}this.context.requestTreeshakingPass()}}class Le extends O{deoptimizeArgumentsOnInteractionAtPath(n,e,r){e.length>0&&this.argument.deoptimizeArgumentsOnInteractionAtPath(n,[on,...e],r)}hasEffects(n){this.deoptimized||this.applyDeoptimizations();const{propertyReadSideEffects:e}=this.context.options.treeshake;return this.argument.hasEffects(n)||e&&(e==="always"||this.argument.hasEffectsOnInteractionAtPath(nn,Pa,n))}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath([on,on]),this.context.requestTreeshakingPass()}}class jn extends qn{constructor(n){super(),this.description=n}deoptimizeArgumentsOnInteractionAtPath({args:n,type:e},r){var a;e===2&&r.length===0&&this.description.mutatesSelfAsArray&&((a=n[0])==null||a.deoptimizePath(Da))}getReturnExpressionWhenCalledAtPath(n,{args:e}){return n.length>0?gn:[this.description.returnsPrimitive||(this.description.returns==="self"?e[0]||U:this.description.returns()),!1]}hasEffectsOnInteractionAtPath(n,e,r){var i,s;const{type:a}=e;if(n.length>(a===0?1:0))return!0;if(a===2){const{args:o}=e;if(this.description.mutatesSelfAsArray===!0&&((i=o[0])!=null&&i.hasEffectsOnInteractionAtPath(Da,Oa,r)))return!0;if(this.description.callsArgs){for(const _ of this.description.callsArgs)if((s=o[_+1])!=null&&s.hasEffectsOnInteractionAtPath(X,gr,r))return!0}}return!1}}const Ar=[new jn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Wa})],Me=[new jn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:Ja})],fo=[new jn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:se})],mo=[new jn({callsArgs:null,mutatesSelfAsArray:!1,returns:null,returnsPrimitive:U})],De=/^\d+$/;class Bn extends qn{constructor(n,e,r=!1){if(super(),this.prototypeExpression=e,this.immutable=r,this.additionalExpressionsToBeDeoptimized=new Set,this.allProperties=[],this.deoptimizedPaths=Object.create(null),this.expressionsToBeDeoptimizedByKey=Object.create(null),this.gettersByKey=Object.create(null),this.hasLostTrack=!1,this.hasUnknownDeoptimizedInteger=!1,this.hasUnknownDeoptimizedProperty=!1,this.propertiesAndGettersByKey=Object.create(null),this.propertiesAndSettersByKey=Object.create(null),this.settersByKey=Object.create(null),this.unknownIntegerProps=[],this.unmatchableGetters=[],this.unmatchablePropertiesAndGetters=[],this.unmatchableSetters=[],Array.isArray(n))this.buildPropertyMaps(n);else{this.propertiesAndGettersByKey=this.propertiesAndSettersByKey=n;for(const a of Object.values(n))this.allProperties.push(...a)}}deoptimizeAllProperties(n){var r;const e=this.hasLostTrack||this.hasUnknownDeoptimizedProperty;if(n?this.hasUnknownDeoptimizedProperty=!0:this.hasLostTrack=!0,!e){for(const a of[...Object.values(this.propertiesAndGettersByKey),...Object.values(this.settersByKey)])for(const i of a)i.deoptimizePath(nn);(r=this.prototypeExpression)==null||r.deoptimizePath([on,on]),this.deoptimizeCachedEntities()}}deoptimizeArgumentsOnInteractionAtPath(n,e,r){var f;const[a,...i]=e,{args:s,type:o}=n;if(this.hasLostTrack||(o===2||e.length>1)&&(this.hasUnknownDeoptimizedProperty||typeof a=="string"&&this.deoptimizedPaths[a]))return void xt(n);const[_,l,u]=o===2||e.length>1?[this.propertiesAndGettersByKey,this.propertiesAndGettersByKey,this.unmatchablePropertiesAndGetters]:o===0?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if(typeof a=="string"){if(_[a]){const m=l[a];if(m)for(const h of m)h.deoptimizeArgumentsOnInteractionAtPath(n,i,r);if(!this.immutable)for(const h of s)h&&this.additionalExpressionsToBeDeoptimized.add(h);return}for(const m of u)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r);if(De.test(a))for(const m of this.unknownIntegerProps)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r)}else{for(const m of[...Object.values(l),u])for(const h of m)h.deoptimizeArgumentsOnInteractionAtPath(n,i,r);for(const m of this.unknownIntegerProps)m.deoptimizeArgumentsOnInteractionAtPath(n,i,r)}if(!this.immutable)for(const m of s)m&&this.additionalExpressionsToBeDeoptimized.add(m);(f=this.prototypeExpression)==null||f.deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeIntegerProperties(){if(!(this.hasLostTrack||this.hasUnknownDeoptimizedProperty||this.hasUnknownDeoptimizedInteger)){this.hasUnknownDeoptimizedInteger=!0;for(const[n,e]of Object.entries(this.propertiesAndGettersByKey))if(De.test(n))for(const r of e)r.deoptimizePath(nn);this.deoptimizeCachedIntegerEntities()}}deoptimizePath(n){var a;if(this.hasLostTrack||this.immutable)return;const e=n[0];if(n.length===1){if(typeof e!="string")return e===ke?this.deoptimizeIntegerProperties():this.deoptimizeAllProperties(e===hr);if(!this.deoptimizedPaths[e]){this.deoptimizedPaths[e]=!0;const i=this.expressionsToBeDeoptimizedByKey[e];if(i)for(const s of i)s.deoptimizeCache()}}const r=n.length===1?nn:n.slice(1);for(const i of typeof e=="string"?[...this.propertiesAndGettersByKey[e]||this.unmatchablePropertiesAndGetters,...this.settersByKey[e]||this.unmatchableSetters]:this.allProperties)i.deoptimizePath(r);(a=this.prototypeExpression)==null||a.deoptimizePath(n.length===1?[...n,on]:n)}getLiteralValueAtPath(n,e,r){if(n.length===0)return Ms;const a=n[0],i=this.getMemberExpressionAndTrackDeopt(a,r);return i?i.getLiteralValueAtPath(n.slice(1),e,r):this.prototypeExpression?this.prototypeExpression.getLiteralValueAtPath(n,e,r):n.length!==1?mn:void 0}getReturnExpressionWhenCalledAtPath(n,e,r,a){if(n.length===0)return gn;const[i,...s]=n,o=this.getMemberExpressionAndTrackDeopt(i,a);return o?o.getReturnExpressionWhenCalledAtPath(s,e,r,a):this.prototypeExpression?this.prototypeExpression.getReturnExpressionWhenCalledAtPath(n,e,r,a):gn}hasEffectsOnInteractionAtPath(n,e,r){const[a,...i]=n;if(i.length>0||e.type===2){const l=this.getMemberExpression(a);return l?l.hasEffectsOnInteractionAtPath(i,e,r):!this.prototypeExpression||this.prototypeExpression.hasEffectsOnInteractionAtPath(n,e,r)}if(a===hr)return!1;if(this.hasLostTrack)return!0;const[s,o,_]=e.type===0?[this.propertiesAndGettersByKey,this.gettersByKey,this.unmatchableGetters]:[this.propertiesAndSettersByKey,this.settersByKey,this.unmatchableSetters];if(typeof a=="string"){if(s[a]){const l=o[a];if(l){for(const u of l)if(u.hasEffectsOnInteractionAtPath(i,e,r))return!0}return!1}for(const l of _)if(l.hasEffectsOnInteractionAtPath(i,e,r))return!0}else for(const l of[...Object.values(o),_])for(const u of l)if(u.hasEffectsOnInteractionAtPath(i,e,r))return!0;return!!this.prototypeExpression&&this.prototypeExpression.hasEffectsOnInteractionAtPath(n,e,r)}buildPropertyMaps(n){const{allProperties:e,propertiesAndGettersByKey:r,propertiesAndSettersByKey:a,settersByKey:i,gettersByKey:s,unknownIntegerProps:o,unmatchablePropertiesAndGetters:_,unmatchableGetters:l,unmatchableSetters:u}=this,f=[];for(let m=n.length-1;m>=0;m--){const{key:h,kind:v,property:d}=n[m];if(e.push(d),typeof h=="string")v==="set"?a[h]||(a[h]=[d,...f],i[h]=[d,...u]):v==="get"?r[h]||(r[h]=[d,..._],s[h]=[d,...l]):(a[h]||(a[h]=[d,...f]),r[h]||(r[h]=[d,..._]));else{if(h===ke){o.push(d);continue}v==="set"&&u.push(d),v==="get"&&l.push(d),v!=="get"&&f.push(d),v!=="set"&&_.push(d)}}}deoptimizeCachedEntities(){for(const n of Object.values(this.expressionsToBeDeoptimizedByKey))for(const e of n)e.deoptimizeCache();for(const n of this.additionalExpressionsToBeDeoptimized)n.deoptimizePath(nn)}deoptimizeCachedIntegerEntities(){for(const[n,e]of Object.entries(this.expressionsToBeDeoptimizedByKey))if(De.test(n))for(const r of e)r.deoptimizeCache();for(const n of this.additionalExpressionsToBeDeoptimized)n.deoptimizePath(Da)}getMemberExpression(n){if(this.hasLostTrack||this.hasUnknownDeoptimizedProperty||typeof n!="string"||this.hasUnknownDeoptimizedInteger&&De.test(n)||this.deoptimizedPaths[n])return U;const e=this.propertiesAndGettersByKey[n];return(e==null?void 0:e.length)===1?e[0]:e||this.unmatchablePropertiesAndGetters.length>0||this.unknownIntegerProps.length>0&&De.test(n)?U:null}getMemberExpressionAndTrackDeopt(n,e){if(typeof n!="string")return U;const r=this.getMemberExpression(n);return r!==U&&!this.immutable&&(this.expressionsToBeDeoptimizedByKey[n]=this.expressionsToBeDeoptimizedByKey[n]||[]).push(e),r}}const po=t=>typeof t=="string"&&/^\d+$/.test(t),Ym=new class extends qn{deoptimizeArgumentsOnInteractionAtPath(t,n){t.type!==2||n.length!==1||po(n[0])||xt(t)}getLiteralValueAtPath(t){return t.length===1&&po(t[0])?void 0:mn}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n===2}},Et=new Bn({__proto__:null,hasOwnProperty:Ar,isPrototypeOf:Ar,propertyIsEnumerable:Ar,toLocaleString:Me,toString:Me,valueOf:mo},Ym,!0),ri=[{key:ke,kind:"init",property:U},{key:"length",kind:"init",property:se}],ho=[new jn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:Wa})],go=[new jn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:se})],Zm=[new jn({callsArgs:null,mutatesSelfAsArray:!0,returns:()=>new Bn(ri,Nr),returnsPrimitive:null})],Ir=[new jn({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:()=>new Bn(ri,Nr),returnsPrimitive:null})],ai=[new jn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:()=>new Bn(ri,Nr),returnsPrimitive:null})],bo=[new jn({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:se})],vo=[new jn({callsArgs:null,mutatesSelfAsArray:!0,returns:null,returnsPrimitive:U})],yo=[new jn({callsArgs:null,mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:U})],Pe=[new jn({callsArgs:[0],mutatesSelfAsArray:"deopt-only",returns:null,returnsPrimitive:U})],ii=[new jn({callsArgs:null,mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],Qm=[new jn({callsArgs:[0],mutatesSelfAsArray:!0,returns:"self",returnsPrimitive:null})],Nr=new Bn({__proto__:null,at:yo,concat:Ir,copyWithin:ii,entries:Ir,every:ho,fill:ii,filter:ai,find:Pe,findIndex:go,findLast:Pe,findLastIndex:go,flat:Ir,flatMap:ai,forEach:Pe,includes:Ar,indexOf:fo,join:Me,keys:mo,lastIndexOf:fo,map:ai,pop:vo,push:bo,reduce:Pe,reduceRight:Pe,reverse:ii,shift:vo,slice:Ir,some:ho,sort:Qm,splice:Zm,toLocaleString:Me,toString:Me,unshift:bo,values:yo},Et,!0);class xo extends O{constructor(){super(...arguments),this.objectEntity=null}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffectsOnInteractionAtPath(n,e,r){return this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r)}applyDeoptimizations(){this.deoptimized=!0;let n=!1;for(let e=0;e<this.elements.length;e++){const r=this.elements[e];r&&(n||r instanceof Le)&&(n=!0,r.deoptimizePath(nn))}this.context.requestTreeshakingPass()}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;const n=[{key:"length",kind:"init",property:se}];let e=!1;for(let r=0;r<this.elements.length;r++){const a=this.elements[r];e||a instanceof Le?a&&(e=!0,n.unshift({key:ke,kind:"init",property:a})):a?n.push({key:String(r),kind:"init",property:a}):n.push({key:String(r),kind:"init",property:ie})}return this.objectEntity=new Bn(n,Nr)}}class $o extends O{addExportedVariables(n,e){for(const r of this.elements)r==null||r.addExportedVariables(n,e)}declare(n){const e=[];for(const r of this.elements)r!==null&&e.push(...r.declare(n,U));return e}deoptimizePath(){for(const n of this.elements)n==null||n.deoptimizePath(X)}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.elements)if(a!=null&&a.hasEffectsOnInteractionAtPath(X,e,r))return!0;return!1}markDeclarationReached(){for(const n of this.elements)n==null||n.markDeclarationReached()}}class pt extends Pt{constructor(n,e,r,a){super(n),this.init=r,this.calledFromTryStatement=!1,this.additionalInitializers=null,this.expressionsToBeDeoptimized=[],this.declarations=e?[e]:[],this.deoptimizationTracker=a.deoptimizationTracker,this.module=a.module}addDeclaration(n,e){this.declarations.push(n),this.markInitializersForDeoptimization().push(e)}consolidateInitializers(){if(this.additionalInitializers){for(const n of this.additionalInitializers)n.deoptimizePath(nn);this.additionalInitializers=null}}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.isReassigned?xt(n):r.withTrackedEntityAtPath(e,this.init,()=>this.init.deoptimizeArgumentsOnInteractionAtPath(n,e,r),void 0)}deoptimizePath(n){if(!this.isReassigned&&!this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(n,this))if(n.length===0){if(!this.isReassigned){this.isReassigned=!0;const e=this.expressionsToBeDeoptimized;this.expressionsToBeDeoptimized=bn;for(const r of e)r.deoptimizeCache();this.init.deoptimizePath(nn)}}else this.init.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.isReassigned?mn:e.withTrackedEntityAtPath(n,this.init,()=>(this.expressionsToBeDeoptimized.push(r),this.init.getLiteralValueAtPath(n,e,r)),mn)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.isReassigned?gn:r.withTrackedEntityAtPath(n,this.init,()=>(this.expressionsToBeDeoptimized.push(a),this.init.getReturnExpressionWhenCalledAtPath(n,e,r,a)),gn)}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return!!this.isReassigned||!r.accessed.trackEntityAtPathAndGetIfTracked(n,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r);case 1:return!!this.included||n.length!==0&&(!!this.isReassigned||!r.assigned.trackEntityAtPathAndGetIfTracked(n,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r));case 2:return!!this.isReassigned||!(e.withNew?r.instantiated:r.called).trackEntityAtPathAndGetIfTracked(n,e.args,this)&&this.init.hasEffectsOnInteractionAtPath(n,e,r)}}include(){if(!this.included){this.included=!0;for(const n of this.declarations){n.included||n.include(Ha(),!1);let e=n.parent;for(;!e.included&&(e.included=!0,e.type!==wr);)e=e.parent}}}includeCallArguments(n,e){if(this.isReassigned||n.includedCallArguments.has(this.init))for(const r of e)r.include(n,!1);else n.includedCallArguments.add(this.init),this.init.includeCallArguments(n,e),n.includedCallArguments.delete(this.init)}markCalledFromTryStatement(){this.calledFromTryStatement=!0}markInitializersForDeoptimization(){return this.additionalInitializers===null&&(this.additionalInitializers=[this.init],this.init=U,this.isReassigned=!0),this.additionalInitializers}mergeDeclarations(n){const{declarations:e}=this;for(const a of n.declarations)e.push(a);const r=this.markInitializersForDeoptimization();if(r.push(n.init),n.additionalInitializers)for(const a of n.additionalInitializers)r.push(a)}}const Eo=bn,np=new Set([on]),tp=new re,ep=new Set([U]);class ko extends pt{constructor(n,e,r){super(n,e,U,r),this.deoptimizationInteractions=[],this.deoptimizations=new re,this.deoptimizedFields=new Set,this.entitiesToBeDeoptimized=new Set}addEntityToBeDeoptimized(n){if(n===U){if(!this.entitiesToBeDeoptimized.has(U)){this.entitiesToBeDeoptimized.add(U);for(const{interaction:e}of this.deoptimizationInteractions)xt(e);this.deoptimizationInteractions=Eo}}else if(this.deoptimizedFields.has(on))n.deoptimizePath(nn);else if(!this.entitiesToBeDeoptimized.has(n)){this.entitiesToBeDeoptimized.add(n);for(const e of this.deoptimizedFields)n.deoptimizePath([e]);for(const{interaction:e,path:r}of this.deoptimizationInteractions)n.deoptimizeArgumentsOnInteractionAtPath(e,r,xn)}}deoptimizeArgumentsOnInteractionAtPath(n,e){if(e.length>=2||this.entitiesToBeDeoptimized.has(U)||this.deoptimizationInteractions.length>=20||e.length===1&&(this.deoptimizedFields.has(on)||n.type===2&&this.deoptimizedFields.has(e[0])))xt(n);else if(!this.deoptimizations.trackEntityAtPathAndGetIfTracked(e,n.args)){for(const r of this.entitiesToBeDeoptimized)r.deoptimizeArgumentsOnInteractionAtPath(n,e,xn);this.entitiesToBeDeoptimized.has(U)||this.deoptimizationInteractions.push({interaction:n,path:e})}}deoptimizePath(n){if(n.length===0||this.deoptimizedFields.has(on))return;const e=n[0];if(!this.deoptimizedFields.has(e)){this.deoptimizedFields.add(e);for(const r of this.entitiesToBeDeoptimized)r.deoptimizePath(n);e===on&&(this.deoptimizationInteractions=Eo,this.deoptimizations=tp,this.deoptimizedFields=np,this.entitiesToBeDeoptimized=ep)}}getReturnExpressionWhenCalledAtPath(n){return n.length===0?this.deoptimizePath(nn):this.deoptimizedFields.has(n[0])||this.deoptimizePath([n[0]]),gn}}const rp="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$",wo=64;function Tr(t){let n="";do{const e=t%wo;t=t/wo|0,n=rp[e]+n}while(t!==0);return n}function et(t,n,e){let r=t,a=1;for(;n.has(r)||vr.has(r)||e!=null&&e.has(r);)r=`${t}$${Tr(a++)}`;return n.add(r),r}let Co=class{constructor(){this.children=[],this.variables=new Map}addDeclaration(t,n,e,r){const a=t.name;let i=this.variables.get(a);return i?i.addDeclaration(t,e):(i=new pt(t.name,t,e||ie,n),this.variables.set(a,i)),i}contains(t){return this.variables.has(t)}findVariable(t){throw new Error("Internal Error: findVariable needs to be implemented by a subclass")}};class Kn extends Co{constructor(n){super(),this.accessedOutsideVariables=new Map,this.parent=n,n.children.push(this)}addAccessedDynamicImport(n){(this.accessedDynamicImports||(this.accessedDynamicImports=new Set)).add(n),this.parent instanceof Kn&&this.parent.addAccessedDynamicImport(n)}addAccessedGlobals(n,e){const r=e.get(this)||new Set;for(const a of n)r.add(a);e.set(this,r),this.parent instanceof Kn&&this.parent.addAccessedGlobals(n,e)}addNamespaceMemberAccess(n,e){this.accessedOutsideVariables.set(n,e),this.parent.addNamespaceMemberAccess(n,e)}addReturnExpression(n){this.parent instanceof Kn&&this.parent.addReturnExpression(n)}addUsedOutsideNames(n,e,r,a){for(const s of this.accessedOutsideVariables.values())s.included&&(n.add(s.getBaseVariableName()),e==="system"&&r.has(s)&&n.add("exports"));const i=a.get(this);if(i)for(const s of i)n.add(s)}contains(n){return this.variables.has(n)||this.parent.contains(n)}deconflict(n,e,r){const a=new Set;if(this.addUsedOutsideNames(a,n,e,r),this.accessedDynamicImports)for(const i of this.accessedDynamicImports)i.inlineNamespace&&a.add(i.inlineNamespace.getBaseVariableName());for(const[i,s]of this.variables)(s.included||s.alwaysRendered)&&s.setRenderNames(null,et(i,a,s.forbiddenNames));for(const i of this.children)i.deconflict(n,e,r)}findLexicalBoundary(){return this.parent.findLexicalBoundary()}findVariable(n){const e=this.variables.get(n)||this.accessedOutsideVariables.get(n);if(e)return e;const r=this.parent.findVariable(n);return this.accessedOutsideVariables.set(n,r),r}}class So extends Kn{constructor(n,e){super(n),this.parameters=[],this.hasRest=!1,this.context=e,this.hoistedBodyVarScope=new Kn(this)}addParameterDeclaration(n){const{name:e}=n,r=new ko(e,n,this.context),a=this.hoistedBodyVarScope.variables.get(e);return a&&(this.hoistedBodyVarScope.variables.set(e,r),r.mergeDeclarations(a)),this.variables.set(e,r),r}addParameterVariables(n,e){this.parameters=n;for(const r of n)for(const a of r)a.alwaysRendered=!0;this.hasRest=e}includeCallArguments(n,e){let r=!1,a=!1;const i=this.hasRest&&this.parameters[this.parameters.length-1];for(const s of e)if(s instanceof Le){for(const o of e)o.include(n,!1);break}for(let s=e.length-1;s>=0;s--){const o=this.parameters[s]||i,_=e[s];if(o)if(r=!1,o.length===0)a=!0;else for(const l of o)l.included&&(a=!0),l.calledFromTryStatement&&(r=!0);!a&&_.shouldBeIncluded(n)&&(a=!0),a&&_.include(n,r)}}}class Ao extends So{constructor(){super(...arguments),this.returnExpression=null,this.returnExpressions=[]}addReturnExpression(n){this.returnExpressions.push(n)}getReturnExpression(){return this.returnExpression===null&&this.updateReturnExpression(),this.returnExpression}updateReturnExpression(){if(this.returnExpressions.length===1)this.returnExpression=this.returnExpressions[0];else{this.returnExpression=U;for(const n of this.returnExpressions)n.deoptimizePath(nn)}}}function Io(t,n){if(t.type==="MemberExpression")return!t.computed&&Io(t.object,t);if(t.type==="Identifier"){if(!n)return!0;switch(n.type){case"MemberExpression":return n.computed||t===n.object;case"MethodDefinition":return n.computed;case"PropertyDefinition":case"Property":return n.computed||t===n.value;case"ExportSpecifier":case"ImportSpecifier":return t===n.local;case"LabeledStatement":case"BreakStatement":case"ContinueStatement":return!1;default:return!0}}return!1}const si=Symbol("PureFunction"),rt=()=>{},dn=Symbol("Value Properties"),jr=()=>Ms,No=()=>!0,at={deoptimizeArgumentsOnCall:rt,getLiteralValue:jr,hasEffectsWhenCalled:()=>!1},kt={deoptimizeArgumentsOnCall:rt,getLiteralValue:jr,hasEffectsWhenCalled:No},C={__proto__:null,[dn]:kt},M={__proto__:null,[dn]:at},oi={__proto__:null,[dn]:{deoptimizeArgumentsOnCall({args:[,t]}){t==null||t.deoptimizePath(nn)},getLiteralValue:jr,hasEffectsWhenCalled:({args:t},n)=>t.length<=1||t[1].hasEffectsOnInteractionAtPath(Wf,Oa,n)}},c={__proto__:null,[dn]:kt,prototype:C},Yn={__proto__:null,[dn]:at,prototype:C},Lr={__proto__:null,[dn]:{deoptimizeArgumentsOnCall:rt,getLiteralValue:jr,hasEffectsWhenCalled:({args:t})=>t.length>1&&!(t[1]instanceof xo)},prototype:C},dt={__proto__:null,[dn]:at,from:C,of:M,prototype:C},_e={__proto__:null,[dn]:at,supportedLocalesOf:Yn},_i={global:C,globalThis:C,self:C,window:C,__proto__:null,[dn]:kt,Array:{__proto__:null,[dn]:kt,from:C,isArray:M,of:M,prototype:C},ArrayBuffer:{__proto__:null,[dn]:at,isView:M,prototype:C},Atomics:C,BigInt:c,BigInt64Array:c,BigUint64Array:c,Boolean:Yn,constructor:c,DataView:Yn,Date:{__proto__:null,[dn]:at,now:M,parse:M,prototype:C,UTC:M},decodeURI:M,decodeURIComponent:M,encodeURI:M,encodeURIComponent:M,Error:Yn,escape:M,eval:C,EvalError:Yn,Float32Array:dt,Float64Array:dt,Function:c,hasOwnProperty:C,Infinity:C,Int16Array:dt,Int32Array:dt,Int8Array:dt,isFinite:M,isNaN:M,isPrototypeOf:C,JSON:C,Map:Lr,Math:{__proto__:null,[dn]:kt,abs:M,acos:M,acosh:M,asin:M,asinh:M,atan:M,atan2:M,atanh:M,cbrt:M,ceil:M,clz32:M,cos:M,cosh:M,exp:M,expm1:M,floor:M,fround:M,hypot:M,imul:M,log:M,log10:M,log1p:M,log2:M,max:M,min:M,pow:M,random:M,round:M,sign:M,sin:M,sinh:M,sqrt:M,tan:M,tanh:M,trunc:M},NaN:C,Number:{__proto__:null,[dn]:at,isFinite:M,isInteger:M,isNaN:M,isSafeInteger:M,parseFloat:M,parseInt:M,prototype:C},Object:{__proto__:null,[dn]:at,create:M,defineProperty:oi,defineProperties:oi,freeze:oi,getOwnPropertyDescriptor:M,getOwnPropertyDescriptors:M,getOwnPropertyNames:M,getOwnPropertySymbols:M,getPrototypeOf:M,hasOwn:M,is:M,isExtensible:M,isFrozen:M,isSealed:M,keys:M,fromEntries:C,entries:M,prototype:C},parseFloat:M,parseInt:M,Promise:{__proto__:null,[dn]:kt,all:C,allSettled:C,any:C,prototype:C,race:C,reject:C,resolve:C},propertyIsEnumerable:C,Proxy:C,RangeError:Yn,ReferenceError:Yn,Reflect:C,RegExp:Yn,Set:Lr,SharedArrayBuffer:c,String:{__proto__:null,[dn]:at,fromCharCode:M,fromCodePoint:M,prototype:C,raw:M},Symbol:{__proto__:null,[dn]:at,for:M,keyFor:M,prototype:C,toStringTag:{__proto__:null,[dn]:{deoptimizeArgumentsOnCall:rt,getLiteralValue:()=>Ma,hasEffectsWhenCalled:No}}},SyntaxError:Yn,toLocaleString:C,toString:C,TypeError:Yn,Uint16Array:dt,Uint32Array:dt,Uint8Array:dt,Uint8ClampedArray:dt,unescape:M,URIError:Yn,valueOf:C,WeakMap:Lr,WeakSet:Lr,clearInterval:c,clearTimeout:c,console:{__proto__:null,[dn]:kt,assert:c,clear:c,count:c,countReset:c,debug:c,dir:c,dirxml:c,error:c,exception:c,group:c,groupCollapsed:c,groupEnd:c,info:c,log:c,table:c,time:c,timeEnd:c,timeLog:c,trace:c,warn:c},Intl:{__proto__:null,[dn]:kt,Collator:_e,DateTimeFormat:_e,ListFormat:_e,NumberFormat:_e,PluralRules:_e,RelativeTimeFormat:_e},setInterval:c,setTimeout:c,TextDecoder:c,TextEncoder:c,URL:c,URLSearchParams:c,AbortController:c,AbortSignal:c,addEventListener:C,alert:C,AnalyserNode:c,Animation:c,AnimationEvent:c,applicationCache:C,ApplicationCache:c,ApplicationCacheErrorEvent:c,atob:C,Attr:c,Audio:c,AudioBuffer:c,AudioBufferSourceNode:c,AudioContext:c,AudioDestinationNode:c,AudioListener:c,AudioNode:c,AudioParam:c,AudioProcessingEvent:c,AudioScheduledSourceNode:c,AudioWorkletNode:c,BarProp:c,BaseAudioContext:c,BatteryManager:c,BeforeUnloadEvent:c,BiquadFilterNode:c,Blob:c,BlobEvent:c,blur:C,BroadcastChannel:c,btoa:C,ByteLengthQueuingStrategy:c,Cache:c,caches:C,CacheStorage:c,cancelAnimationFrame:C,cancelIdleCallback:C,CanvasCaptureMediaStreamTrack:c,CanvasGradient:c,CanvasPattern:c,CanvasRenderingContext2D:c,ChannelMergerNode:c,ChannelSplitterNode:c,CharacterData:c,clientInformation:C,ClipboardEvent:c,close:C,closed:C,CloseEvent:c,Comment:c,CompositionEvent:c,confirm:C,ConstantSourceNode:c,ConvolverNode:c,CountQueuingStrategy:c,createImageBitmap:C,Credential:c,CredentialsContainer:c,crypto:C,Crypto:c,CryptoKey:c,CSS:c,CSSConditionRule:c,CSSFontFaceRule:c,CSSGroupingRule:c,CSSImportRule:c,CSSKeyframeRule:c,CSSKeyframesRule:c,CSSMediaRule:c,CSSNamespaceRule:c,CSSPageRule:c,CSSRule:c,CSSRuleList:c,CSSStyleDeclaration:c,CSSStyleRule:c,CSSStyleSheet:c,CSSSupportsRule:c,CustomElementRegistry:c,customElements:C,CustomEvent:c,DataTransfer:c,DataTransferItem:c,DataTransferItemList:c,defaultstatus:C,defaultStatus:C,DelayNode:c,DeviceMotionEvent:c,DeviceOrientationEvent:c,devicePixelRatio:C,dispatchEvent:C,document:C,Document:c,DocumentFragment:c,DocumentType:c,DOMError:c,DOMException:c,DOMImplementation:c,DOMMatrix:c,DOMMatrixReadOnly:c,DOMParser:c,DOMPoint:c,DOMPointReadOnly:c,DOMQuad:c,DOMRect:c,DOMRectReadOnly:c,DOMStringList:c,DOMStringMap:c,DOMTokenList:c,DragEvent:c,DynamicsCompressorNode:c,Element:c,ErrorEvent:c,Event:c,EventSource:c,EventTarget:c,external:C,fetch:C,File:c,FileList:c,FileReader:c,find:C,focus:C,FocusEvent:c,FontFace:c,FontFaceSetLoadEvent:c,FormData:c,frames:C,GainNode:c,Gamepad:c,GamepadButton:c,GamepadEvent:c,getComputedStyle:C,getSelection:C,HashChangeEvent:c,Headers:c,history:C,History:c,HTMLAllCollection:c,HTMLAnchorElement:c,HTMLAreaElement:c,HTMLAudioElement:c,HTMLBaseElement:c,HTMLBodyElement:c,HTMLBRElement:c,HTMLButtonElement:c,HTMLCanvasElement:c,HTMLCollection:c,HTMLContentElement:c,HTMLDataElement:c,HTMLDataListElement:c,HTMLDetailsElement:c,HTMLDialogElement:c,HTMLDirectoryElement:c,HTMLDivElement:c,HTMLDListElement:c,HTMLDocument:c,HTMLElement:c,HTMLEmbedElement:c,HTMLFieldSetElement:c,HTMLFontElement:c,HTMLFormControlsCollection:c,HTMLFormElement:c,HTMLFrameElement:c,HTMLFrameSetElement:c,HTMLHeadElement:c,HTMLHeadingElement:c,HTMLHRElement:c,HTMLHtmlElement:c,HTMLIFrameElement:c,HTMLImageElement:c,HTMLInputElement:c,HTMLLabelElement:c,HTMLLegendElement:c,HTMLLIElement:c,HTMLLinkElement:c,HTMLMapElement:c,HTMLMarqueeElement:c,HTMLMediaElement:c,HTMLMenuElement:c,HTMLMetaElement:c,HTMLMeterElement:c,HTMLModElement:c,HTMLObjectElement:c,HTMLOListElement:c,HTMLOptGroupElement:c,HTMLOptionElement:c,HTMLOptionsCollection:c,HTMLOutputElement:c,HTMLParagraphElement:c,HTMLParamElement:c,HTMLPictureElement:c,HTMLPreElement:c,HTMLProgressElement:c,HTMLQuoteElement:c,HTMLScriptElement:c,HTMLSelectElement:c,HTMLShadowElement:c,HTMLSlotElement:c,HTMLSourceElement:c,HTMLSpanElement:c,HTMLStyleElement:c,HTMLTableCaptionElement:c,HTMLTableCellElement:c,HTMLTableColElement:c,HTMLTableElement:c,HTMLTableRowElement:c,HTMLTableSectionElement:c,HTMLTemplateElement:c,HTMLTextAreaElement:c,HTMLTimeElement:c,HTMLTitleElement:c,HTMLTrackElement:c,HTMLUListElement:c,HTMLUnknownElement:c,HTMLVideoElement:c,IDBCursor:c,IDBCursorWithValue:c,IDBDatabase:c,IDBFactory:c,IDBIndex:c,IDBKeyRange:c,IDBObjectStore:c,IDBOpenDBRequest:c,IDBRequest:c,IDBTransaction:c,IDBVersionChangeEvent:c,IdleDeadline:c,IIRFilterNode:c,Image:c,ImageBitmap:c,ImageBitmapRenderingContext:c,ImageCapture:c,ImageData:c,indexedDB:C,innerHeight:C,innerWidth:C,InputEvent:c,IntersectionObserver:c,IntersectionObserverEntry:c,isSecureContext:C,KeyboardEvent:c,KeyframeEffect:c,length:C,localStorage:C,location:C,Location:c,locationbar:C,matchMedia:C,MediaDeviceInfo:c,MediaDevices:c,MediaElementAudioSourceNode:c,MediaEncryptedEvent:c,MediaError:c,MediaKeyMessageEvent:c,MediaKeySession:c,MediaKeyStatusMap:c,MediaKeySystemAccess:c,MediaList:c,MediaQueryList:c,MediaQueryListEvent:c,MediaRecorder:c,MediaSettingsRange:c,MediaSource:c,MediaStream:c,MediaStreamAudioDestinationNode:c,MediaStreamAudioSourceNode:c,MediaStreamEvent:c,MediaStreamTrack:c,MediaStreamTrackEvent:c,menubar:C,MessageChannel:c,MessageEvent:c,MessagePort:c,MIDIAccess:c,MIDIConnectionEvent:c,MIDIInput:c,MIDIInputMap:c,MIDIMessageEvent:c,MIDIOutput:c,MIDIOutputMap:c,MIDIPort:c,MimeType:c,MimeTypeArray:c,MouseEvent:c,moveBy:C,moveTo:C,MutationEvent:c,MutationObserver:c,MutationRecord:c,name:C,NamedNodeMap:c,NavigationPreloadManager:c,navigator:C,Navigator:c,NetworkInformation:c,Node:c,NodeFilter:C,NodeIterator:c,NodeList:c,Notification:c,OfflineAudioCompletionEvent:c,OfflineAudioContext:c,offscreenBuffering:C,OffscreenCanvas:c,open:C,openDatabase:C,Option:c,origin:C,OscillatorNode:c,outerHeight:C,outerWidth:C,PageTransitionEvent:c,pageXOffset:C,pageYOffset:C,PannerNode:c,parent:C,Path2D:c,PaymentAddress:c,PaymentRequest:c,PaymentRequestUpdateEvent:c,PaymentResponse:c,performance:C,Performance:c,PerformanceEntry:c,PerformanceLongTaskTiming:c,PerformanceMark:c,PerformanceMeasure:c,PerformanceNavigation:c,PerformanceNavigationTiming:c,PerformanceObserver:c,PerformanceObserverEntryList:c,PerformancePaintTiming:c,PerformanceResourceTiming:c,PerformanceTiming:c,PeriodicWave:c,Permissions:c,PermissionStatus:c,personalbar:C,PhotoCapabilities:c,Plugin:c,PluginArray:c,PointerEvent:c,PopStateEvent:c,postMessage:C,Presentation:c,PresentationAvailability:c,PresentationConnection:c,PresentationConnectionAvailableEvent:c,PresentationConnectionCloseEvent:c,PresentationConnectionList:c,PresentationReceiver:c,PresentationRequest:c,print:C,ProcessingInstruction:c,ProgressEvent:c,PromiseRejectionEvent:c,prompt:C,PushManager:c,PushSubscription:c,PushSubscriptionOptions:c,queueMicrotask:C,RadioNodeList:c,Range:c,ReadableStream:c,RemotePlayback:c,removeEventListener:C,Request:c,requestAnimationFrame:C,requestIdleCallback:C,resizeBy:C,ResizeObserver:c,ResizeObserverEntry:c,resizeTo:C,Response:c,RTCCertificate:c,RTCDataChannel:c,RTCDataChannelEvent:c,RTCDtlsTransport:c,RTCIceCandidate:c,RTCIceTransport:c,RTCPeerConnection:c,RTCPeerConnectionIceEvent:c,RTCRtpReceiver:c,RTCRtpSender:c,RTCSctpTransport:c,RTCSessionDescription:c,RTCStatsReport:c,RTCTrackEvent:c,screen:C,Screen:c,screenLeft:C,ScreenOrientation:c,screenTop:C,screenX:C,screenY:C,ScriptProcessorNode:c,scroll:C,scrollbars:C,scrollBy:C,scrollTo:C,scrollX:C,scrollY:C,SecurityPolicyViolationEvent:c,Selection:c,ServiceWorker:c,ServiceWorkerContainer:c,ServiceWorkerRegistration:c,sessionStorage:C,ShadowRoot:c,SharedWorker:c,SourceBuffer:c,SourceBufferList:c,speechSynthesis:C,SpeechSynthesisEvent:c,SpeechSynthesisUtterance:c,StaticRange:c,status:C,statusbar:C,StereoPannerNode:c,stop:C,Storage:c,StorageEvent:c,StorageManager:c,styleMedia:C,StyleSheet:c,StyleSheetList:c,SubtleCrypto:c,SVGAElement:c,SVGAngle:c,SVGAnimatedAngle:c,SVGAnimatedBoolean:c,SVGAnimatedEnumeration:c,SVGAnimatedInteger:c,SVGAnimatedLength:c,SVGAnimatedLengthList:c,SVGAnimatedNumber:c,SVGAnimatedNumberList:c,SVGAnimatedPreserveAspectRatio:c,SVGAnimatedRect:c,SVGAnimatedString:c,SVGAnimatedTransformList:c,SVGAnimateElement:c,SVGAnimateMotionElement:c,SVGAnimateTransformElement:c,SVGAnimationElement:c,SVGCircleElement:c,SVGClipPathElement:c,SVGComponentTransferFunctionElement:c,SVGDefsElement:c,SVGDescElement:c,SVGDiscardElement:c,SVGElement:c,SVGEllipseElement:c,SVGFEBlendElement:c,SVGFEColorMatrixElement:c,SVGFEComponentTransferElement:c,SVGFECompositeElement:c,SVGFEConvolveMatrixElement:c,SVGFEDiffuseLightingElement:c,SVGFEDisplacementMapElement:c,SVGFEDistantLightElement:c,SVGFEDropShadowElement:c,SVGFEFloodElement:c,SVGFEFuncAElement:c,SVGFEFuncBElement:c,SVGFEFuncGElement:c,SVGFEFuncRElement:c,SVGFEGaussianBlurElement:c,SVGFEImageElement:c,SVGFEMergeElement:c,SVGFEMergeNodeElement:c,SVGFEMorphologyElement:c,SVGFEOffsetElement:c,SVGFEPointLightElement:c,SVGFESpecularLightingElement:c,SVGFESpotLightElement:c,SVGFETileElement:c,SVGFETurbulenceElement:c,SVGFilterElement:c,SVGForeignObjectElement:c,SVGGElement:c,SVGGeometryElement:c,SVGGradientElement:c,SVGGraphicsElement:c,SVGImageElement:c,SVGLength:c,SVGLengthList:c,SVGLinearGradientElement:c,SVGLineElement:c,SVGMarkerElement:c,SVGMaskElement:c,SVGMatrix:c,SVGMetadataElement:c,SVGMPathElement:c,SVGNumber:c,SVGNumberList:c,SVGPathElement:c,SVGPatternElement:c,SVGPoint:c,SVGPointList:c,SVGPolygonElement:c,SVGPolylineElement:c,SVGPreserveAspectRatio:c,SVGRadialGradientElement:c,SVGRect:c,SVGRectElement:c,SVGScriptElement:c,SVGSetElement:c,SVGStopElement:c,SVGStringList:c,SVGStyleElement:c,SVGSVGElement:c,SVGSwitchElement:c,SVGSymbolElement:c,SVGTextContentElement:c,SVGTextElement:c,SVGTextPathElement:c,SVGTextPositioningElement:c,SVGTitleElement:c,SVGTransform:c,SVGTransformList:c,SVGTSpanElement:c,SVGUnitTypes:c,SVGUseElement:c,SVGViewElement:c,TaskAttributionTiming:c,Text:c,TextEvent:c,TextMetrics:c,TextTrack:c,TextTrackCue:c,TextTrackCueList:c,TextTrackList:c,TimeRanges:c,toolbar:C,top:C,Touch:c,TouchEvent:c,TouchList:c,TrackEvent:c,TransitionEvent:c,TreeWalker:c,UIEvent:c,ValidityState:c,visualViewport:C,VisualViewport:c,VTTCue:c,WaveShaperNode:c,WebAssembly:C,WebGL2RenderingContext:c,WebGLActiveInfo:c,WebGLBuffer:c,WebGLContextEvent:c,WebGLFramebuffer:c,WebGLProgram:c,WebGLQuery:c,WebGLRenderbuffer:c,WebGLRenderingContext:c,WebGLSampler:c,WebGLShader:c,WebGLShaderPrecisionFormat:c,WebGLSync:c,WebGLTexture:c,WebGLTransformFeedback:c,WebGLUniformLocation:c,WebGLVertexArrayObject:c,WebSocket:c,WheelEvent:c,Window:c,Worker:c,WritableStream:c,XMLDocument:c,XMLHttpRequest:c,XMLHttpRequestEventTarget:c,XMLHttpRequestUpload:c,XMLSerializer:c,XPathEvaluator:c,XPathExpression:c,XPathResult:c,XSLTProcessor:c};for(const t of["window","global","self","globalThis"])_i[t]=_i;function le(t){let n=_i;for(const e of t)if(typeof e!="string"||(n=n[e],!n))return null;return n[dn]}class li extends Pt{constructor(){super(...arguments),this.isReassigned=!0}deoptimizeArgumentsOnInteractionAtPath(n,e,r){switch(n.type){case 0:case 1:return void(le([this.name,...e].slice(0,-1))||super.deoptimizeArgumentsOnInteractionAtPath(n,e,r));case 2:{const a=le([this.name,...e]);return void(a?a.deoptimizeArgumentsOnCall(n):super.deoptimizeArgumentsOnInteractionAtPath(n,e,r))}}}getLiteralValueAtPath(n,e,r){const a=le([this.name,...n]);return a?a.getLiteralValue():mn}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return n.length===0?this.name!=="undefined"&&!le([this.name]):!le([this.name,...n].slice(0,-1));case 1:return!0;case 2:{const a=le([this.name,...n]);return!a||a.hasEffectsWhenCalled(e,r)}}}}const ap={__proto__:null,class:!0,const:!0,let:!0,var:!0};class cn extends O{constructor(){super(...arguments),this.variable=null,this.isTDZAccess=null}addExportedVariables(n,e){e.has(this.variable)&&n.push(this.variable)}bind(){!this.variable&&Io(this,this.parent)&&(this.variable=this.scope.findVariable(this.name),this.variable.addReference(this))}declare(n,e){let r;const{treeshake:a}=this.context.options;switch(n){case"var":r=this.scope.addDeclaration(this,this.context,e,!0),a&&a.correctVarValueBeforeDeclaration&&r.markInitializersForDeoptimization();break;case"function":case"let":case"const":case"class":r=this.scope.addDeclaration(this,this.context,e,!1);break;case"parameter":r=this.scope.addParameterDeclaration(this);break;default:throw new Error(`Internal Error: Unexpected identifier kind ${n}.`)}return r.kind=n,[this.variable=r]}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.variable.deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){var e;n.length!==0||this.scope.contains(this.name)||this.disallowImportReassignment(),(e=this.variable)==null||e.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getVariableRespectingTDZ().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){const[i,s]=this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(n,e,r,a);return[i,s||this.isPureFunction(n)]}hasEffects(n){return this.deoptimized||this.applyDeoptimizations(),!(!this.isPossibleTDZ()||this.variable.kind==="var")||this.context.options.treeshake.unknownGlobalSideEffects&&this.variable instanceof li&&!this.isPureFunction(X)&&this.variable.hasEffectsOnInteractionAtPath(X,Pa,n)}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return this.variable!==null&&!this.isPureFunction(n)&&this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(n,e,r);case 1:return(n.length>0?this.getVariableRespectingTDZ():this.variable).hasEffectsOnInteractionAtPath(n,e,r);case 2:return!this.isPureFunction(n)&&this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(n,e,r)}}include(){this.deoptimized||this.applyDeoptimizations(),this.included||(this.included=!0,this.variable!==null&&this.context.includeVariableInModule(this.variable))}includeCallArguments(n,e){this.variable.includeCallArguments(n,e)}isPossibleTDZ(){if(this.isTDZAccess!==null)return this.isTDZAccess;if(!(this.variable instanceof pt&&this.variable.kind&&this.variable.kind in ap&&this.variable.module===this.context.module))return this.isTDZAccess=!1;let n;return this.variable.declarations&&this.variable.declarations.length===1&&(n=this.variable.declarations[0])&&this.start<n.start&&To(this)===To(n)?this.isTDZAccess=!0:this.variable.initReached?this.isTDZAccess=!1:this.isTDZAccess=!0}markDeclarationReached(){this.variable.initReached=!0}render(n,{snippets:{getPropertyAccess:e},useOriginalName:r},{renderedParentType:a,isCalleeOfRenderedParent:i,isShorthandProperty:s}=In){if(this.variable){const o=this.variable.getName(e,r);o!==this.name&&(n.overwrite(this.start,this.end,o,{contentOnly:!0,storeName:!0}),s&&n.prependRight(this.start,`${this.name}: `)),o==="eval"&&a===so&&i&&n.appendRight(this.start,"0, ")}}applyDeoptimizations(){this.deoptimized=!0,this.variable instanceof pt&&(this.variable.consolidateInitializers(),this.context.requestTreeshakingPass())}disallowImportReassignment(){return this.context.error(Qs(this.name,this.context.module.id),this.start)}getVariableRespectingTDZ(){return this.isPossibleTDZ()?U:this.variable}isPureFunction(n){let e=this.context.manualPureFunctions[this.name];for(const r of n){if(!e)return!1;if(e[si])return!0;e=e[r]}return e==null?void 0:e[si]}}function To(t){for(;t&&!/^Program|Function/.test(t.type);)t=t.parent;return t}function ci(t,n,e,r){if(n.remove(e,r),t.annotations)for(const a of t.annotations){if(!(a.start<e))return;n.remove(a.start,a.end)}}function jo(t,n){if(t.annotations||t.parent.type!==Vn||(t=t.parent),t.annotations)for(const e of t.annotations)n.remove(e.start,e.end)}const Rt={isNoStatement:!0};function En(t,n,e=0){let r,a;for(r=t.indexOf(n,e);;){if((e=t.indexOf("/",e))===-1||e>=r)return r;a=t.charCodeAt(++e),++e,(e=a===47?t.indexOf(`
`,e)+1:t.indexOf("*/",e)+2)>r&&(r=t.indexOf(n,e))}}const Lo=/\S/g;function wt(t,n){return Lo.lastIndex=n,Lo.exec(t).index}function Oe(t){let n,e,r=0;for(n=t.indexOf(`
`,r);;){if(r=t.indexOf("/",r),r===-1||r>n)return[n,n+1];if(e=t.charCodeAt(r+1),e===47)return[r,n+1];r=t.indexOf("*/",r+3)+2,r>n&&(n=t.indexOf(`
`,r))}}function ze(t,n,e,r,a){let i,s,o,_,l=t[0],u=!l.included||l.needsBoundaries;u&&(_=e+Oe(n.original.slice(e,l.start))[1]);for(let f=1;f<=t.length;f++)i=l,s=_,o=u,l=t[f],u=l!==void 0&&(!l.included||l.needsBoundaries),o||u?(_=i.end+Oe(n.original.slice(i.end,l===void 0?r:l.start))[1],i.included?o?i.render(n,a,{end:_,start:s}):i.render(n,a):ci(i,n,s,_)):i.render(n,a)}function Mo(t,n,e,r){const a=[];let i,s,o,_,l=e-1;for(const u of t){for(i!==void 0&&(l=i.end+En(n.original.slice(i.end,u.start),",")),s=o=l+1+Oe(n.original.slice(l+1,u.start))[1];_=n.original.charCodeAt(s),_===32||_===9||_===10||_===13;)s++;i!==void 0&&a.push({contentEnd:o,end:s,node:i,separator:l,start:e}),i=u,e=s}return a.push({contentEnd:r,end:r,node:i,separator:null,start:e}),a}function Mr(t,n,e){for(;;){const[r,a]=Oe(t.original.slice(n,e));if(r===-1)break;t.remove(n+r,n+=a)}}class qt extends Kn{addDeclaration(n,e,r,a){if(a){const i=this.parent.addDeclaration(n,e,r,a);return i.markInitializersForDeoptimization(),i}return super.addDeclaration(n,e,r,!1)}}class Vt extends O{initialise(){var n,e;this.directive&&this.directive!=="use strict"&&this.parent.type===wr&&this.context.log(V,(n=this.directive,{code:"MODULE_LEVEL_DIRECTIVE",id:e=this.context.module.id,message:`Module level directives cause errors when bundled, "${n}" in "${H(e)}" was ignored.`}),this.start)}render(n,e){super.render(n,e),this.included&&this.insertSemicolon(n)}shouldBeIncluded(n){return this.directive&&this.directive!=="use strict"?this.parent.type!==wr:super.shouldBeIncluded(n)}applyDeoptimizations(){}}class Dr extends O{constructor(){super(...arguments),this.directlyIncluded=!1}addImplicitReturnExpressionToScope(){const n=this.body[this.body.length-1];n&&n.type==="ReturnStatement"||this.scope.addReturnExpression(U)}createScope(n){this.scope=this.parent.preventChildBlockScope?n:new qt(n)}hasEffects(n){if(this.deoptimizeBody)return!0;for(const e of this.body){if(n.brokenFlow)break;if(e.hasEffects(n))return!0}return!1}include(n,e){if(!this.deoptimizeBody||!this.directlyIncluded){this.included=!0,this.directlyIncluded=!0,this.deoptimizeBody&&(e=!0);for(const r of this.body)(e||r.shouldBeIncluded(n))&&r.include(n,e)}}initialise(){const n=this.body[0];this.deoptimizeBody=n instanceof Vt&&n.directive==="use asm"}render(n,e){this.body.length>0?ze(this.body,n,this.start+1,this.end-1,e):super.render(n,e)}}class ui extends O{constructor(){super(...arguments),this.declarationInit=null}addExportedVariables(n,e){this.argument.addExportedVariables(n,e)}declare(n,e){return this.declarationInit=e,this.argument.declare(n,U)}deoptimizePath(n){n.length===0&&this.argument.deoptimizePath(X)}hasEffectsOnInteractionAtPath(n,e,r){return n.length>0||this.argument.hasEffectsOnInteractionAtPath(X,e,r)}markDeclarationReached(){this.argument.markDeclarationReached()}applyDeoptimizations(){this.deoptimized=!0,this.declarationInit!==null&&(this.declarationInit.deoptimizePath([on,on]),this.context.requestTreeshakingPass())}}class fi extends O{constructor(){super(...arguments),this.objectEntity=null,this.deoptimizedReturn=!1}deoptimizeArgumentsOnInteractionAtPath(n,e,r){if(n.type===2){const{parameters:a}=this.scope,{args:i}=n;let s=!1;for(let o=0;o<i.length-1;o++){const _=this.params[o],l=i[o+1];s||_ instanceof ui?(s=!0,l.deoptimizePath(nn)):_ instanceof cn?(a[o][0].addEntityToBeDeoptimized(l),this.addArgumentToBeDeoptimized(l)):_?l.deoptimizePath(nn):this.addArgumentToBeDeoptimized(l)}}else this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n),n.length===1&&n[0]===on&&this.scope.getReturnExpression().deoptimizePath(nn)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return n.length>0?this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a):this.async?(this.deoptimizedReturn||(this.deoptimizedReturn=!0,this.scope.getReturnExpression().deoptimizePath(nn),this.context.requestTreeshakingPass()),gn):[this.scope.getReturnExpression(),!1]}hasEffectsOnInteractionAtPath(n,e,r){if(n.length>0||e.type!==2)return this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r);if(this.annotationNoSideEffects)return!1;if(this.async){const{propertyReadSideEffects:a}=this.context.options.treeshake,i=this.scope.getReturnExpression();if(i.hasEffectsOnInteractionAtPath(["then"],gr,r)||a&&(a==="always"||i.hasEffectsOnInteractionAtPath(["then"],Pa,r)))return!0}for(const a of this.params)if(a.hasEffects(r))return!0;return!1}include(n,e){this.deoptimized||this.applyDeoptimizations(),this.included=!0;const{brokenFlow:r}=n;n.brokenFlow=!1,this.body.include(n,e),n.brokenFlow=r}includeCallArguments(n,e){this.scope.includeCallArguments(n,e)}initialise(){this.scope.addParameterVariables(this.params.map(n=>n.declare("parameter",U)),this.params[this.params.length-1]instanceof ui),this.body instanceof Dr?this.body.addImplicitReturnExpressionToScope():this.scope.addReturnExpression(this.body)}parseNode(n){n.body.type===io&&(this.body=new Dr(n.body,this,this.scope.hoistedBodyVarScope)),super.parseNode(n)}addArgumentToBeDeoptimized(n){}applyDeoptimizations(){}}fi.prototype.preventChildBlockScope=!0;class mi extends fi{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new Ao(n,this.context)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!1}hasEffectsOnInteractionAtPath(n,e,r){if(super.hasEffectsOnInteractionAtPath(n,e,r))return!0;if(this.annotationNoSideEffects)return!1;if(e.type===2){const{ignore:a,brokenFlow:i}=r;if(r.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0,this:!1},this.body.hasEffects(r))return!0;r.ignore=a,r.brokenFlow=i}return!1}include(n,e){super.include(n,e);for(const r of this.params)r instanceof cn||r.include(n,e)}getObjectEntity(){return this.objectEntity!==null?this.objectEntity:this.objectEntity=new Bn([],Et)}}function Xt(t,{exportNamesByVariable:n,snippets:{_:e,getObject:r,getPropertyAccess:a}},i=""){if(t.length===1&&n.get(t[0]).length===1){const s=t[0];return`exports('${n.get(s)}',${e}${s.getName(a)}${i})`}{const s=[];for(const o of t)for(const _ of n.get(o))s.push([_,o.getName(a)+i]);return`exports(${r(s,{lineBreakIndent:null})})`}}function pi(t,n,e,r,{exportNamesByVariable:a,snippets:{_:i}}){r.prependRight(n,`exports('${a.get(t)}',${i}`),r.appendLeft(e,")")}function Do(t,n,e,r,a,i){const{_:s,getPropertyAccess:o}=i.snippets;a.appendLeft(e,`,${s}${Xt([t],i)},${s}${t.getName(o)}`),r&&(a.prependRight(n,"("),a.appendLeft(e,")"))}class Fe extends O{addExportedVariables(n,e){for(const r of this.properties)r.type==="Property"?r.value.addExportedVariables(n,e):r.argument.addExportedVariables(n,e)}declare(n,e){const r=[];for(const a of this.properties)r.push(...a.declare(n,e));return r}deoptimizePath(n){if(n.length===0)for(const e of this.properties)e.deoptimizePath(n)}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.properties)if(a.hasEffectsOnInteractionAtPath(X,e,r))return!0;return!1}markDeclarationReached(){for(const n of this.properties)n.markDeclarationReached()}}class ip extends pt{constructor(n){super("arguments",null,U,n),this.deoptimizedArguments=[]}addArgumentToBeDeoptimized(n){this.included?n.deoptimizePath(nn):this.deoptimizedArguments.push(n)}hasEffectsOnInteractionAtPath(n,{type:e}){return e!==0||n.length>1}include(){super.include();for(const n of this.deoptimizedArguments)n.deoptimizePath(nn);this.deoptimizedArguments.length=0}}class Po extends ko{constructor(n){super("this",null,n)}hasEffectsOnInteractionAtPath(n,e,r){return(r.replacedVariableInits.get(this)||U).hasEffectsOnInteractionAtPath(n,e,r)}}class sp extends Ao{constructor(n,e){super(n,e),this.variables.set("arguments",this.argumentsVariable=new ip(e)),this.variables.set("this",this.thisVariable=new Po(e))}findLexicalBoundary(){return this}includeCallArguments(n,e){if(super.includeCallArguments(n,e),this.argumentsVariable.included)for(const r of e)r.included||r.include(n,!1)}}class di extends fi{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new sp(n,this.context),this.constructedEntity=new Bn(Object.create(null),Et),this.scope.thisVariable.addEntityToBeDeoptimized(this.constructedEntity)}deoptimizeArgumentsOnInteractionAtPath(n,e,r){super.deoptimizeArgumentsOnInteractionAtPath(n,e,r),n.type===2&&e.length===0&&n.args[0]&&this.scope.thisVariable.addEntityToBeDeoptimized(n.args[0])}hasEffects(n){var e;return this.deoptimized||this.applyDeoptimizations(),!this.annotationNoSideEffects&&!!((e=this.id)!=null&&e.hasEffects(n))}hasEffectsOnInteractionAtPath(n,e,r){if(super.hasEffectsOnInteractionAtPath(n,e,r))return!0;if(this.annotationNoSideEffects)return!1;if(e.type===2){const a=r.replacedVariableInits.get(this.scope.thisVariable);r.replacedVariableInits.set(this.scope.thisVariable,e.withNew?this.constructedEntity:U);const{brokenFlow:i,ignore:s,replacedVariableInits:o}=r;if(r.ignore={breaks:!1,continues:!1,labels:new Set,returnYield:!0,this:e.withNew},this.body.hasEffects(r))return!0;r.brokenFlow=i,a?o.set(this.scope.thisVariable,a):o.delete(this.scope.thisVariable),r.ignore=s}return!1}include(n,e){var a;super.include(n,e),(a=this.id)==null||a.include();const r=this.scope.argumentsVariable.included;for(const i of this.params)i instanceof cn&&!r||i.include(n,e)}initialise(){var n;super.initialise(),(n=this.id)==null||n.declare("function",this)}addArgumentToBeDeoptimized(n){this.scope.argumentsVariable.addArgumentToBeDeoptimized(n)}getObjectEntity(){return this.objectEntity!==null?this.objectEntity:this.objectEntity=new Bn([{key:"prototype",kind:"init",property:new Bn([],Et)}],Et)}}class Oo extends O{hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(n,e){if(this.deoptimized||this.applyDeoptimizations(),!this.included){this.included=!0;n:if(!this.context.usesTopLevelAwait){let r=this.parent;do if(r instanceof di||r instanceof mi)break n;while(r=r.parent);this.context.usesTopLevelAwait=!0}}this.argument.include(n,e)}}const op={"!=":(t,n)=>t!=n,"!==":(t,n)=>t!==n,"%":(t,n)=>t%n,"&":(t,n)=>t&n,"*":(t,n)=>t*n,"**":(t,n)=>t**n,"+":(t,n)=>t+n,"-":(t,n)=>t-n,"/":(t,n)=>t/n,"<":(t,n)=>t<n,"<<":(t,n)=>t<<n,"<=":(t,n)=>t<=n,"==":(t,n)=>t==n,"===":(t,n)=>t===n,">":(t,n)=>t>n,">=":(t,n)=>t>=n,">>":(t,n)=>t>>n,">>>":(t,n)=>t>>>n,"^":(t,n)=>t^n,"|":(t,n)=>t|n};function zo(t,n,e){if(e.arguments.length>0)if(e.arguments[e.arguments.length-1].included)for(const r of e.arguments)r.render(t,n);else{let r=e.arguments.length-2;for(;r>=0&&!e.arguments[r].included;)r--;if(r>=0){for(let a=0;a<=r;a++)e.arguments[a].render(t,n);t.remove(En(t.original,",",e.arguments[r].end),e.end-1)}else t.remove(En(t.original,"(",e.callee.end)+1,e.end-1)}}class Ut extends O{deoptimizeArgumentsOnInteractionAtPath(){}getLiteralValueAtPath(n){return n.length>0||this.value===null&&this.context.code.charCodeAt(this.start)!==110||typeof this.value=="bigint"||this.context.code.charCodeAt(this.start)===47?mn:this.value}getReturnExpressionWhenCalledAtPath(n){return n.length!==1?gn:je(this.members,n[0])}hasEffectsOnInteractionAtPath(n,e,r){switch(e.type){case 0:return n.length>(this.value===null?0:1);case 1:return!0;case 2:return!!(this.included&&this.value instanceof RegExp&&(this.value.global||this.value.sticky))||n.length!==1||Te(this.members,n[0],e,r)}}initialise(){this.members=function(n){if(n instanceof RegExp)return Dm;switch(typeof n){case"boolean":return Ka;case"number":return Ya;case"string":return Ne}return Object.create(null)}(this.value)}parseNode(n){this.value=n.value,this.regex=n.regex,super.parseNode(n)}render(n){typeof this.value=="string"&&n.indentExclusionRanges.push([this.start+1,this.end-1])}}function _p(t){return t.computed?function(n){return n instanceof Ut?String(n.value):null}(t.property):t.property.name}function Fo(t){const n=t.propertyKey,e=t.object;if(typeof n=="string"){if(e instanceof cn)return[{key:e.name,pos:e.start},{key:n,pos:t.property.start}];if(e instanceof Ct){const r=Fo(e);return r&&[...r,{key:n,pos:t.property.start}]}}return null}class Ct extends O{constructor(){super(...arguments),this.variable=null,this.assignmentDeoptimized=!1,this.bound=!1,this.expressionsToBeDeoptimized=[],this.isUndefined=!1}bind(){this.bound=!0;const n=Fo(this),e=n&&this.scope.findVariable(n[0].key);if(e!=null&&e.isNamespace){const r=Bo(e,n.slice(1),this.context);r?r==="undefined"?this.isUndefined=!0:(this.variable=r,this.scope.addNamespaceMemberAccess(function(a){let i=a[0].key;for(let s=1;s<a.length;s++)i+="."+a[s].key;return i}(n),r)):super.bind()}else super.bind()}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.variable?this.variable.deoptimizeArgumentsOnInteractionAtPath(n,e,r):this.isUndefined||(e.length<7?this.object.deoptimizeArgumentsOnInteractionAtPath(n,[this.getPropertyKey(),...e],r):xt(n))}deoptimizeCache(){const{expressionsToBeDeoptimized:n,object:e}=this;this.expressionsToBeDeoptimized=bn,this.propertyKey=on,e.deoptimizePath(nn);for(const r of n)r.deoptimizeCache()}deoptimizePath(n){if(n.length===0&&this.disallowNamespaceReassignment(),this.variable)this.variable.deoptimizePath(n);else if(!this.isUndefined&&n.length<7){const e=this.getPropertyKey();this.object.deoptimizePath([e===on?hr:e,...n])}}getLiteralValueAtPath(n,e,r){return this.variable?this.variable.getLiteralValueAtPath(n,e,r):this.isUndefined?void 0:this.propertyKey!==on&&n.length<7?(this.expressionsToBeDeoptimized.push(r),this.object.getLiteralValueAtPath([this.getPropertyKey(),...n],e,r)):mn}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.variable?this.variable.getReturnExpressionWhenCalledAtPath(n,e,r,a):this.isUndefined?[ie,!1]:this.propertyKey!==on&&n.length<7?(this.expressionsToBeDeoptimized.push(a),this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(),...n],e,r,a)):gn}hasEffects(n){return this.deoptimized||this.applyDeoptimizations(),this.property.hasEffects(n)||this.object.hasEffects(n)||this.hasAccessEffect(n)}hasEffectsAsAssignmentTarget(n,e){return e&&!this.deoptimized&&this.applyDeoptimizations(),this.assignmentDeoptimized||this.applyAssignmentDeoptimization(),this.property.hasEffects(n)||this.object.hasEffects(n)||e&&this.hasAccessEffect(n)||this.hasEffectsOnInteractionAtPath(X,this.assignmentInteraction,n)}hasEffectsOnInteractionAtPath(n,e,r){return this.variable?this.variable.hasEffectsOnInteractionAtPath(n,e,r):!!this.isUndefined||!(n.length<7)||this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(),...n],e,r)}include(n,e){this.deoptimized||this.applyDeoptimizations(),this.includeProperties(n,e)}includeAsAssignmentTarget(n,e,r){this.assignmentDeoptimized||this.applyAssignmentDeoptimization(),r?this.include(n,e):this.includeProperties(n,e)}includeCallArguments(n,e){this.variable?this.variable.includeCallArguments(n,e):super.includeCallArguments(n,e)}initialise(){this.propertyKey=_p(this),this.accessInteraction={args:[this.object],type:0}}isSkippedAsOptional(n){var e,r;return!this.variable&&!this.isUndefined&&(((r=(e=this.object).isSkippedAsOptional)==null?void 0:r.call(e,n))||this.optional&&this.object.getLiteralValueAtPath(X,xn,n)==null)}render(n,e,{renderedParentType:r,isCalleeOfRenderedParent:a,renderedSurroundingElement:i}=In){if(this.variable||this.isUndefined){const{snippets:{getPropertyAccess:s}}=e;let o=this.variable?this.variable.getName(s):"undefined";r&&a&&(o="0, "+o),n.overwrite(this.start,this.end,o,{contentOnly:!0,storeName:!0})}else r&&a&&n.appendRight(this.start,"0, "),this.object.render(n,e,{renderedSurroundingElement:i}),this.property.render(n,e)}setAssignedValue(n){this.assignmentInteraction={args:[this.object,n],type:1}}applyDeoptimizations(){this.deoptimized=!0;const{propertyReadSideEffects:n}=this.context.options.treeshake;if(this.bound&&n&&!this.variable&&!this.isUndefined){const e=this.getPropertyKey();this.object.deoptimizeArgumentsOnInteractionAtPath(this.accessInteraction,[e],xn),this.context.requestTreeshakingPass()}}applyAssignmentDeoptimization(){this.assignmentDeoptimized=!0;const{propertyReadSideEffects:n}=this.context.options.treeshake;this.bound&&n&&!this.variable&&!this.isUndefined&&(this.object.deoptimizeArgumentsOnInteractionAtPath(this.assignmentInteraction,[this.getPropertyKey()],xn),this.context.requestTreeshakingPass())}disallowNamespaceReassignment(){this.object instanceof cn&&this.scope.findVariable(this.object.name).isNamespace&&(this.variable&&this.context.includeVariableInModule(this.variable),this.context.log(V,Qs(this.object.name,this.context.module.id),this.start))}getPropertyKey(){if(this.propertyKey===null){this.propertyKey=on;const n=this.property.getLiteralValueAtPath(X,xn,this);return this.propertyKey=n===Ma?n:typeof n=="symbol"?on:String(n)}return this.propertyKey}hasAccessEffect(n){const{propertyReadSideEffects:e}=this.context.options.treeshake;return!(this.variable||this.isUndefined)&&e&&(e==="always"||this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()],this.accessInteraction,n))}includeProperties(n,e){this.included||(this.included=!0,this.variable&&this.context.includeVariableInModule(this.variable)),this.object.include(n,e),this.property.include(n,e)}}function Bo(t,n,e){if(n.length===0)return t;if(!t.isNamespace||t instanceof br)return null;const r=n[0].key,a=t.context.traceExport(r);if(!a){if(n.length===1){const i=t.context.fileName;return e.log(V,$r(r,e.module.id,i),n[0].pos),"undefined"}return null}return Bo(a,n.slice(1),e)}class Go extends O{constructor(){super(...arguments),this.returnExpression=null,this.deoptimizableDependentExpressions=[],this.expressionsToBeDeoptimized=new Set}deoptimizeArgumentsOnInteractionAtPath(n,e,r){const{args:a}=n,[i,s]=this.getReturnExpression(r);if(s)return;const o=a.filter(_=>!!_&&_!==U);if(o.length!==0)if(i===U)for(const _ of o)_.deoptimizePath(nn);else r.withTrackedEntityAtPath(e,i,()=>{for(const _ of o)this.expressionsToBeDeoptimized.add(_);i.deoptimizeArgumentsOnInteractionAtPath(n,e,r)},null)}deoptimizeCache(){var n;if(((n=this.returnExpression)==null?void 0:n[0])!==U){this.returnExpression=gn;const{deoptimizableDependentExpressions:e,expressionsToBeDeoptimized:r}=this;this.expressionsToBeDeoptimized=Ds,this.deoptimizableDependentExpressions=bn;for(const a of e)a.deoptimizeCache();for(const a of r)a.deoptimizePath(nn)}}deoptimizePath(n){if(n.length===0||this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(n,this))return;const[e]=this.getReturnExpression();e!==U&&e.deoptimizePath(n)}getLiteralValueAtPath(n,e,r){const[a]=this.getReturnExpression(e);return a===U?mn:e.withTrackedEntityAtPath(n,a,()=>(this.deoptimizableDependentExpressions.push(r),a.getLiteralValueAtPath(n,e,r)),mn)}getReturnExpressionWhenCalledAtPath(n,e,r,a){const i=this.getReturnExpression(r);return i[0]===U?i:r.withTrackedEntityAtPath(n,i,()=>{this.deoptimizableDependentExpressions.push(a);const[s,o]=i[0].getReturnExpressionWhenCalledAtPath(n,e,r,a);return[s,o||i[1]]},gn)}hasEffectsOnInteractionAtPath(n,e,r){const{type:a}=e;if(a===2){const{args:o,withNew:_}=e;if((_?r.instantiated:r.called).trackEntityAtPathAndGetIfTracked(n,o,this))return!1}else if((a===1?r.assigned:r.accessed).trackEntityAtPathAndGetIfTracked(n,this))return!1;const[i,s]=this.getReturnExpression();return(a===1||!s)&&i.hasEffectsOnInteractionAtPath(n,e,r)}}class Ro extends Go{bind(){super.bind(),this.callee instanceof cn&&(this.scope.findVariable(this.callee.name).isNamespace&&this.context.log(V,Zs(this.callee.name),this.start),this.callee.name==="eval"&&this.context.log(V,{code:"EVAL",id:n=this.context.module.id,message:`Use of eval in "${H(n)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,url:wn("troubleshooting/#avoiding-eval")},this.start));var n;this.interaction={args:[this.callee instanceof Ct&&!this.callee.variable?this.callee.object:null,...this.arguments],type:2,withNew:!1}}hasEffects(n){try{for(const e of this.arguments)if(e.hasEffects(n))return!0;return!this.annotationPure&&(this.callee.hasEffects(n)||this.callee.hasEffectsOnInteractionAtPath(X,this.interaction,n))}finally{this.deoptimized||this.applyDeoptimizations()}}include(n,e){this.deoptimized||this.applyDeoptimizations(),e?(super.include(n,e),e===uo&&this.callee instanceof cn&&this.callee.variable&&this.callee.variable.markCalledFromTryStatement()):(this.included=!0,this.callee.include(n,!1)),this.callee.includeCallArguments(n,this.arguments)}isSkippedAsOptional(n){var e,r;return((r=(e=this.callee).isSkippedAsOptional)==null?void 0:r.call(e,n))||this.optional&&this.callee.getLiteralValueAtPath(X,xn,n)==null}render(n,e,{renderedSurroundingElement:r}=In){this.callee.render(n,e,{isCalleeOfRenderedParent:!0,renderedSurroundingElement:r}),zo(n,e,this)}applyDeoptimizations(){this.deoptimized=!0,this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction,X,xn),this.context.requestTreeshakingPass()}getReturnExpression(n=xn){return this.returnExpression===null?(this.returnExpression=gn,this.returnExpression=this.callee.getReturnExpressionWhenCalledAtPath(X,this.interaction,n,this)):this.returnExpression}}class lp extends So{addDeclaration(n,e,r,a){const i=this.variables.get(n.name);return i?(this.parent.addDeclaration(n,e,ie,a),i.addDeclaration(n,r),i):this.parent.addDeclaration(n,e,r,a)}}class cp extends Kn{constructor(n,e,r){super(n),this.variables.set("this",this.thisVariable=new pt("this",null,e,r)),this.instanceScope=new Kn(this),this.instanceScope.variables.set("this",new Po(r))}findLexicalBoundary(){return this}}class qo extends O{constructor(){super(...arguments),this.accessedValue=null}deoptimizeArgumentsOnInteractionAtPath(n,e,r){return n.type===0&&this.kind==="get"&&e.length===0||n.type===1&&this.kind==="set"&&e.length===0?this.value.deoptimizeArgumentsOnInteractionAtPath({args:n.args,type:2,withNew:!1},X,r):void this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeCache(){}deoptimizePath(n){this.getAccessedValue()[0].deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getAccessedValue()[0].getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffects(n){return this.key.hasEffects(n)}hasEffectsOnInteractionAtPath(n,e,r){return this.kind==="get"&&e.type===0&&n.length===0||this.kind==="set"&&e.type===1?this.value.hasEffectsOnInteractionAtPath(X,{args:e.args,type:2,withNew:!1},r):this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(n,e,r)}applyDeoptimizations(){}getAccessedValue(){return this.accessedValue===null?this.kind==="get"?(this.accessedValue=gn,this.accessedValue=this.value.getReturnExpressionWhenCalledAtPath(X,gr,xn,this)):this.accessedValue=[this.value,!1]:this.accessedValue}}class hi extends qo{applyDeoptimizations(){}}class up extends qn{constructor(n,e){super(),this.object=n,this.key=e}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.object.deoptimizeArgumentsOnInteractionAtPath(n,[this.key,...e],r)}deoptimizePath(n){this.object.deoptimizePath([this.key,...n])}getLiteralValueAtPath(n,e,r){return this.object.getLiteralValueAtPath([this.key,...n],e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.object.getReturnExpressionWhenCalledAtPath([this.key,...n],e,r,a)}hasEffectsOnInteractionAtPath(n,e,r){return this.object.hasEffectsOnInteractionAtPath([this.key,...n],e,r)}}class Vo extends O{constructor(){super(...arguments),this.objectEntity=null}createScope(n){this.scope=new Kn(n)}deoptimizeArgumentsOnInteractionAtPath(n,e,r){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(n,e,r)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(n){this.getObjectEntity().deoptimizePath(n)}getLiteralValueAtPath(n,e,r){return this.getObjectEntity().getLiteralValueAtPath(n,e,r)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(n,e,r,a)}hasEffects(n){var r,a;this.deoptimized||this.applyDeoptimizations();const e=((r=this.superClass)==null?void 0:r.hasEffects(n))||this.body.hasEffects(n);return(a=this.id)==null||a.markDeclarationReached(),e||super.hasEffects(n)}hasEffectsOnInteractionAtPath(n,e,r){var a;return e.type===2&&n.length===0?!e.withNew||(this.classConstructor===null?(a=this.superClass)==null?void 0:a.hasEffectsOnInteractionAtPath(n,e,r):this.classConstructor.hasEffectsOnInteractionAtPath(n,e,r))||!1:this.getObjectEntity().hasEffectsOnInteractionAtPath(n,e,r)}include(n,e){var r;this.deoptimized||this.applyDeoptimizations(),this.included=!0,(r=this.superClass)==null||r.include(n,e),this.body.include(n,e),this.id&&(this.id.markDeclarationReached(),this.id.include())}initialise(){var n;(n=this.id)==null||n.declare("class",this);for(const e of this.body.body)if(e instanceof hi&&e.kind==="constructor")return void(this.classConstructor=e);this.classConstructor=null}applyDeoptimizations(){this.deoptimized=!0;for(const n of this.body.body)n.static||n instanceof hi&&n.kind==="constructor"||n.deoptimizePath(nn);this.context.requestTreeshakingPass()}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;const n=[],e=[];for(const r of this.body.body){const a=r.static?n:e,i=r.kind;if(a===e&&!i)continue;const s=i==="set"||i==="get"?i:"init";let o;if(r.computed){const _=r.key.getLiteralValueAtPath(X,xn,this);if(typeof _=="symbol"){a.push({key:on,kind:s,property:r});continue}o=String(_)}else o=r.key instanceof cn?r.key.name:String(r.key.value);a.push({key:o,kind:s,property:r})}return n.unshift({key:"prototype",kind:"init",property:new Bn(e,this.superClass?new up(this.superClass,"prototype"):Et)}),this.objectEntity=new Bn(n,this.superClass||Et)}}class Pr extends Vo{initialise(){super.initialise(),this.id!==null&&(this.id.variable.isId=!0)}parseNode(n){n.id!==null&&(this.id=new cn(n.id,this,this.scope.parent)),super.parseNode(n)}render(n,e){var o;const{exportNamesByVariable:r,format:a,snippets:{_:i,getPropertyAccess:s}}=e;if(this.id){const{variable:_,name:l}=this.id;a==="system"&&r.has(_)&&n.appendLeft(this.end,`${i}${Xt([_],e)};`);const u=_.getName(s);if(u!==l)return(o=this.superClass)==null||o.render(n,e),this.body.render(n,{...e,useOriginalName:f=>f===_}),n.prependRight(this.start,`let ${u}${i}=${i}`),void n.prependLeft(this.end,";")}super.render(n,e)}applyDeoptimizations(){super.applyDeoptimizations();const{id:n,scope:e}=this;if(n){const{name:r,variable:a}=n;for(const i of e.accessedOutsideVariables.values())i!==a&&i.forbidName(r)}}}class gi extends Vo{render(n,e,{renderedSurroundingElement:r}=In){super.render(n,e),r===Vn&&(n.appendRight(this.start,"("),n.prependLeft(this.end,")"))}}class Or extends qn{constructor(n){super(),this.expressions=n,this.included=!1}deoptimizePath(n){for(const e of this.expressions)e.deoptimizePath(n)}getReturnExpressionWhenCalledAtPath(n,e,r,a){return[new Or(this.expressions.map(i=>i.getReturnExpressionWhenCalledAtPath(n,e,r,a)[0])),!1]}hasEffectsOnInteractionAtPath(n,e,r){for(const a of this.expressions)if(a.hasEffectsOnInteractionAtPath(n,e,r))return!0;return!1}}function zr(t,n){const{brokenFlow:e,hasBreak:r,hasContinue:a,ignore:i}=t,{breaks:s,continues:o}=i;return i.breaks=!0,i.continues=!0,t.hasBreak=!1,t.hasContinue=!1,!!n.hasEffects(t)||(i.breaks=s,i.continues=o,t.hasBreak=r,t.hasContinue=a,t.brokenFlow=e,!1)}function Be(t,n,e){const{brokenFlow:r,hasBreak:a,hasContinue:i}=t;t.hasBreak=!1,t.hasContinue=!1,n.include(t,e,{asSingleStatement:!0}),t.hasBreak=a,t.hasContinue=i,t.brokenFlow=r}class bi extends O{hasEffects(){return!1}initialise(){this.context.addExport(this)}render(n,e,r){n.remove(r.start,r.end)}applyDeoptimizations(){}}bi.prototype.needsBoundaries=!0;class Ge extends di{initialise(){super.initialise(),this.id!==null&&(this.id.variable.isId=!0)}parseNode(n){n.id!==null&&(this.id=new cn(n.id,this,this.scope.parent)),super.parseNode(n)}}class Fr extends O{include(n,e){super.include(n,e),e&&this.context.includeVariableInModule(this.variable)}initialise(){const n=this.declaration;this.declarationName=n.id&&n.id.name||this.declaration.name,this.variable=this.scope.addExportDefaultDeclaration(this.declarationName||this.context.getModuleName(),this,this.context),this.context.addExport(this)}render(n,e,r){const{start:a,end:i}=r,s=function(o,_){return wt(o,En(o,"default",_)+7)}(n.original,this.start);if(this.declaration instanceof Ge)this.renderNamedDeclaration(n,s,this.declaration.id===null?function(o,_){const l=En(o,"function",_)+8;o=o.slice(l,En(o,"(",l));const u=En(o,"*");return u===-1?l:l+u+1}(n.original,s):null,e);else if(this.declaration instanceof Pr)this.renderNamedDeclaration(n,s,this.declaration.id===null?En(n.original,"class",a)+5:null,e);else{if(this.variable.getOriginalVariable()!==this.variable)return void ci(this,n,a,i);if(!this.variable.included)return n.remove(this.start,s),this.declaration.render(n,e,{renderedSurroundingElement:Vn}),void(n.original[this.end-1]!==";"&&n.appendLeft(this.end,";"));this.renderVariableDeclaration(n,s,e)}this.declaration.render(n,e)}applyDeoptimizations(){}renderNamedDeclaration(n,e,r,a){const{exportNamesByVariable:i,format:s,snippets:{getPropertyAccess:o}}=a,_=this.variable.getName(o);n.remove(this.start,e),r!==null&&n.appendLeft(r,` ${_}`),s==="system"&&this.declaration instanceof Pr&&i.has(this.variable)&&n.appendLeft(this.end,` ${Xt([this.variable],a)};`)}renderVariableDeclaration(n,e,{format:r,exportNamesByVariable:a,snippets:{cnst:i,getPropertyAccess:s}}){const o=n.original.charCodeAt(this.end-1)===59,_=r==="system"&&a.get(this.variable);_?(n.overwrite(this.start,e,`${i} ${this.variable.getName(s)} = exports('${_[0]}', `),n.appendRight(o?this.end-1:this.end,")"+(o?"":";"))):(n.overwrite(this.start,e,`${i} ${this.variable.getName(s)} = `),o||n.appendLeft(this.end,";"))}}Fr.prototype.needsBoundaries=!0;class Xo extends O{bind(){var n;(n=this.declaration)==null||n.bind()}hasEffects(n){var e;return!!((e=this.declaration)!=null&&e.hasEffects(n))}initialise(){this.context.addExport(this)}render(n,e,r){const{start:a,end:i}=r;this.declaration===null?n.remove(a,i):(n.remove(this.start,this.declaration.start),this.declaration.render(n,e,{end:i,start:a}))}applyDeoptimizations(){}}Xo.prototype.needsBoundaries=!0;class Uo extends di{render(n,e,{renderedSurroundingElement:r}=In){super.render(n,e),r===Vn&&(n.appendRight(this.start,"("),n.prependLeft(this.end,")"))}}class Ho extends qt{constructor(){super(...arguments),this.hoistedDeclarations=[]}addDeclaration(n,e,r,a){return this.hoistedDeclarations.push(n),super.addDeclaration(n,e,r,a)}}const Wo=Symbol("unset");class vi extends O{constructor(){super(...arguments),this.testValue=Wo}deoptimizeCache(){this.testValue=mn}hasEffects(n){var r;if(this.test.hasEffects(n))return!0;const e=this.getTestValue();if(typeof e=="symbol"){const{brokenFlow:a}=n;if(this.consequent.hasEffects(n))return!0;const i=n.brokenFlow;return n.brokenFlow=a,this.alternate===null?!1:!!this.alternate.hasEffects(n)||(n.brokenFlow=n.brokenFlow&&i,!1)}return e?this.consequent.hasEffects(n):!!((r=this.alternate)!=null&&r.hasEffects(n))}include(n,e){if(this.included=!0,e)this.includeRecursively(e,n);else{const r=this.getTestValue();typeof r=="symbol"?this.includeUnknownTest(n):this.includeKnownTest(n,r)}}parseNode(n){this.consequentScope=new Ho(this.scope),this.consequent=new(this.context.getNodeConstructor(n.consequent.type))(n.consequent,this,this.consequentScope),n.alternate&&(this.alternateScope=new Ho(this.scope),this.alternate=new(this.context.getNodeConstructor(n.alternate.type))(n.alternate,this,this.alternateScope)),super.parseNode(n)}render(n,e){const{snippets:{getPropertyAccess:r}}=e,a=this.getTestValue(),i=[],s=this.test.included,o=!this.context.options.treeshake;s?this.test.render(n,e):n.remove(this.start,this.consequent.start),this.consequent.included&&(o||typeof a=="symbol"||a)?this.consequent.render(n,e):(n.overwrite(this.consequent.start,this.consequent.end,s?";":""),i.push(...this.consequentScope.hoistedDeclarations)),this.alternate&&(!this.alternate.included||!o&&typeof a!="symbol"&&a?(s&&this.shouldKeepAlternateBranch()?n.overwrite(this.alternate.start,this.end,";"):n.remove(this.consequent.end,this.end),i.push(...this.alternateScope.hoistedDeclarations)):(s?n.original.charCodeAt(this.alternate.start-1)===101&&n.prependLeft(this.alternate.start," "):n.remove(this.consequent.end,this.alternate.start),this.alternate.render(n,e))),this.renderHoistedDeclarations(i,n,r)}applyDeoptimizations(){}getTestValue(){return this.testValue===Wo?this.testValue=this.test.getLiteralValueAtPath(X,xn,this):this.testValue}includeKnownTest(n,e){var r;this.test.shouldBeIncluded(n)&&this.test.include(n,!1),e&&this.consequent.shouldBeIncluded(n)&&this.consequent.include(n,!1,{asSingleStatement:!0}),!e&&((r=this.alternate)!=null&&r.shouldBeIncluded(n))&&this.alternate.include(n,!1,{asSingleStatement:!0})}includeRecursively(n,e){var r;this.test.include(e,n),this.consequent.include(e,n),(r=this.alternate)==null||r.include(e,n)}includeUnknownTest(n){var a;this.test.include(n,!1);const{brokenFlow:e}=n;let r=!1;this.consequent.shouldBeIncluded(n)&&(this.consequent.include(n,!1,{asSingleStatement:!0}),r=n.brokenFlow,n.brokenFlow=e),(a=this.alternate)!=null&&a.shouldBeIncluded(n)&&(this.alternate.include(n,!1,{asSingleStatement:!0}),n.brokenFlow=n.brokenFlow&&r)}renderHoistedDeclarations(n,e,r){const a=[...new Set(n.map(i=>{const s=i.variable;return s.included?s.getName(r):""}))].filter(Boolean).join(", ");if(a){const i=this.parent.type,s=i!==wr&&i!==io;e.prependRight(this.start,`${s?"{ ":""}var ${a}; `),s&&e.appendLeft(this.end," }")}}shouldKeepAlternateBranch(){let n=this.parent;do{if(n instanceof vi&&n.alternate)return!0;if(n instanceof Dr)return!1;n=n.parent}while(n);return!1}}class Jo extends O{bind(){}hasEffects(){return!1}initialise(){this.context.addImport(this)}render(n,e,r){n.remove(r.start,r.end)}applyDeoptimizations(){}}Jo.prototype.needsBoundaries=!0;class Ko extends O{applyDeoptimizations(){}}const yi="_interopDefault",xi="_interopDefaultCompat",Br="_interopNamespace",Gr="_interopNamespaceCompat",Ht="_interopNamespaceDefault",Re="_interopNamespaceDefaultOnly",Rr="_mergeNamespaces",qr={auto:yi,compat:xi,default:null,defaultOnly:null,esModule:null},Vr=(t,n)=>t==="esModule"||n&&(t==="auto"||t==="compat"),qe={auto:Br,compat:Gr,default:Ht,defaultOnly:Re,esModule:null},fp=(t,n)=>t!=="esModule"&&Vr(t,n),$i=(t,n,e,r,a,i,s)=>{const o=new Set(t);for(const _ of Ci)n.has(_)&&o.add(_);return Ci.map(_=>o.has(_)?Yo[_](e,r,a,i,s,o):"").join("")},Yo={[xi](t,n,e){const{_:r,getDirectReturnFunction:a,n:i}=n,[s,o]=a(["e"],{functionReturn:!0,lineBreakIndent:null,name:xi});return`${s}${Ei(n)}${r}?${r}${e?Zo(n):Qo(n)}${o}${i}${i}`},[yi](t,n,e){const{_:r,getDirectReturnFunction:a,n:i}=n,[s,o]=a(["e"],{functionReturn:!0,lineBreakIndent:null,name:yi});return`${s}e${r}&&${r}e.__esModule${r}?${r}${e?Zo(n):Qo(n)}${o}${i}${i}`},[Gr](t,n,e,r,a,i){const{_:s,getDirectReturnFunction:o,n:_}=n;if(i.has(Ht)){const[l,u]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:Gr});return`${l}${Ei(n)}${s}?${s}e${s}:${s}${Ht}(e)${u}${_}${_}`}return`function ${Gr}(e)${s}{${_}${t}if${s}(${Ei(n)})${s}return e;${_}`+ki(t,t,n,e,r,a)+`}${_}${_}`},[Re](t,n,e,r,a){const{getDirectReturnFunction:i,getObject:s,n:o}=n,[_,l]=i(["e"],{functionReturn:!0,lineBreakIndent:null,name:Re});return`${_}${wi(r,e_(a,s([["__proto__","null"],["default","e"]],{lineBreakIndent:null}),n))}${l}${o}${o}`},[Ht](t,n,e,r,a){const{_:i,n:s}=n;return`function ${Ht}(e)${i}{${s}`+ki(t,t,n,e,r,a)+`}${s}${s}`},[Br](t,n,e,r,a,i){const{_:s,getDirectReturnFunction:o,n:_}=n;if(i.has(Ht)){const[l,u]=o(["e"],{functionReturn:!0,lineBreakIndent:null,name:Br});return`${l}e${s}&&${s}e.__esModule${s}?${s}e${s}:${s}${Ht}(e)${u}${_}${_}`}return`function ${Br}(e)${s}{${_}${t}if${s}(e${s}&&${s}e.__esModule)${s}return e;${_}`+ki(t,t,n,e,r,a)+`}${_}${_}`},[Rr](t,n,e,r,a){const{_:i,cnst:s,n:o}=n,_=s==="var"&&e;return`function ${Rr}(n, m)${i}{${o}${t}${pp(`{${o}${t}${t}${t}if${i}(k${i}!==${i}'default'${i}&&${i}!(k in n))${i}{${o}`+(e?_?n_:hp:t_)(t,t+t+t+t,n)+`${t}${t}${t}}${o}${t}${t}}`,_,t,n)}${o}${t}return ${wi(r,e_(a,"n",n))};${o}}${o}${o}`}},Zo=({_:t,getObject:n})=>`e${t}:${t}${n([["default","e"]],{lineBreakIndent:null})}`,Qo=({_:t,getPropertyAccess:n})=>`e${n("default")}${t}:${t}e`,Ei=({_:t})=>`e${t}&&${t}typeof e${t}===${t}'object'${t}&&${t}'default'${t}in e`,ki=(t,n,e,r,a,i)=>{const{_:s,cnst:o,getObject:_,getPropertyAccess:l,n:u,s:f}=e,m=`{${u}`+(r?dp:t_)(t,n+t+t,e)+`${n}${t}}`;return`${n}${o} n${s}=${s}Object.create(null${i?`,${s}{${s}[Symbol.toStringTag]:${s}${Ve(_)}${s}}`:""});${u}${n}if${s}(e)${s}{${u}${n}${t}${mp(m,!r,e)}${u}${n}}${u}${n}n${l("default")}${s}=${s}e;${u}${n}return ${wi(a,"n")}${f}${u}`},mp=(t,n,{_:e,cnst:r,getFunctionIntro:a,s:i})=>r!=="var"||n?`for${e}(${r} k in e)${e}${t}`:`Object.keys(e).forEach(${a(["k"],{isAsync:!1,name:null})}${t})${i}`,pp=(t,n,e,{_:r,cnst:a,getDirectReturnFunction:i,getFunctionIntro:s,n:o})=>{if(n){const[_,l]=i(["e"],{functionReturn:!1,lineBreakIndent:{base:e,t:e},name:null});return`m.forEach(${_}e${r}&&${r}typeof e${r}!==${r}'string'${r}&&${r}!Array.isArray(e)${r}&&${r}Object.keys(e).forEach(${s(["k"],{isAsync:!1,name:null})}${t})${l});`}return`for${r}(var i${r}=${r}0;${r}i${r}<${r}m.length;${r}i++)${r}{${o}${e}${e}${a} e${r}=${r}m[i];${o}${e}${e}if${r}(typeof e${r}!==${r}'string'${r}&&${r}!Array.isArray(e))${r}{${r}for${r}(${a} k in e)${r}${t}${r}}${o}${e}}`},dp=(t,n,e)=>{const{_:r,n:a}=e;return`${n}if${r}(k${r}!==${r}'default')${r}{${a}`+n_(t,n+t,e)+`${n}}${a}`},n_=(t,n,{_:e,cnst:r,getDirectReturnFunction:a,n:i})=>{const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${n}${r} d${e}=${e}Object.getOwnPropertyDescriptor(e,${e}k);${i}${n}Object.defineProperty(n,${e}k,${e}d.get${e}?${e}d${e}:${e}{${i}${n}${t}enumerable:${e}true,${i}${n}${t}get:${e}${s}e[k]${o}${i}${n}});${i}`},hp=(t,n,{_:e,cnst:r,getDirectReturnFunction:a,n:i})=>{const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`${n}${r} d${e}=${e}Object.getOwnPropertyDescriptor(e,${e}k);${i}${n}if${e}(d)${e}{${i}${n}${t}Object.defineProperty(n,${e}k,${e}d.get${e}?${e}d${e}:${e}{${i}${n}${t}${t}enumerable:${e}true,${i}${n}${t}${t}get:${e}${s}e[k]${o}${i}${n}${t}});${i}${n}}${i}`},t_=(t,n,{_:e,n:r})=>`${n}n[k]${e}=${e}e[k];${r}`,wi=(t,n)=>t?`Object.freeze(${n})`:n,e_=(t,n,{_:e,getObject:r})=>t?`Object.defineProperty(${n},${e}Symbol.toStringTag,${e}${Ve(r)})`:n,Ci=Object.keys(Yo);function Ve(t){return t([["value","'Module'"]],{lineBreakIndent:null})}function r_(t,n){return t.renderBaseName!==null&&n.has(t)&&t.isReassigned}class a_ extends O{declareDeclarator(n){this.id.declare(n,this.init||ie)}deoptimizePath(n){this.id.deoptimizePath(n)}hasEffects(n){var r;this.deoptimized||this.applyDeoptimizations();const e=(r=this.init)==null?void 0:r.hasEffects(n);return this.id.markDeclarationReached(),e||this.id.hasEffects(n)}include(n,e){const{deoptimized:r,id:a,init:i}=this;r||this.applyDeoptimizations(),this.included=!0,i==null||i.include(n,e),a.markDeclarationReached(),(e||a.shouldBeIncluded(n))&&a.include(n,e)}render(n,e){const{exportNamesByVariable:r,snippets:{_:a,getPropertyAccess:i}}=e,{end:s,id:o,init:_,start:l}=this,u=o.included;if(u)o.render(n,e);else{const f=En(n.original,"=",o.end);n.remove(l,wt(n.original,f+1))}_?(o instanceof cn&&_ instanceof gi&&!_.id&&o.variable.getName(i)!==o.name&&n.appendLeft(_.start+5,` ${o.name}`),_.render(n,e,u?In:{renderedSurroundingElement:Vn})):o instanceof cn&&r_(o.variable,r)&&n.appendLeft(s,`${a}=${a}void 0`)}applyDeoptimizations(){this.deoptimized=!0;const{id:n,init:e}=this;if(e&&n instanceof cn&&e instanceof gi&&!e.id){const{name:r,variable:a}=n;for(const i of e.scope.accessedOutsideVariables.values())i!==a&&i.forbidName(r)}}}function i_(t,n,e){return n==="external"?qe[e(t instanceof fn?t.id:null)]:n==="default"?Re:null}const gp={amd:["require"],cjs:["require"],system:["module"]};function s_(t){const n=[];for(const e of t.properties){if(e.type==="RestElement"||e.computed||e.key.type!=="Identifier")return;n.push(e.key.name)}return n}class o_ extends O{applyDeoptimizations(){}}const Si="ROLLUP_FILE_URL_",Ai="import",bp={amd:["document","module","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module"],umd:["document","require","URL"]},vp={amd:["document","require","URL"],cjs:["document","require","URL"],es:[],iife:["document","URL"],system:["module","URL"],umd:["document","require","URL"]},Xe=(t,n="URL")=>`new ${n}(${t}).href`,Ii=(t,n=!1)=>Xe(`'${pr(t)}', ${n?"typeof document === 'undefined' ? location.href : ":""}document.currentScript && document.currentScript.src || document.baseURI`),Xr=t=>(n,{chunkId:e})=>{const r=t(e);return n===null?`({ url: ${r} })`:n==="url"?r:"undefined"},Ni=t=>`require('u' + 'rl').pathToFileURL(${t}).href`,__=t=>Ni(`__dirname + '/${t}'`),Ti=(t,n=!1)=>`${n?"typeof document === 'undefined' ? location.href : ":""}(document.currentScript && document.currentScript.src || new URL('${pr(t)}', document.baseURI).href)`,yp={amd:t=>(t[0]!=="."&&(t="./"+t),Xe(`require.toUrl('${t}'), document.baseURI`)),cjs:t=>`(typeof document === 'undefined' ? ${__(t)} : ${Ii(t)})`,es:t=>Xe(`'${t}', import.meta.url`),iife:t=>Ii(t),system:t=>Xe(`'${t}', module.meta.url`),umd:t=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${__(t)} : ${Ii(t,!0)})`},ji={amd:Xr(()=>Xe("module.uri, document.baseURI")),cjs:Xr(t=>`(typeof document === 'undefined' ? ${Ni("__filename")} : ${Ti(t)})`),iife:Xr(t=>Ti(t)),system:(t,{snippets:{getPropertyAccess:n}})=>t===null?"module.meta":`module.meta${n(t)}`,umd:Xr(t=>`(typeof document === 'undefined' && typeof location === 'undefined' ? ${Ni("__filename")} : ${Ti(t,!0)})`)};class l_ extends O{constructor(){super(...arguments),this.hasCachedEffect=null,this.hasLoggedEffect=!1}hasCachedEffects(){return!!this.included&&(this.hasCachedEffect===null?this.hasCachedEffect=this.hasEffects(Er()):this.hasCachedEffect)}hasEffects(n){for(const e of this.body)if(e.hasEffects(n)){if(this.context.options.experimentalLogSideEffects&&!this.hasLoggedEffect){this.hasLoggedEffect=!0;const{code:r,log:a,module:i}=this.context;a(Ot,Nm(r,i.id,Fa(r,e.start,{offsetLine:1})),e.start)}return this.hasCachedEffect=!0}return!1}include(n,e){this.included=!0;for(const r of this.body)(e||r.shouldBeIncluded(n))&&r.include(n,e)}render(n,e){let r=this.start;if(n.original.startsWith("#!")&&(r=Math.min(n.original.indexOf(`
`)+1,this.end),n.remove(0,r)),this.body.length>0){for(;n.original[r]==="/"&&/[*/]/.test(n.original[r+1]);){const a=Oe(n.original.slice(r,this.body[0].start));if(a[0]===-1)break;r+=a[1]}ze(this.body,n,r,this.end,e)}else super.render(n,e)}applyDeoptimizations(){}}class c_ extends O{hasEffects(n){var e;if((e=this.test)!=null&&e.hasEffects(n))return!0;for(const r of this.consequent){if(n.brokenFlow)break;if(r.hasEffects(n))return!0}return!1}include(n,e){var r;this.included=!0,(r=this.test)==null||r.include(n,e);for(const a of this.consequent)(e||a.shouldBeIncluded(n))&&a.include(n,e)}render(n,e,r){if(this.consequent.length>0){this.test&&this.test.render(n,e);const a=this.test?this.test.end:En(n.original,"default",this.start)+7,i=En(n.original,":",a)+1;ze(this.consequent,n,i,r.end,e)}else super.render(n,e)}}c_.prototype.needsBoundaries=!0;class u_ extends O{deoptimizeArgumentsOnInteractionAtPath(){}getLiteralValueAtPath(n){return n.length>0||this.quasis.length!==1?mn:this.quasis[0].value.cooked}getReturnExpressionWhenCalledAtPath(n){return n.length!==1?gn:je(Ne,n[0])}hasEffectsOnInteractionAtPath(n,e,r){return e.type===0?n.length>1:e.type!==2||n.length!==1||Te(Ne,n[0],e,r)}render(n,e){n.indentExclusionRanges.push([this.start,this.end]),super.render(n,e)}}class f_ extends Pt{constructor(){super("undefined")}getLiteralValueAtPath(){}}class it extends pt{constructor(n,e,r){super(n,e,e.declaration,r),this.hasId=!1,this.originalId=null,this.originalVariable=null;const a=e.declaration;(a instanceof Ge||a instanceof Pr)&&a.id?(this.hasId=!0,this.originalId=a.id):a instanceof cn&&(this.originalId=a)}addReference(n){this.hasId||(this.name=n.name)}forbidName(n){const e=this.getOriginalVariable();e===this?super.forbidName(n):e.forbidName(n)}getAssignedVariableName(){return this.originalId&&this.originalId.name||null}getBaseVariableName(){const n=this.getOriginalVariable();return n===this?super.getBaseVariableName():n.getBaseVariableName()}getDirectOriginalVariable(){return!this.originalId||!this.hasId&&(this.originalId.isPossibleTDZ()||this.originalId.variable.isReassigned||this.originalId.variable instanceof f_||"syntheticNamespace"in this.originalId.variable)?null:this.originalId.variable}getName(n){const e=this.getOriginalVariable();return e===this?super.getName(n):e.getName(n)}getOriginalVariable(){if(this.originalVariable)return this.originalVariable;let n,e=this;const r=new Set;do r.add(e),n=e,e=n.getDirectOriginalVariable();while(e instanceof it&&!r.has(e));return this.originalVariable=e||n}}class m_ extends Kn{constructor(n,e){super(n),this.context=e,this.variables.set("this",new pt("this",null,ie,e))}addExportDefaultDeclaration(n,e,r){const a=new it(n,e,r);return this.variables.set("default",a),a}addNamespaceMemberAccess(){}deconflict(n,e,r){for(const a of this.children)a.deconflict(n,e,r)}findLexicalBoundary(){return this}findVariable(n){const e=this.variables.get(n)||this.accessedOutsideVariables.get(n);if(e)return e;const r=this.context.traceVariable(n)||this.parent.findVariable(n);return r instanceof li&&this.accessedOutsideVariables.set(n,r),r}}const xp={"!":t=>!t,"+":t=>+t,"-":t=>-t,delete:()=>mn,typeof:t=>typeof t,void:()=>{},"~":t=>~t};class p_ extends O{deoptimizePath(){for(const n of this.declarations)n.deoptimizePath(X)}hasEffectsOnInteractionAtPath(){return!1}include(n,e,{asSingleStatement:r}=In){this.included=!0;for(const a of this.declarations){(e||a.shouldBeIncluded(n))&&a.include(n,e);const{id:i,init:s}=a;r&&i.include(n,e),s&&i.included&&!s.included&&(i instanceof Fe||i instanceof $o)&&s.include(n,e)}}initialise(){for(const n of this.declarations)n.declareDeclarator(this.kind)}render(n,e,r=In){if(function(a,i){for(const s of a){if(!s.id.included)return!1;if(s.id.type===oo){if(i.has(s.id.variable))return!1}else{const o=[];if(s.id.addExportedVariables(o,i),o.length>0)return!1}}return!0}(this.declarations,e.exportNamesByVariable)){for(const a of this.declarations)a.render(n,e);r.isNoStatement||n.original.charCodeAt(this.end-1)===59||n.appendLeft(this.end,";")}else this.renderReplacedDeclarations(n,e)}applyDeoptimizations(){}renderDeclarationEnd(n,e,r,a,i,s,o){n.original.charCodeAt(this.end-1)===59&&n.remove(this.end-1,this.end),e+=";",r===null?n.appendLeft(i,e):(n.original.charCodeAt(a-1)!==10||n.original.charCodeAt(this.end)!==10&&n.original.charCodeAt(this.end)!==13||(a--,n.original.charCodeAt(a)===13&&a--),a===r+1?n.overwrite(r,i,e):(n.overwrite(r,r+1,e),n.remove(a,i))),s.length>0&&n.appendLeft(i,` ${Xt(s,o)};`)}renderReplacedDeclarations(n,e){const r=Mo(this.declarations,n,this.start+this.kind.length,this.end-(n.original.charCodeAt(this.end-1)===59?1:0));let a,i;i=wt(n.original,this.start+this.kind.length);let s=i-1;n.remove(this.start,s);let o,_=!1,l=!1,u="";const f=[],m=function(h,v,d){var y;let g=null;if(v.format==="system"){for(const{node:E}of h)E.id instanceof cn&&E.init&&d.length===0&&((y=v.exportNamesByVariable.get(E.id.variable))==null?void 0:y.length)===1?(g=E.id.variable,d.push(g)):E.id.addExportedVariables(d,v.exportNamesByVariable);d.length>1?g=null:g&&(d.length=0)}return g}(r,e,f);for(const{node:h,start:v,separator:d,contentEnd:g,end:y}of r)if(h.included){if(h.render(n,e),o="",!h.id.included||h.id instanceof cn&&r_(h.id.variable,e.exportNamesByVariable))l&&(u+=";"),_=!1;else{if(m&&m===h.id.variable){const E=En(n.original,"=",h.id.end);pi(m,wt(n.original,E+1),d===null?g:d,n,e)}_?u+=",":(l&&(u+=";"),o+=`${this.kind} `,_=!0)}i===s+1?n.overwrite(s,i,u+o):(n.overwrite(s,s+1,u),n.appendLeft(i,o)),a=g,i=y,l=!0,s=d,u=""}else n.remove(v,y);this.renderDeclarationEnd(n,u,s,a,i,f,e)}}const d_={ArrayExpression:xo,ArrayPattern:$o,ArrowFunctionExpression:mi,AssignmentExpression:class extends O{hasEffects(t){const{deoptimized:n,left:e,operator:r,right:a}=this;return n||this.applyDeoptimizations(),a.hasEffects(t)||e.hasEffectsAsAssignmentTarget(t,r!=="=")}hasEffectsOnInteractionAtPath(t,n,e){return this.right.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){const{deoptimized:e,left:r,right:a,operator:i}=this;e||this.applyDeoptimizations(),this.included=!0,(n||i!=="="||r.included||r.hasEffectsAsAssignmentTarget(Er(),!1))&&r.includeAsAssignmentTarget(t,n,i!=="="),a.include(t,n)}initialise(){this.left.setAssignedValue(this.right)}render(t,n,{preventASI:e,renderedParentType:r,renderedSurroundingElement:a}=In){const{left:i,right:s,start:o,end:_,parent:l}=this;if(i.included)i.render(t,n),s.render(t,n);else{const u=wt(t.original,En(t.original,"=",i.end)+1);t.remove(o,u),e&&Mr(t,u,s.start),s.render(t,n,{renderedParentType:r||l.type,renderedSurroundingElement:a||l.type})}if(n.format==="system")if(i instanceof cn){const u=i.variable,f=n.exportNamesByVariable.get(u);if(f)return void(f.length===1?pi(u,o,_,t,n):Do(u,o,_,l.type!==Vn,t,n))}else{const u=[];if(i.addExportedVariables(u,n.exportNamesByVariable),u.length>0)return void function(f,m,h,v,d,g){const{_:y,getDirectReturnIifeLeft:E}=g.snippets;d.prependRight(m,E(["v"],`${Xt(f,g)},${y}v`,{needsArrowReturnParens:!0,needsWrappedFunction:v})),d.appendLeft(h,")")}(u,o,_,a===Vn,t,n)}i.included&&i instanceof Fe&&(a===Vn||a===Qa)&&(t.appendRight(o,"("),t.prependLeft(_,")"))}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(X),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},AssignmentPattern:class extends O{addExportedVariables(t,n){this.left.addExportedVariables(t,n)}declare(t,n){return this.left.declare(t,n)}deoptimizePath(t){t.length===0&&this.left.deoptimizePath(t)}hasEffectsOnInteractionAtPath(t,n,e){return t.length>0||this.left.hasEffectsOnInteractionAtPath(X,n,e)}markDeclarationReached(){this.left.markDeclarationReached()}render(t,n,{isShorthandProperty:e}=In){this.left.render(t,n,{isShorthandProperty:e}),this.right.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(X),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},AwaitExpression:Oo,BinaryExpression:class extends O{deoptimizeCache(){}getLiteralValueAtPath(t,n,e){if(t.length>0)return mn;const r=this.left.getLiteralValueAtPath(X,n,e);if(typeof r=="symbol")return mn;const a=this.right.getLiteralValueAtPath(X,n,e);if(typeof a=="symbol")return mn;const i=op[this.operator];return i?i(r,a):mn}hasEffects(t){return this.operator==="+"&&this.parent instanceof Vt&&this.left.getLiteralValueAtPath(X,xn,this)===""||super.hasEffects(t)}hasEffectsOnInteractionAtPath(t,{type:n}){return n!==0||t.length>1}render(t,n,{renderedSurroundingElement:e}=In){this.left.render(t,n,{renderedSurroundingElement:e}),this.right.render(t,n)}},BlockStatement:Dr,BreakStatement:class extends O{hasEffects(t){if(this.label){if(!t.ignore.labels.has(this.label.name))return!0;t.includedLabels.add(this.label.name)}else{if(!t.ignore.breaks)return!0;t.hasBreak=!0}return t.brokenFlow=!0,!1}include(t){this.included=!0,this.label?(this.label.include(),t.includedLabels.add(this.label.name)):t.hasBreak=!0,t.brokenFlow=!0}},CallExpression:Ro,CatchClause:class extends O{createScope(t){this.scope=new lp(t,this.context)}parseNode(t){const{param:n}=t;n&&(this.param=new(this.context.getNodeConstructor(n.type))(n,this,this.scope),this.param.declare("parameter",U)),super.parseNode(t)}},ChainExpression:class extends O{deoptimizeCache(){}getLiteralValueAtPath(t,n,e){if(!this.expression.isSkippedAsOptional(e))return this.expression.getLiteralValueAtPath(t,n,e)}hasEffects(t){return!this.expression.isSkippedAsOptional(this)&&this.expression.hasEffects(t)}},ClassBody:class extends O{createScope(t){this.scope=new cp(t,this.parent,this.context)}include(t,n){this.included=!0,this.context.includeVariableInModule(this.scope.thisVariable);for(const e of this.body)e.include(t,n)}parseNode(t){const n=this.body=[];for(const e of t.body)n.push(new(this.context.getNodeConstructor(e.type))(e,this,e.static?this.scope:this.scope.instanceScope));super.parseNode(t)}applyDeoptimizations(){}},ClassDeclaration:Pr,ClassExpression:gi,ConditionalExpression:class extends O{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.consequent.deoptimizeArgumentsOnInteractionAtPath(t,n,e),this.alternate.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){if(this.usedBranch!==null){const t=this.usedBranch===this.consequent?this.alternate:this.consequent;this.usedBranch=null,t.deoptimizePath(nn);const{expressionsToBeDeoptimized:n}=this;this.expressionsToBeDeoptimized=bn;for(const e of n)e.deoptimizeCache()}}deoptimizePath(t){const n=this.getUsedBranch();n?n.deoptimizePath(t):(this.consequent.deoptimizePath(t),this.alternate.deoptimizePath(t))}getLiteralValueAtPath(t,n,e){const r=this.getUsedBranch();return r?(this.expressionsToBeDeoptimized.push(e),r.getLiteralValueAtPath(t,n,e)):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){const a=this.getUsedBranch();return a?(this.expressionsToBeDeoptimized.push(r),a.getReturnExpressionWhenCalledAtPath(t,n,e,r)):[new Or([this.consequent.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0],this.alternate.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0]]),!1]}hasEffects(t){if(this.test.hasEffects(t))return!0;const n=this.getUsedBranch();return n?n.hasEffects(t):this.consequent.hasEffects(t)||this.alternate.hasEffects(t)}hasEffectsOnInteractionAtPath(t,n,e){const r=this.getUsedBranch();return r?r.hasEffectsOnInteractionAtPath(t,n,e):this.consequent.hasEffectsOnInteractionAtPath(t,n,e)||this.alternate.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.getUsedBranch();n||this.test.shouldBeIncluded(t)||e===null?(this.test.include(t,n),this.consequent.include(t,n),this.alternate.include(t,n)):e.include(t,n)}includeCallArguments(t,n){const e=this.getUsedBranch();e?e.includeCallArguments(t,n):(this.consequent.includeCallArguments(t,n),this.alternate.includeCallArguments(t,n))}render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a,renderedSurroundingElement:i}=In){const s=this.getUsedBranch();if(this.test.included)this.test.render(t,n,{renderedSurroundingElement:i}),this.consequent.render(t,n),this.alternate.render(t,n);else{const o=En(t.original,":",this.consequent.end),_=wt(t.original,(this.consequent.included?En(t.original,"?",this.test.end):o)+1);r&&Mr(t,_,s.start),t.remove(this.start,_),this.consequent.included&&t.remove(o,this.end),jo(this,t),s.render(t,n,{isCalleeOfRenderedParent:e,preventASI:!0,renderedParentType:a||this.parent.type,renderedSurroundingElement:i||this.parent.type})}}getUsedBranch(){if(this.isBranchResolutionAnalysed)return this.usedBranch;this.isBranchResolutionAnalysed=!0;const t=this.test.getLiteralValueAtPath(X,xn,this);return typeof t=="symbol"?null:this.usedBranch=t?this.consequent:this.alternate}},ContinueStatement:class extends O{hasEffects(t){if(this.label){if(!t.ignore.labels.has(this.label.name))return!0;t.includedLabels.add(this.label.name)}else{if(!t.ignore.continues)return!0;t.hasContinue=!0}return t.brokenFlow=!0,!1}include(t){this.included=!0,this.label?(this.label.include(),t.includedLabels.add(this.label.name)):t.hasContinue=!0,t.brokenFlow=!0}},DoWhileStatement:class extends O{hasEffects(t){return!!this.test.hasEffects(t)||zr(t,this.body)}include(t,n){this.included=!0,this.test.include(t,n),Be(t,this.body,n)}},EmptyStatement:class extends O{hasEffects(){return!1}},ExportAllDeclaration:bi,ExportDefaultDeclaration:Fr,ExportNamedDeclaration:Xo,ExportSpecifier:class extends O{applyDeoptimizations(){}},ExpressionStatement:Vt,ForInStatement:class extends O{createScope(t){this.scope=new qt(t)}hasEffects(t){const{body:n,deoptimized:e,left:r,right:a}=this;return e||this.applyDeoptimizations(),!(!r.hasEffectsAsAssignmentTarget(t,!1)&&!a.hasEffects(t))||zr(t,n)}include(t,n){const{body:e,deoptimized:r,left:a,right:i}=this;r||this.applyDeoptimizations(),this.included=!0,a.includeAsAssignmentTarget(t,n||!0,!1),i.include(t,n),Be(t,e,n)}initialise(){this.left.setAssignedValue(U)}render(t,n){this.left.render(t,n,Rt),this.right.render(t,n,Rt),t.original.charCodeAt(this.right.start-1)===110&&t.prependLeft(this.right.start," "),this.body.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(X),this.context.requestTreeshakingPass()}},ForOfStatement:class extends O{createScope(t){this.scope=new qt(t)}hasEffects(){return this.deoptimized||this.applyDeoptimizations(),!0}include(t,n){const{body:e,deoptimized:r,left:a,right:i}=this;r||this.applyDeoptimizations(),this.included=!0,a.includeAsAssignmentTarget(t,n||!0,!1),i.include(t,n),Be(t,e,n)}initialise(){this.left.setAssignedValue(U)}render(t,n){this.left.render(t,n,Rt),this.right.render(t,n,Rt),t.original.charCodeAt(this.right.start-1)===102&&t.prependLeft(this.right.start," "),this.body.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.left.deoptimizePath(X),this.right.deoptimizePath(nn),this.context.requestTreeshakingPass()}},ForStatement:class extends O{createScope(t){this.scope=new qt(t)}hasEffects(t){var n,e,r;return!!((n=this.init)!=null&&n.hasEffects(t)||(e=this.test)!=null&&e.hasEffects(t)||(r=this.update)!=null&&r.hasEffects(t))||zr(t,this.body)}include(t,n){var e,r,a;this.included=!0,(e=this.init)==null||e.include(t,n,{asSingleStatement:!0}),(r=this.test)==null||r.include(t,n),(a=this.update)==null||a.include(t,n),Be(t,this.body,n)}render(t,n){var e,r,a;(e=this.init)==null||e.render(t,n,Rt),(r=this.test)==null||r.render(t,n,Rt),(a=this.update)==null||a.render(t,n,Rt),this.body.render(t,n)}},FunctionDeclaration:Ge,FunctionExpression:Uo,Identifier:cn,IfStatement:vi,ImportAttribute:class extends O{},ImportDeclaration:Jo,ImportDefaultSpecifier:Ko,ImportExpression:class extends O{constructor(){super(...arguments),this.inlineNamespace=null,this.assertions=null,this.mechanism=null,this.namespaceExportName=void 0,this.resolution=null,this.resolutionString=null}bind(){this.source.bind()}getDeterministicImportedNames(){const t=this.parent;if(t instanceof Vt)return bn;if(t instanceof Oo){const n=t.parent;if(n instanceof Vt)return bn;if(n instanceof a_){const e=n.id;return e instanceof Fe?s_(e):void 0}if(n instanceof Ct){const e=n.property;if(!n.computed&&e instanceof cn)return[e.name]}}else if(t instanceof Ct){const n=t.parent,e=t.property;if(!(n instanceof Ro&&e instanceof cn))return;const r=e.name;if(n.parent instanceof Vt&&["catch","finally"].includes(r))return bn;if(r!=="then")return;if(n.arguments.length===0)return bn;const a=n.arguments[0];if(n.arguments.length!==1||!(a instanceof mi||a instanceof Uo))return;if(a.params.length===0)return bn;const i=a.params[0];return a.params.length===1&&i instanceof Fe?s_(i):void 0}}hasEffects(){return!0}include(t,n){this.included||(this.included=!0,this.context.includeDynamicImport(this),this.scope.addAccessedDynamicImport(this)),this.source.include(t,n)}initialise(){this.context.addDynamicImport(this)}parseNode(t){super.parseNode(t,["source"])}render(t,n){const{snippets:{_:e,getDirectReturnFunction:r,getObject:a,getPropertyAccess:i}}=n;if(this.inlineNamespace){const[s,o]=r([],{functionReturn:!0,lineBreakIndent:null,name:null});t.overwrite(this.start,this.end,`Promise.resolve().then(${s}${this.inlineNamespace.getName(i)}${o})`)}else{if(this.mechanism&&(t.overwrite(this.start,En(t.original,"(",this.start+6)+1,this.mechanism.left),t.overwrite(this.end-1,this.end,this.mechanism.right)),this.resolutionString){if(t.overwrite(this.source.start,this.source.end,this.resolutionString),this.namespaceExportName){const[s,o]=r(["n"],{functionReturn:!0,lineBreakIndent:null,name:null});t.prependLeft(this.end,`.then(${s}n.${this.namespaceExportName}${o})`)}}else this.source.render(t,n);this.assertions!==!0&&(this.arguments&&t.overwrite(this.source.end,this.end-1,"",{contentOnly:!0}),this.assertions&&t.appendLeft(this.end-1,`,${e}${a([["assert",this.assertions]],{lineBreakIndent:null})}`))}}setExternalResolution(t,n,e,r,a,i,s,o,_){const{format:l}=e;this.inlineNamespace=null,this.resolution=n,this.resolutionString=s,this.namespaceExportName=o,this.assertions=_;const u=[...gp[l]||[]];let f;({helper:f,mechanism:this.mechanism}=this.getDynamicImportMechanismAndHelper(n,t,e,r,a)),f&&u.push(f),u.length>0&&this.scope.addAccessedGlobals(u,i)}setInternalResolution(t){this.inlineNamespace=t}applyDeoptimizations(){}getDynamicImportMechanismAndHelper(t,n,{compact:e,dynamicImportFunction:r,dynamicImportInCjs:a,format:i,generatedCode:{arrowFunctions:s},interop:o},{_,getDirectReturnFunction:l,getDirectReturnIifeLeft:u},f){const m=f.hookFirstSync("renderDynamicImport",[{customResolution:typeof this.resolution=="string"?this.resolution:null,format:i,moduleId:this.context.module.id,targetModuleId:this.resolution&&typeof this.resolution!="string"?this.resolution.id:null}]);if(m)return{helper:null,mechanism:m};const h=!this.resolution||typeof this.resolution=="string";switch(i){case"cjs":{if(a&&(!t||typeof t=="string"||t instanceof fn))return{helper:null,mechanism:null};const v=i_(t,n,o);let d="require(",g=")";v&&(d=`/*#__PURE__*/${v}(${d}`,g+=")");const[y,E]=l([],{functionReturn:!0,lineBreakIndent:null,name:null});return d=`Promise.resolve().then(${y}${d}`,g+=`${E})`,!s&&h&&(d=u(["t"],`${d}t${g}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),g=")"),{helper:v,mechanism:{left:d,right:g}}}case"amd":{const v=e?"c":"resolve",d=e?"e":"reject",g=i_(t,n,o),[y,E]=l(["m"],{functionReturn:!1,lineBreakIndent:null,name:null}),b=g?`${y}${v}(/*#__PURE__*/${g}(m))${E}`:v,[x,$]=l([v,d],{functionReturn:!1,lineBreakIndent:null,name:null});let S=`new Promise(${x}require([`,A=`],${_}${b},${_}${d})${$})`;return!s&&h&&(S=u(["t"],`${S}t${A}`,{needsArrowReturnParens:!1,needsWrappedFunction:!0}),A=")"),{helper:g,mechanism:{left:S,right:A}}}case"system":return{helper:null,mechanism:{left:"module.import(",right:")"}};case"es":if(r)return{helper:null,mechanism:{left:`${r}(`,right:")"}}}return{helper:null,mechanism:null}}},ImportNamespaceSpecifier:o_,ImportSpecifier:class extends O{applyDeoptimizations(){}},LabeledStatement:class extends O{hasEffects(t){const n=t.brokenFlow;return t.ignore.labels.add(this.label.name),!!this.body.hasEffects(t)||(t.ignore.labels.delete(this.label.name),t.includedLabels.has(this.label.name)&&(t.includedLabels.delete(this.label.name),t.brokenFlow=n),!1)}include(t,n){this.included=!0;const e=t.brokenFlow;this.body.include(t,n),(n||t.includedLabels.has(this.label.name))&&(this.label.include(),t.includedLabels.delete(this.label.name),t.brokenFlow=e)}render(t,n){this.label.included?this.label.render(t,n):t.remove(this.start,wt(t.original,En(t.original,":",this.label.end)+1)),this.body.render(t,n)}},Literal:Ut,LogicalExpression:class extends O{constructor(){super(...arguments),this.expressionsToBeDeoptimized=[],this.isBranchResolutionAnalysed=!1,this.usedBranch=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.left.deoptimizeArgumentsOnInteractionAtPath(t,n,e),this.right.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){if(this.usedBranch){const t=this.usedBranch===this.left?this.right:this.left;this.usedBranch=null,t.deoptimizePath(nn);const{context:n,expressionsToBeDeoptimized:e}=this;this.expressionsToBeDeoptimized=bn;for(const r of e)r.deoptimizeCache();n.requestTreeshakingPass()}}deoptimizePath(t){const n=this.getUsedBranch();n?n.deoptimizePath(t):(this.left.deoptimizePath(t),this.right.deoptimizePath(t))}getLiteralValueAtPath(t,n,e){const r=this.getUsedBranch();return r?(this.expressionsToBeDeoptimized.push(e),r.getLiteralValueAtPath(t,n,e)):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){const a=this.getUsedBranch();return a?(this.expressionsToBeDeoptimized.push(r),a.getReturnExpressionWhenCalledAtPath(t,n,e,r)):[new Or([this.left.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0],this.right.getReturnExpressionWhenCalledAtPath(t,n,e,r)[0]]),!1]}hasEffects(t){return!!this.left.hasEffects(t)||this.getUsedBranch()!==this.left&&this.right.hasEffects(t)}hasEffectsOnInteractionAtPath(t,n,e){const r=this.getUsedBranch();return r?r.hasEffectsOnInteractionAtPath(t,n,e):this.left.hasEffectsOnInteractionAtPath(t,n,e)||this.right.hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.getUsedBranch();n||e===this.right&&this.left.shouldBeIncluded(t)||!e?(this.left.include(t,n),this.right.include(t,n)):e.include(t,n)}render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a,renderedSurroundingElement:i}=In){if(this.left.included&&this.right.included)this.left.render(t,n,{preventASI:r,renderedSurroundingElement:i}),this.right.render(t,n);else{const s=En(t.original,this.operator,this.left.end);if(this.right.included){const o=wt(t.original,s+2);t.remove(this.start,o),r&&Mr(t,o,this.right.start)}else t.remove(s,this.end);jo(this,t),this.getUsedBranch().render(t,n,{isCalleeOfRenderedParent:e,preventASI:r,renderedParentType:a||this.parent.type,renderedSurroundingElement:i||this.parent.type})}}getUsedBranch(){if(!this.isBranchResolutionAnalysed){this.isBranchResolutionAnalysed=!0;const t=this.left.getLiteralValueAtPath(X,xn,this);if(typeof t=="symbol")return null;this.usedBranch=this.operator==="||"&&t||this.operator==="&&"&&!t||this.operator==="??"&&t!=null?this.left:this.right}return this.usedBranch}},MemberExpression:Ct,MetaProperty:class extends O{constructor(){super(...arguments),this.metaProperty=null,this.preliminaryChunkId=null,this.referenceId=null}getReferencedFileName(t){const{meta:{name:n},metaProperty:e}=this;return n===Ai&&(e!=null&&e.startsWith(Si))?t.getFileName(e.slice(16)):null}hasEffects(){return!1}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n!==0}include(){if(!this.included&&(this.included=!0,this.meta.name===Ai)){this.context.addImportMeta(this);const t=this.parent,n=this.metaProperty=t instanceof Ct&&typeof t.propertyKey=="string"?t.propertyKey:null;n!=null&&n.startsWith(Si)&&(this.referenceId=n.slice(16))}}render(t,{format:n,pluginDriver:e,snippets:r}){var v;const{context:{module:{id:a}},meta:{name:i},metaProperty:s,parent:o,preliminaryChunkId:_,referenceId:l,start:u,end:f}=this;if(i!==Ai)return;const m=_;if(l){const d=e.getFileName(l),g=Ee(ne(Mt(m),d)),y=e.hookFirstSync("resolveFileUrl",[{chunkId:m,fileName:d,format:n,moduleId:a,referenceId:l,relativePath:g}])||yp[n](g);return void t.overwrite(o.start,o.end,y,{contentOnly:!0})}const h=e.hookFirstSync("resolveImportMeta",[s,{chunkId:m,format:n,moduleId:a}])||((v=ji[n])==null?void 0:v.call(ji,s,{chunkId:m,snippets:r}));typeof h=="string"&&(o instanceof Ct?t.overwrite(o.start,o.end,h,{contentOnly:!0}):t.overwrite(u,f,h,{contentOnly:!0}))}setResolution(t,n,e){var a;this.preliminaryChunkId=e;const r=((a=this.metaProperty)!=null&&a.startsWith(Si)?vp:bp)[t];r.length>0&&this.scope.addAccessedGlobals(r,n)}},MethodDefinition:hi,NewExpression:class extends O{hasEffects(t){try{for(const n of this.arguments)if(n.hasEffects(t))return!0;return!this.annotationPure&&(this.callee.hasEffects(t)||this.callee.hasEffectsOnInteractionAtPath(X,this.interaction,t))}finally{this.deoptimized||this.applyDeoptimizations()}}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>0||n!==0}include(t,n){this.deoptimized||this.applyDeoptimizations(),n?super.include(t,n):(this.included=!0,this.callee.include(t,!1)),this.callee.includeCallArguments(t,this.arguments)}initialise(){this.interaction={args:[null,...this.arguments],type:2,withNew:!0}}render(t,n){this.callee.render(t,n),zo(t,n,this)}applyDeoptimizations(){this.deoptimized=!0,this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction,X,xn),this.context.requestTreeshakingPass()}},ObjectExpression:class extends O{constructor(){super(...arguments),this.objectEntity=null}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizeCache(){this.getObjectEntity().deoptimizeAllProperties()}deoptimizePath(t){this.getObjectEntity().deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.getObjectEntity().getLiteralValueAtPath(t,n,e)}getReturnExpressionWhenCalledAtPath(t,n,e,r){return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(t,n,e,r)}hasEffectsOnInteractionAtPath(t,n,e){return this.getObjectEntity().hasEffectsOnInteractionAtPath(t,n,e)}render(t,n,{renderedSurroundingElement:e}=In){super.render(t,n),e!==Vn&&e!==Qa||(t.appendRight(this.start,"("),t.prependLeft(this.end,")"))}applyDeoptimizations(){}getObjectEntity(){if(this.objectEntity!==null)return this.objectEntity;let t=Et;const n=[];for(const e of this.properties){if(e instanceof Le){n.push({key:on,kind:"init",property:e});continue}let r;if(e.computed){const a=e.key.getLiteralValueAtPath(X,xn,this);if(typeof a=="symbol"){n.push({key:on,kind:e.kind,property:e});continue}r=String(a)}else if(r=e.key instanceof cn?e.key.name:String(e.key.value),r==="__proto__"&&e.kind==="init"){t=e.value instanceof Ut&&e.value.value===null?null:e.value;continue}n.push({key:r,kind:e.kind,property:e})}return this.objectEntity=new Bn(n,t)}},ObjectPattern:Fe,PrivateIdentifier:class extends O{},Program:l_,Property:class extends qo{constructor(){super(...arguments),this.declarationInit=null}declare(t,n){return this.declarationInit=n,this.value.declare(t,U)}hasEffects(t){this.deoptimized||this.applyDeoptimizations();const n=this.context.options.treeshake.propertyReadSideEffects;return this.parent.type==="ObjectPattern"&&n==="always"||this.key.hasEffects(t)||this.value.hasEffects(t)}markDeclarationReached(){this.value.markDeclarationReached()}render(t,n){this.shorthand||this.key.render(t,n),this.value.render(t,n,{isShorthandProperty:this.shorthand})}applyDeoptimizations(){this.deoptimized=!0,this.declarationInit!==null&&(this.declarationInit.deoptimizePath([on,on]),this.context.requestTreeshakingPass())}},PropertyDefinition:class extends O{deoptimizeArgumentsOnInteractionAtPath(t,n,e){var r;(r=this.value)==null||r.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){var n;(n=this.value)==null||n.deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.value?this.value.getLiteralValueAtPath(t,n,e):mn}getReturnExpressionWhenCalledAtPath(t,n,e,r){return this.value?this.value.getReturnExpressionWhenCalledAtPath(t,n,e,r):gn}hasEffects(t){var n;return this.key.hasEffects(t)||this.static&&!!((n=this.value)!=null&&n.hasEffects(t))}hasEffectsOnInteractionAtPath(t,n,e){return!this.value||this.value.hasEffectsOnInteractionAtPath(t,n,e)}applyDeoptimizations(){}},RestElement:ui,ReturnStatement:class extends O{hasEffects(t){var n;return!(t.ignore.returnYield&&!((n=this.argument)!=null&&n.hasEffects(t)))||(t.brokenFlow=!0,!1)}include(t,n){var e;this.included=!0,(e=this.argument)==null||e.include(t,n),t.brokenFlow=!0}initialise(){this.scope.addReturnExpression(this.argument||U)}render(t,n){this.argument&&(this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+6&&t.prependLeft(this.start+6," "))}},SequenceExpression:class extends O{deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.expressions[this.expressions.length-1].deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.expressions[this.expressions.length-1].deoptimizePath(t)}getLiteralValueAtPath(t,n,e){return this.expressions[this.expressions.length-1].getLiteralValueAtPath(t,n,e)}hasEffects(t){for(const n of this.expressions)if(n.hasEffects(t))return!0;return!1}hasEffectsOnInteractionAtPath(t,n,e){return this.expressions[this.expressions.length-1].hasEffectsOnInteractionAtPath(t,n,e)}include(t,n){this.included=!0;const e=this.expressions[this.expressions.length-1];for(const r of this.expressions)(n||r===e&&!(this.parent instanceof Vt)||r.shouldBeIncluded(t))&&r.include(t,n)}render(t,n,{renderedParentType:e,isCalleeOfRenderedParent:r,preventASI:a}=In){let i=0,s=null;const o=this.expressions[this.expressions.length-1];for(const{node:_,separator:l,start:u,end:f}of Mo(this.expressions,t,this.start,this.end))if(_.included)if(i++,s=l,i===1&&a&&Mr(t,u,_.start),i===1){const m=e||this.parent.type;_.render(t,n,{isCalleeOfRenderedParent:r&&_===o,renderedParentType:m,renderedSurroundingElement:m})}else _.render(t,n);else ci(_,t,u,f);s&&t.remove(s,this.end)}},SpreadElement:Le,StaticBlock:class extends O{createScope(t){this.scope=new qt(t)}hasEffects(t){for(const n of this.body)if(n.hasEffects(t))return!0;return!1}include(t,n){this.included=!0;for(const e of this.body)(n||e.shouldBeIncluded(t))&&e.include(t,n)}render(t,n){if(this.body.length>0){const e=En(t.original.slice(this.start,this.end),"{")+1;ze(this.body,t,this.start+e,this.end-1,n)}else super.render(t,n)}},Super:class extends O{bind(){this.variable=this.scope.findVariable("this")}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.variable.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.variable.deoptimizePath(t)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}},SwitchCase:c_,SwitchStatement:class extends O{createScope(t){this.parentScope=t,this.scope=new qt(t)}hasEffects(t){if(this.discriminant.hasEffects(t))return!0;const{brokenFlow:n,hasBreak:e,ignore:r}=t,{breaks:a}=r;r.breaks=!0,t.hasBreak=!1;let i=!0;for(const s of this.cases){if(s.hasEffects(t))return!0;i&&(i=t.brokenFlow&&!t.hasBreak),t.hasBreak=!1,t.brokenFlow=n}return this.defaultCase!==null&&(t.brokenFlow=i),r.breaks=a,t.hasBreak=e,!1}include(t,n){this.included=!0,this.discriminant.include(t,n);const{brokenFlow:e,hasBreak:r}=t;t.hasBreak=!1;let a=!0,i=n||this.defaultCase!==null&&this.defaultCase<this.cases.length-1;for(let s=this.cases.length-1;s>=0;s--){const o=this.cases[s];if(o.included&&(i=!0),!i){const _=Er();_.ignore.breaks=!0,i=o.hasEffects(_)}i?(o.include(t,n),a&&(a=t.brokenFlow&&!t.hasBreak),t.hasBreak=!1,t.brokenFlow=e):a=e}i&&this.defaultCase!==null&&(t.brokenFlow=a),t.hasBreak=r}initialise(){for(let t=0;t<this.cases.length;t++)if(this.cases[t].test===null)return void(this.defaultCase=t);this.defaultCase=null}parseNode(t){this.discriminant=new(this.context.getNodeConstructor(t.discriminant.type))(t.discriminant,this,this.parentScope),super.parseNode(t)}render(t,n){this.discriminant.render(t,n),this.cases.length>0&&ze(this.cases,t,this.cases[0].start,this.end-1,n)}},TaggedTemplateExpression:class extends Go{bind(){if(super.bind(),this.tag.type===oo){const t=this.tag.name;this.scope.findVariable(t).isNamespace&&this.context.log(V,Zs(t),this.start)}}hasEffects(t){try{for(const n of this.quasi.expressions)if(n.hasEffects(t))return!0;return this.tag.hasEffects(t)||this.tag.hasEffectsOnInteractionAtPath(X,this.interaction,t)}finally{this.deoptimized||this.applyDeoptimizations()}}include(t,n){this.deoptimized||this.applyDeoptimizations(),n?super.include(t,n):(this.included=!0,this.tag.include(t,n),this.quasi.include(t,n)),this.tag.includeCallArguments(t,this.args);const[e]=this.getReturnExpression();e.included||e.include(t,!1)}initialise(){this.args=[U,...this.quasi.expressions],this.interaction={args:[this.tag instanceof Ct&&!this.tag.variable?this.tag.object:null,...this.args],type:2,withNew:!1}}render(t,n){this.tag.render(t,n,{isCalleeOfRenderedParent:!0}),this.quasi.render(t,n)}applyDeoptimizations(){this.deoptimized=!0,this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction,X,xn),this.context.requestTreeshakingPass()}getReturnExpression(t=xn){return this.returnExpression===null?(this.returnExpression=gn,this.returnExpression=this.tag.getReturnExpressionWhenCalledAtPath(X,this.interaction,t,this)):this.returnExpression}},TemplateElement:class extends O{bind(){}hasEffects(){return!1}include(){this.included=!0}parseNode(t){this.value=t.value,super.parseNode(t)}render(){}},TemplateLiteral:u_,ThisExpression:class extends O{bind(){this.variable=this.scope.findVariable("this")}deoptimizeArgumentsOnInteractionAtPath(t,n,e){this.variable.deoptimizeArgumentsOnInteractionAtPath(t,n,e)}deoptimizePath(t){this.variable.deoptimizePath(t)}hasEffectsOnInteractionAtPath(t,n,e){return t.length===0?n.type!==0:this.variable.hasEffectsOnInteractionAtPath(t,n,e)}include(){this.included||(this.included=!0,this.context.includeVariableInModule(this.variable))}initialise(){this.alias=this.scope.findLexicalBoundary()instanceof m_?this.context.moduleContext:null,this.alias==="undefined"&&this.context.log(V,{code:"THIS_IS_UNDEFINED",message:"The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten",url:wn("troubleshooting/#error-this-is-undefined")},this.start)}render(t){this.alias!==null&&t.overwrite(this.start,this.end,this.alias,{contentOnly:!1,storeName:!0})}},ThrowStatement:class extends O{hasEffects(){return!0}include(t,n){this.included=!0,this.argument.include(t,n),t.brokenFlow=!0}render(t,n){this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+5&&t.prependLeft(this.start+5," ")}},TryStatement:class extends O{constructor(){super(...arguments),this.directlyIncluded=!1,this.includedLabelsAfterBlock=null}hasEffects(t){var n;return(this.context.options.treeshake.tryCatchDeoptimization?this.block.body.length>0:this.block.hasEffects(t))||!!((n=this.finalizer)!=null&&n.hasEffects(t))}include(t,n){var i,s;const e=(i=this.context.options.treeshake)==null?void 0:i.tryCatchDeoptimization,{brokenFlow:r,includedLabels:a}=t;if(this.directlyIncluded&&e){if(this.includedLabelsAfterBlock)for(const o of this.includedLabelsAfterBlock)a.add(o)}else this.included=!0,this.directlyIncluded=!0,this.block.include(t,e?uo:n),a.size>0&&(this.includedLabelsAfterBlock=[...a]),t.brokenFlow=r;this.handler!==null&&(this.handler.include(t,n),t.brokenFlow=r),(s=this.finalizer)==null||s.include(t,n)}},UnaryExpression:class extends O{getLiteralValueAtPath(t,n,e){if(t.length>0)return mn;const r=this.argument.getLiteralValueAtPath(X,n,e);return typeof r=="symbol"?mn:xp[this.operator](r)}hasEffects(t){return this.deoptimized||this.applyDeoptimizations(),!(this.operator==="typeof"&&this.argument instanceof cn)&&(this.argument.hasEffects(t)||this.operator==="delete"&&this.argument.hasEffectsOnInteractionAtPath(X,Oa,t))}hasEffectsOnInteractionAtPath(t,{type:n}){return n!==0||t.length>(this.operator==="void"?0:1)}applyDeoptimizations(){this.deoptimized=!0,this.operator==="delete"&&(this.argument.deoptimizePath(X),this.context.requestTreeshakingPass())}},UnknownNode:class extends O{hasEffects(){return!0}include(t){super.include(t,!0)}},UpdateExpression:class extends O{hasEffects(t){return this.deoptimized||this.applyDeoptimizations(),this.argument.hasEffectsAsAssignmentTarget(t,!0)}hasEffectsOnInteractionAtPath(t,{type:n}){return t.length>1||n!==0}include(t,n){this.deoptimized||this.applyDeoptimizations(),this.included=!0,this.argument.includeAsAssignmentTarget(t,n,!0)}initialise(){this.argument.setAssignedValue(U)}render(t,n){const{exportNamesByVariable:e,format:r,snippets:{_:a}}=n;if(this.argument.render(t,n),r==="system"){const i=this.argument.variable,s=e.get(i);if(s)if(this.prefix)s.length===1?pi(i,this.start,this.end,t,n):Do(i,this.start,this.end,this.parent.type!==Vn,t,n);else{const o=this.operator[0];(function(_,l,u,f,m,h,v){const{_:d}=h.snippets;m.prependRight(l,`${Xt([_],h,v)},${d}`),f&&(m.prependRight(l,"("),m.appendLeft(u,")"))})(i,this.start,this.end,this.parent.type!==Vn,t,n,`${a}${o}${a}1`)}}}applyDeoptimizations(){this.deoptimized=!0,this.argument.deoptimizePath(X),this.argument instanceof cn&&(this.scope.findVariable(this.argument.name).isReassigned=!0),this.context.requestTreeshakingPass()}},VariableDeclaration:p_,VariableDeclarator:a_,WhileStatement:class extends O{hasEffects(t){return!!this.test.hasEffects(t)||zr(t,this.body)}include(t,n){this.included=!0,this.test.include(t,n),Be(t,this.body,n)}},YieldExpression:class extends O{hasEffects(t){var n;return this.deoptimized||this.applyDeoptimizations(),!(t.ignore.returnYield&&!((n=this.argument)!=null&&n.hasEffects(t)))}render(t,n){this.argument&&(this.argument.render(t,n,{preventASI:!0}),this.argument.start===this.start+5&&t.prependLeft(this.start+5," "))}}},ce="_missingExportShim";class $p extends Pt{constructor(n){super(ce),this.module=n}include(){super.include(),this.module.needsExportShim=!0}}class Ue extends Pt{constructor(n){super(n.getModuleName()),this.memberVariables=null,this.mergedNamespaces=[],this.referencedEarly=!1,this.references=[],this.context=n,this.module=n.module}addReference(n){this.references.push(n),this.name=n.name}deoptimizeArgumentsOnInteractionAtPath(n,e,r){var a;if(e.length>1||e.length===1&&n.type===2){const i=e[0];typeof i=="string"?(a=this.getMemberVariables()[i])==null||a.deoptimizeArgumentsOnInteractionAtPath(n,e.slice(1),r):xt(n)}}deoptimizePath(n){var e;if(n.length>1){const r=n[0];typeof r=="string"&&((e=this.getMemberVariables()[r])==null||e.deoptimizePath(n.slice(1)))}}getLiteralValueAtPath(n){return n[0]===Ma?"Module":mn}getMemberVariables(){if(this.memberVariables)return this.memberVariables;const n=Object.create(null),e=[...this.context.getExports(),...this.context.getReexports()].sort();for(const r of e)if(r[0]!=="*"&&r!==this.module.info.syntheticNamedExports){const a=this.context.traceExport(r);a&&(n[r]=a)}return this.memberVariables=n}hasEffectsOnInteractionAtPath(n,e,r){const{type:a}=e;if(n.length===0)return!0;if(n.length===1&&a!==2)return a===1;const i=n[0];if(typeof i!="string")return!0;const s=this.getMemberVariables()[i];return!s||s.hasEffectsOnInteractionAtPath(n.slice(1),e,r)}include(){this.included=!0,this.context.includeAllExports()}prepare(n){this.mergedNamespaces.length>0&&this.module.scope.addAccessedGlobals([Rr],n)}renderBlock(n){const{exportNamesByVariable:e,format:r,freeze:a,indent:i,namespaceToStringTag:s,snippets:{_:o,cnst:_,getObject:l,getPropertyAccess:u,n:f,s:m}}=n,h=this.getMemberVariables(),v=Object.entries(h).filter(([g,y])=>y.included).map(([g,y])=>this.referencedEarly||y.isReassigned||y===this?[null,`get ${g}${o}()${o}{${o}return ${y.getName(u)}${m}${o}}`]:[g,y.getName(u)]);v.unshift([null,`__proto__:${o}null`]);let d=l(v,{lineBreakIndent:{base:"",t:i}});if(this.mergedNamespaces.length>0){const g=this.mergedNamespaces.map(y=>y.getName(u));d=`/*#__PURE__*/${Rr}(${d},${o}[${g.join(`,${o}`)}])`}else s&&(d=`/*#__PURE__*/Object.defineProperty(${d},${o}Symbol.toStringTag,${o}${Ve(l)})`),a&&(d=`/*#__PURE__*/Object.freeze(${d})`);return d=`${_} ${this.getName(u)}${o}=${o}${d};`,r==="system"&&e.has(this)&&(d+=`${f}${Xt([this],n)};`),d}renderFirst(){return this.referencedEarly}setMergedNamespaces(n){this.mergedNamespaces=n;const e=this.context.getModuleExecIndex();for(const r of this.references)if(r.context.getModuleExecIndex()<=e){this.referencedEarly=!0;break}}}Ue.prototype.isNamespace=!0;class Dn extends Pt{constructor(n,e,r){super(e),this.baseVariable=null,this.context=n,this.module=n.module,this.syntheticNamespace=r}getBaseVariable(){if(this.baseVariable)return this.baseVariable;let n=this.syntheticNamespace;for(;n instanceof it||n instanceof Dn;){if(n instanceof it){const e=n.getOriginalVariable();if(e===n)break;n=e}n instanceof Dn&&(n=n.syntheticNamespace)}return this.baseVariable=n}getBaseVariableName(){return this.syntheticNamespace.getBaseVariableName()}getName(n){return`${this.syntheticNamespace.getName(n)}${n(this.name)}`}include(){this.included=!0,this.context.includeVariableInModule(this.syntheticNamespace)}setRenderNames(n,e){super.setRenderNames(n,e)}}var St;function Li(t){return t.id}(function(t){t[t.LOAD_AND_PARSE=0]="LOAD_AND_PARSE",t[t.ANALYSE=1]="ANALYSE",t[t.GENERATE=2]="GENERATE"})(St||(St={}));const Mi=t=>{const n=t.key;return n&&(n.name||n.value)};function Ur(t,n){const e=Object.keys(t);return e.length!==Object.keys(n).length||e.some(r=>t[r]!==n[r])}var h_="performance"in(typeof globalThis>"u"?typeof window>"u"?{}:window:globalThis)?performance:{now:()=>0},g_={memoryUsage:()=>({heapUsed:0})};let He=new Map;function b_(t,n){switch(n){case 1:return`# ${t}`;case 2:return`## ${t}`;case 3:return t;default:return`${"  ".repeat(n-4)}- ${t}`}}function Ep(t,n=3){t=b_(t,n);const e=g_.memoryUsage().heapUsed,r=h_.now(),a=He.get(t);a===void 0?He.set(t,{memory:0,startMemory:e,startTime:r,time:0,totalMemory:0}):(a.startMemory=e,a.startTime=r)}function kp(t,n=3){t=b_(t,n);const e=He.get(t);if(e!==void 0){const r=g_.memoryUsage().heapUsed;e.memory+=r-e.startMemory,e.time+=h_.now()-e.startTime,e.totalMemory=Math.max(e.totalMemory,r)}}function wp(){const t={};for(const[n,{memory:e,time:r,totalMemory:a}]of He)t[n]=[r,e,a];return t}let $n=rt,yn=rt;const Cp=["augmentChunkHash","buildEnd","buildStart","generateBundle","load","moduleParsed","options","outputOptions","renderChunk","renderDynamicImport","renderStart","resolveDynamicImport","resolveFileUrl","resolveId","resolveImportMeta","shouldTransformCachedModule","transform","writeBundle"];function Sp(t,n){for(const e of Cp)if(e in t){let r=`plugin ${n}`;t.name&&(r+=` (${t.name})`),r+=` - ${e}`;const a=function(...s){$n(r,4);const o=i.apply(this,s);return yn(r,4),o};let i;typeof t[e].handler=="function"?(i=t[e].handler,t[e].handler=a):(i=t[e],t[e]=a)}return t}function We(t){t.isExecuted=!0;const n=[t],e=new Set;for(const r of n)for(const a of[...r.dependencies,...r.implicitlyLoadedBefore])a instanceof fn||a.isExecuted||!a.info.moduleSideEffects&&!r.implicitlyLoadedBefore.has(a)||e.has(a.id)||(a.isExecuted=!0,e.add(a.id),n.push(a))}const v_={identifier:null,localName:ce};function Di(t,n,e,r,a=new Map){const i=a.get(n);if(i){if(i.has(t))return r?[null]:L((s=n,o=t.id,{code:lm,exporter:o,message:`"${s}" cannot be exported from "${H(o)}" as it is a reexport that references itself.`}));i.add(t)}else a.set(n,new Set([t]));var s,o;return t.getVariableForExportName(n,{importerForSideEffects:e,isExportAllSearch:r,searchedNamesAndModules:a})}function y_(t,n){const e=zn(n.sideEffectDependenciesByVariable,t,Dt);let r=t;const a=new Set([r]);for(;;){const i=r.module;if(r=r instanceof it?r.getDirectOriginalVariable():r instanceof Dn?r.syntheticNamespace:null,!r||a.has(r))break;a.add(r),e.add(i);const s=i.sideEffectDependenciesByVariable.get(r);if(s)for(const o of s)e.add(o)}return e}class hn{constructor(n,e,r,a,i,s,o,_){this.graph=n,this.id=e,this.options=r,this.alternativeReexportModules=new Map,this.chunkFileNames=new Set,this.chunkNames=[],this.cycles=new Set,this.dependencies=new Set,this.dynamicDependencies=new Set,this.dynamicImporters=[],this.dynamicImports=[],this.execIndex=1/0,this.implicitlyLoadedAfter=new Set,this.implicitlyLoadedBefore=new Set,this.importDescriptions=new Map,this.importMetas=[],this.importedFromNotTreeshaken=!1,this.importers=[],this.includedDynamicImporters=[],this.includedImports=new Set,this.isExecuted=!1,this.isUserDefinedEntryPoint=!1,this.needsExportShim=!1,this.sideEffectDependenciesByVariable=new Map,this.sourcesWithAssertions=new Map,this.allExportNames=null,this.ast=null,this.exportAllModules=[],this.exportAllSources=new Set,this.exportNamesByVariable=null,this.exportShimVariable=new $p(this),this.exports=new Map,this.namespaceReexportsByName=new Map,this.reexportDescriptions=new Map,this.relevantDependencies=null,this.syntheticExports=new Map,this.syntheticNamespace=null,this.transformDependencies=[],this.transitiveReexports=null,this.excludeFromSourcemap=/\0/.test(e),this.context=r.moduleContext(e),this.preserveSignature=this.options.preserveEntrySignatures;const l=this,{dynamicImports:u,dynamicImporters:f,exportAllSources:m,exports:h,implicitlyLoadedAfter:v,implicitlyLoadedBefore:d,importers:g,reexportDescriptions:y,sourcesWithAssertions:E}=this;this.info={assertions:_,ast:null,code:null,get dynamicallyImportedIdResolutions(){return u.map(({argument:b})=>typeof b=="string"&&l.resolvedIds[b]).filter(Boolean)},get dynamicallyImportedIds(){return u.map(({id:b})=>b).filter(b=>b!=null)},get dynamicImporters(){return f.sort()},get exportedBindings(){const b={".":[...h.keys()]};for(const[x,{source:$}]of y)(b[$]??(b[$]=[])).push(x);for(const x of m)(b[x]??(b[x]=[])).push("*");return b},get exports(){return[...h.keys(),...y.keys(),...[...m].map(()=>"*")]},get hasDefaultExport(){return l.ast?l.exports.has("default")||y.has("default"):null},get hasModuleSideEffects(){return Ft("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.",Rs,!0,r),this.moduleSideEffects},id:e,get implicitlyLoadedAfterOneOf(){return Array.from(v,Li).sort()},get implicitlyLoadedBefore(){return Array.from(d,Li).sort()},get importedIdResolutions(){return Array.from(E.keys(),b=>l.resolvedIds[b]).filter(Boolean)},get importedIds(){return Array.from(E.keys(),b=>{var x;return(x=l.resolvedIds[b])==null?void 0:x.id}).filter(Boolean)},get importers(){return g.sort()},isEntry:a,isExternal:!1,get isIncluded(){return n.phase!==St.GENERATE?null:l.isIncluded()},meta:{...o},moduleSideEffects:i,syntheticNamedExports:s},Object.defineProperty(this.info,"hasModuleSideEffects",{enumerable:!1})}basename(){const n=ft(this.id),e=yt(this.id);return za(e?n.slice(0,-e.length):n)}bindReferences(){this.ast.bind()}error(n,e){return this.addLocationToLogProps(n,e),L(n)}estimateSize(){let n=0;for(const e of this.ast.body)e.included&&(n+=e.end-e.start);return n}getAllExportNames(){if(this.allExportNames)return this.allExportNames;this.allExportNames=new Set([...this.exports.keys(),...this.reexportDescriptions.keys()]);for(const n of this.exportAllModules)if(n instanceof fn)this.allExportNames.add(`*${n.id}`);else for(const e of n.getAllExportNames())e!=="default"&&this.allExportNames.add(e);return typeof this.info.syntheticNamedExports=="string"&&this.allExportNames.delete(this.info.syntheticNamedExports),this.allExportNames}getDependenciesToBeIncluded(){if(this.relevantDependencies)return this.relevantDependencies;this.relevantDependencies=new Set;const n=new Set,e=new Set,r=new Set(this.includedImports);if(this.info.isEntry||this.includedDynamicImporters.length>0||this.namespace.included||this.implicitlyLoadedAfter.size>0)for(const a of[...this.getReexports(),...this.getExports()]){const[i]=this.getVariableForExportName(a);i&&r.add(i)}for(let a of r){const i=this.sideEffectDependenciesByVariable.get(a);if(i)for(const s of i)e.add(s);a instanceof Dn?a=a.getBaseVariable():a instanceof it&&(a=a.getOriginalVariable()),n.add(a.module)}if(this.options.treeshake&&this.info.moduleSideEffects!=="no-treeshake")this.addRelevantSideEffectDependencies(this.relevantDependencies,n,e);else for(const a of this.dependencies)this.relevantDependencies.add(a);for(const a of n)this.relevantDependencies.add(a);return this.relevantDependencies}getExportNamesByVariable(){if(this.exportNamesByVariable)return this.exportNamesByVariable;const n=new Map;for(const e of this.getAllExportNames()){let[r]=this.getVariableForExportName(e);if(r instanceof it&&(r=r.getOriginalVariable()),!r||!(r.included||r instanceof br))continue;const a=n.get(r);a?a.push(e):n.set(r,[e])}return this.exportNamesByVariable=n}getExports(){return[...this.exports.keys()]}getReexports(){if(this.transitiveReexports)return this.transitiveReexports;this.transitiveReexports=[];const n=new Set(this.reexportDescriptions.keys());for(const e of this.exportAllModules)if(e instanceof fn)n.add(`*${e.id}`);else for(const r of[...e.getReexports(),...e.getExports()])r!=="default"&&n.add(r);return this.transitiveReexports=[...n]}getRenderedExports(){const n=[],e=[];for(const r of this.exports.keys()){const[a]=this.getVariableForExportName(r);(a&&a.included?n:e).push(r)}return{removedExports:e,renderedExports:n}}getSyntheticNamespace(){return this.syntheticNamespace===null&&(this.syntheticNamespace=void 0,[this.syntheticNamespace]=this.getVariableForExportName(typeof this.info.syntheticNamedExports=="string"?this.info.syntheticNamedExports:"default",{onlyExplicit:!0})),this.syntheticNamespace?this.syntheticNamespace:L((n=this.id,e=this.info.syntheticNamedExports,{code:"SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT",exporter:n,message:`Module "${H(n)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(e)}\` needs ${typeof e=="string"&&e!=="default"?`an explicit export named "${e}"`:"a default export"} that does not reexport an unresolved named export of the same module.`}));var n,e}getVariableForExportName(n,{importerForSideEffects:e,isExportAllSearch:r,onlyExplicit:a,searchedNamesAndModules:i}=Fn){if(n[0]==="*")return n.length===1?[this.namespace]:this.graph.modulesById.get(n.slice(1)).getVariableForExportName("*");const s=this.reexportDescriptions.get(n);if(s){const[_]=Di(s.module,s.localName,e,!1,i);return _?(e&&(x_(_,e,this),this.info.moduleSideEffects&&zn(e.sideEffectDependenciesByVariable,_,Dt).add(this)),[_]):this.error($r(s.localName,this.id,s.module.id),s.start)}const o=this.exports.get(n);if(o){if(o===v_)return[this.exportShimVariable];const _=o.localName,l=this.traceVariable(_,{importerForSideEffects:e,searchedNamesAndModules:i});return e&&(x_(l,e,this),zn(e.sideEffectDependenciesByVariable,l,Dt).add(this)),[l]}if(a)return[null];if(n!=="default"){const _=this.namespaceReexportsByName.get(n)??this.getVariableFromNamespaceReexports(n,e,i);if(this.namespaceReexportsByName.set(n,_),_[0])return _}return this.info.syntheticNamedExports?[zn(this.syntheticExports,n,()=>new Dn(this.astContext,n,this.getSyntheticNamespace()))]:!r&&this.options.shimMissingExports?(this.shimMissingExport(n),[this.exportShimVariable]):[null]}hasEffects(){return this.info.moduleSideEffects==="no-treeshake"||this.ast.hasCachedEffects()}include(){const n=Ha();this.ast.shouldBeIncluded(n)&&this.ast.include(n,!1)}includeAllExports(n){this.isExecuted||(We(this),this.graph.needsTreeshakingPass=!0);for(const e of this.exports.keys())if(n||e!==this.info.syntheticNamedExports){const r=this.getVariableForExportName(e)[0];r.deoptimizePath(nn),r.included||this.includeVariable(r)}for(const e of this.getReexports()){const[r]=this.getVariableForExportName(e);r&&(r.deoptimizePath(nn),r.included||this.includeVariable(r),r instanceof br&&(r.module.reexported=!0))}n&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}includeAllInBundle(){this.ast.include(Ha(),!0),this.includeAllExports(!1)}includeExportsByNames(n){this.isExecuted||(We(this),this.graph.needsTreeshakingPass=!0);let e=!1;for(const r of n){const a=this.getVariableForExportName(r)[0];a&&(a.deoptimizePath(nn),a.included||this.includeVariable(a)),this.exports.has(r)||this.reexportDescriptions.has(r)||(e=!0)}e&&this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())}isIncluded(){return this.ast&&(this.ast.included||this.namespace.included||this.importedFromNotTreeshaken||this.exportShimVariable.included)}linkImports(){this.addModulesToImportDescriptions(this.importDescriptions),this.addModulesToImportDescriptions(this.reexportDescriptions);const n=[];for(const e of this.exportAllSources){const r=this.graph.modulesById.get(this.resolvedIds[e].id);r instanceof fn?n.push(r):this.exportAllModules.push(r)}this.exportAllModules.push(...n)}log(n,e,r){this.addLocationToLogProps(e,r),this.options.onLog(n,e)}render(n){const e=this.magicString.clone();this.ast.render(e,n),e.trim();const{usesTopLevelAwait:r}=this.astContext;return r&&n.format!=="es"&&n.format!=="system"?L((a=this.id,i=n.format,{code:"INVALID_TLA_FORMAT",id:a,message:`Module format "${i}" does not support top-level await. Use the "es" or "system" output formats rather.`})):{source:e,usesTopLevelAwait:r};var a,i}setSource({ast:n,code:e,customTransformCache:r,originalCode:a,originalSourcemap:i,resolvedIds:s,sourcemapChain:o,transformDependencies:_,transformFiles:l,...u}){$n("generate ast",3),this.info.code=e,this.originalCode=a,this.originalSourcemap=i,this.sourcemapChain=o,l&&(this.transformFiles=l),this.transformDependencies=_,this.customTransformCache=r,this.updateOptions(u);const f=n??this.tryParse();yn("generate ast",3),$n("analyze ast",3),this.resolvedIds=s??Object.create(null);const m=this.id;this.magicString=new Lt(e,{filename:this.excludeFromSourcemap?null:m,indentExclusionRanges:[]}),this.astContext={addDynamicImport:this.addDynamicImport.bind(this),addExport:this.addExport.bind(this),addImport:this.addImport.bind(this),addImportMeta:this.addImportMeta.bind(this),code:e,deoptimizationTracker:this.graph.deoptimizationTracker,error:this.error.bind(this),fileName:m,getExports:this.getExports.bind(this),getModuleExecIndex:()=>this.execIndex,getModuleName:this.basename.bind(this),getNodeConstructor:h=>d_[h]||d_.UnknownNode,getReexports:this.getReexports.bind(this),importDescriptions:this.importDescriptions,includeAllExports:()=>this.includeAllExports(!0),includeDynamicImport:this.includeDynamicImport.bind(this),includeVariableInModule:this.includeVariableInModule.bind(this),log:this.log.bind(this),magicString:this.magicString,manualPureFunctions:this.graph.pureFunctions,module:this,moduleContext:this.context,options:this.options,requestTreeshakingPass:()=>this.graph.needsTreeshakingPass=!0,traceExport:h=>this.getVariableForExportName(h)[0],traceVariable:this.traceVariable.bind(this),usesTopLevelAwait:!1},this.scope=new m_(this.graph.scope,this.astContext),this.namespace=new Ue(this.astContext),this.ast=new l_(f,{context:this.astContext,type:"Module"},this.scope),n||this.options.cache!==!1?this.info.ast=f:Object.defineProperty(this.info,"ast",{get:()=>{if(this.graph.astLru.has(m))return this.graph.astLru.get(m);{const h=this.tryParse();return this.graph.astLru.set(m,h),h}}}),yn("analyze ast",3)}toJSON(){return{assertions:this.info.assertions,ast:this.info.ast,code:this.info.code,customTransformCache:this.customTransformCache,dependencies:Array.from(this.dependencies,Li),id:this.id,meta:this.info.meta,moduleSideEffects:this.info.moduleSideEffects,originalCode:this.originalCode,originalSourcemap:this.originalSourcemap,resolvedIds:this.resolvedIds,sourcemapChain:this.sourcemapChain,syntheticNamedExports:this.info.syntheticNamedExports,transformDependencies:this.transformDependencies,transformFiles:this.transformFiles}}traceVariable(n,{importerForSideEffects:e,isExportAllSearch:r,searchedNamesAndModules:a}=Fn){const i=this.scope.variables.get(n);if(i)return i;const s=this.importDescriptions.get(n);if(s){const o=s.module;if(o instanceof hn&&s.name==="*")return o.namespace;const[_]=Di(o,s.name,e||this,r,a);return _||this.error($r(s.name,this.id,o.id),s.start)}return null}updateOptions({meta:n,moduleSideEffects:e,syntheticNamedExports:r}){e!=null&&(this.info.moduleSideEffects=e),r!=null&&(this.info.syntheticNamedExports=r),n!=null&&Object.assign(this.info.meta,n)}addDynamicImport(n){let e=n.source;e instanceof u_?e.quasis.length===1&&e.quasis[0].value.cooked&&(e=e.quasis[0].value.cooked):e instanceof Ut&&typeof e.value=="string"&&(e=e.value),this.dynamicImports.push({argument:e,id:null,node:n,resolution:null})}addExport(n){if(n instanceof Fr)this.exports.set("default",{identifier:n.variable.getAssignedVariableName(),localName:"default"});else if(n instanceof bi){const e=n.source.value;if(this.addSource(e,n),n.exported){const r=n.exported.name;this.reexportDescriptions.set(r,{localName:"*",module:null,source:e,start:n.start})}else this.exportAllSources.add(e)}else if(n.source instanceof Ut){const e=n.source.value;this.addSource(e,n);for(const{exported:r,local:a,start:i}of n.specifiers){const s=r instanceof Ut?r.value:r.name;this.reexportDescriptions.set(s,{localName:a instanceof Ut?a.value:a.name,module:null,source:e,start:i})}}else if(n.declaration){const e=n.declaration;if(e instanceof p_)for(const r of e.declarations)for(const a of Mm(r.id))this.exports.set(a,{identifier:null,localName:a});else{const r=e.id.name;this.exports.set(r,{identifier:null,localName:r})}}else for(const{local:e,exported:r}of n.specifiers){const a=e.name,i=r instanceof cn?r.name:r.value;this.exports.set(i,{identifier:null,localName:a})}}addImport(n){const e=n.source.value;this.addSource(e,n);for(const r of n.specifiers){const a=r instanceof Ko?"default":r instanceof o_?"*":r.imported instanceof cn?r.imported.name:r.imported.value;this.importDescriptions.set(r.local.name,{module:null,name:a,source:e,start:r.start})}}addImportMeta(n){this.importMetas.push(n)}addLocationToLogProps(n,e){n.id=this.id,n.pos=e;let r=this.info.code;const a=Fa(r,e,{offsetLine:1});if(a){let{column:i,line:s}=a;try{({column:i,line:s}=function(o,_){const l=o.filter(u=>!!u.mappings);n:for(;l.length>0;){const u=l.pop().mappings[_.line-1];if(u){const f=u.filter(h=>h.length>1),m=f[f.length-1];for(const h of f)if(h[0]>=_.column||h===m){_={column:h[3],line:h[2]+1};continue n}}throw new Error("Can't resolve original location of error.")}return _}(this.sourcemapChain,{column:i,line:s})),r=this.originalCode}catch(o){this.options.onLog(V,function(_,l,u,f,m){return{cause:_,code:"SOURCEMAP_ERROR",id:l,loc:{column:u,file:l,line:f},message:`Error when using sourcemap for reporting an error: ${_.message}`,pos:m}}(o,this.id,i,s,e))}yr(n,{column:i,line:s},r,this.id)}}addModulesToImportDescriptions(n){for(const e of n.values()){const{id:r}=this.resolvedIds[e.source];e.module=this.graph.modulesById.get(r)}}addRelevantSideEffectDependencies(n,e,r){const a=new Set,i=s=>{for(const o of s)a.has(o)||(a.add(o),e.has(o)?n.add(o):(o.info.moduleSideEffects||r.has(o))&&(o instanceof fn||o.hasEffects()?n.add(o):i(o.dependencies)))};i(this.dependencies),i(r)}addSource(n,e){const r=(a=e.assertions,a!=null&&a.length?Object.fromEntries(a.map(s=>[Mi(s),s.value.value])):Fn);var a;const i=this.sourcesWithAssertions.get(n);i?Ur(i,r)&&this.log(V,xr(i,r,n,this.id),e.start):this.sourcesWithAssertions.set(n,r)}getVariableFromNamespaceReexports(n,e,r){let a=null;const i=new Map,s=new Set;for(const u of this.exportAllModules){if(u.info.syntheticNamedExports===n)continue;const[f,m]=Di(u,n,e,!0,Ap(r));u instanceof fn||m?s.add(f):f instanceof Dn?a||(a=f):f&&i.set(f,u)}if(i.size>0){const u=[...i],f=u[0][0];return u.length===1?[f]:(this.options.onLog(V,(o=n,_=this.id,l=u.map(([,m])=>m.id),{binding:o,code:"NAMESPACE_CONFLICT",ids:l,message:`Conflicting namespaces: "${H(_)}" re-exports "${o}" from one of the modules ${mt(l.map(m=>H(m)))} (will be ignored).`,reexporter:_})),[null])}var o,_,l;if(s.size>0){const u=[...s],f=u[0];return u.length>1&&this.options.onLog(V,function(m,h,v,d){return{binding:m,code:"AMBIGUOUS_EXTERNAL_NAMESPACES",ids:d,message:`Ambiguous external namespace resolution: "${H(h)}" re-exports "${m}" from one of the external modules ${mt(d.map(g=>H(g)))}, guessing "${H(v)}".`,reexporter:h}}(n,this.id,f.module.id,u.map(m=>m.module.id))),[f,!0]}return a?[a]:[null]}includeAndGetAdditionalMergedNamespaces(){const n=new Set,e=new Set;for(const r of[this,...this.exportAllModules])if(r instanceof fn){const[a]=r.getVariableForExportName("*");a.include(),this.includedImports.add(a),n.add(a)}else if(r.info.syntheticNamedExports){const a=r.getSyntheticNamespace();a.include(),this.includedImports.add(a),e.add(a)}return[...e,...n]}includeDynamicImport(n){const e=this.dynamicImports.find(r=>r.node===n).resolution;if(e instanceof hn){e.includedDynamicImporters.push(this);const r=this.options.treeshake?n.getDeterministicImportedNames():void 0;r?e.includeExportsByNames(r):e.includeAllExports(!0)}}includeVariable(n){const e=n.module;if(n.included)e instanceof hn&&e!==this&&y_(n,this);else if(n.include(),this.graph.needsTreeshakingPass=!0,e instanceof hn&&(e.isExecuted||We(e),e!==this)){const r=y_(n,this);for(const a of r)a.isExecuted||We(a)}}includeVariableInModule(n){this.includeVariable(n);const e=n.module;e&&e!==this&&this.includedImports.add(n)}shimMissingExport(n){var e,r;this.options.onLog(V,(e=this.id,{binding:r=n,code:"SHIMMED_EXPORT",exporter:e,message:`Missing export "${r}" has been shimmed in module "${H(e)}".`})),this.exports.set(n,v_)}tryParse(){try{return this.graph.contextParse(this.info.code)}catch(n){return this.error(function(e,r){let a=e.message.replace(/ \(\d+:\d+\)$/,"");return r.endsWith(".json")?a+=" (Note that you need @rollup/plugin-json to import JSON files)":r.endsWith(".js")||(a+=" (Note that you need plugins to import files that are not JavaScript)"),{cause:e,code:"PARSE_ERROR",id:r,message:a}}(n,this.id),n.pos)}}}function x_(t,n,e){if(t.module instanceof hn&&t.module!==e){const r=t.module.cycles;if(r.size>0){const a=e.cycles;for(const i of a)if(r.has(i)){n.alternativeReexportModules.set(t,e);break}}}}const Ap=t=>t&&new Map(Array.from(t,([n,e])=>[n,new Set(e)]));function $_(t){return t.endsWith(".js")?t.slice(0,-3):t}function E_(t,n){return t.autoId?`${t.basePath?t.basePath+"/":""}${$_(n)}`:t.id??""}function Hr(t,n,e,r,a,i,s,o="return "){const{_,getDirectReturnFunction:l,getFunctionIntro:u,getPropertyAccess:f,n:m,s:h}=a;if(!e)return`${m}${m}${o}${function(d,g,y,E,b){if(d.length>0)return d[0].local;for(const{defaultVariableName:x,importPath:$,isChunk:S,name:A,namedExportsMode:N,namespaceVariableName:k,reexports:I}of g)if(I)return k_(A,I[0].imported,N,S,x,k,y,$,E,b)}(t,n,r,s,f)};`;let v="";for(const{defaultVariableName:d,importPath:g,isChunk:y,name:E,namedExportsMode:b,namespaceVariableName:x,reexports:$}of n)if($&&e){for(const S of $)if(S.reexported!=="*"){const A=k_(E,S.imported,b,y,d,x,r,g,s,f);if(v&&(v+=m),S.imported!=="*"&&S.needsLiveBinding){const[N,k]=l([],{functionReturn:!0,lineBreakIndent:null,name:null});v+=`Object.defineProperty(exports,${_}'${S.reexported}',${_}{${m}${i}enumerable:${_}true,${m}${i}get:${_}${N}${A}${k}${m}});`}else v+=`exports${f(S.reexported)}${_}=${_}${A};`}}for(const{exported:d,local:g}of t){const y=`exports${f(d)}`;y!==g&&(v&&(v+=m),v+=`${y}${_}=${_}${g};`)}for(const{name:d,reexports:g}of n)if(g&&e){for(const y of g)if(y.reexported==="*"){v&&(v+=m);const E=`{${m}${i}if${_}(k${_}!==${_}'default'${_}&&${_}!exports.hasOwnProperty(k))${_}${Ip(d,y.needsLiveBinding,i,a)}${h}${m}}`;v+=`Object.keys(${d}).forEach(${u(["k"],{isAsync:!1,name:null})}${E});`}}return v?`${m}${m}${v}`:""}function k_(t,n,e,r,a,i,s,o,_,l){if(n==="default"){if(!r){const u=s(o),f=qr[u]?a:t;return Vr(u,_)?`${f}${l("default")}`:f}return e?`${t}${l("default")}`:t}return n==="*"?(r?!e:qe[s(o)])?i:t:`${t}${l(n)}`}function w_(t){return t([["value","true"]],{lineBreakIndent:null})}function Wr(t,n,e,{_:r,getObject:a}){if(t){if(n)return e?`Object.defineProperties(exports,${r}${a([["__esModule",w_(a)],[null,`[Symbol.toStringTag]:${r}${Ve(a)}`]],{lineBreakIndent:null})});`:`Object.defineProperty(exports,${r}'__esModule',${r}${w_(a)});`;if(e)return`Object.defineProperty(exports,${r}Symbol.toStringTag,${r}${Ve(a)});`}return""}const Ip=(t,n,e,{_:r,getDirectReturnFunction:a,n:i})=>{if(n){const[s,o]=a([],{functionReturn:!0,lineBreakIndent:null,name:null});return`Object.defineProperty(exports,${r}k,${r}{${i}${e}${e}enumerable:${r}true,${i}${e}${e}get:${r}${s}${t}[k]${o}${i}${e}})`}return`exports[k]${r}=${r}${t}[k]`};function Jr(t,n,e,r,a,i,s,o){const{_,cnst:l,n:u}=o,f=new Set,m=[],h=(v,d,g)=>{f.add(d),m.push(`${l} ${v}${_}=${_}/*#__PURE__*/${d}(${g});`)};for(const{defaultVariableName:v,imports:d,importPath:g,isChunk:y,name:E,namedExportsMode:b,namespaceVariableName:x,reexports:$}of t)if(y){for(const{imported:S,reexported:A}of[...d||[],...$||[]])if(S==="*"&&A!=="*"){b||h(x,Re,E);break}}else{const S=n(g);let A=!1,N=!1;for(const{imported:k,reexported:I}of[...d||[],...$||[]]){let R,P;k==="default"?A||(A=!0,v!==x&&(P=v,R=qr[S])):k!=="*"||I==="*"||N||(N=!0,R=qe[S],P=x),R&&h(P,R,E)}}return`${$i(f,i,s,o,e,r,a)}${m.length>0?`${m.join(u)}${u}${u}`:""}`}function C_(t,n){return t[0]!=="."?t:n?(e=t).endsWith(".js")?e:e+".js":$_(t);var e}const Np=new Set([...Es(["assert","async_hooks","buffer","child_process","cluster","console","constants","crypto","dgram","diagnostics_channel","dns","domain","events","fs","http","http2","https","inspector","module","net","os","path","perf_hooks","process","punycode","querystring","readline","repl","stream","string_decoder","timers","tls","trace_events","tty","url","util","v8","vm","wasi","worker_threads","zlib"]),"assert/strict","dns/promises","fs/promises","path/posix","path/win32","readline/promises","stream/consumers","stream/promises","stream/web","timers/promises","util/types"]);function Pi(t,n){const e=n.map(({importPath:r})=>r).filter(r=>Np.has(r)||r.startsWith("node:"));e.length!==0&&t(V,function(r){return{code:ym,ids:r,message:`Creating a browser bundle that depends on Node.js built-in modules (${mt(r)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`}}(e))}const Kr=(t,n)=>t.split(".").map(n).join("");function Oi(t,n,e,r,{_:a,getPropertyAccess:i}){const s=t.split(".");s[0]=(typeof e=="function"?e(s[0]):e[s[0]])||s[0];const o=s.pop();let _=n,l=[...s.map(u=>(_+=i(u),`${_}${a}=${a}${_}${a}||${a}{}`)),`${_}${i(o)}`].join(`,${a}`)+`${a}=${a}${r}`;return s.length>0&&(l=`(${l})`),l}function S_(t){let n=t.length;for(;n--;){const{imports:e,reexports:r}=t[n];if(e||r)return t.slice(0,n+1)}return[]}const Tp=({dependencies:t,exports:n})=>{const e=new Set(n.map(r=>r.exported));e.add("default");for(const{reexports:r}of t)if(r)for(const a of r)a.reexported!=="*"&&e.add(a.reexported);return e},jp=(t,n,{_:e,cnst:r,getObject:a,n:i})=>t?`${i}${n}${r} _starExcludes${e}=${e}${a([...t].map(s=>[s,"1"]),{lineBreakIndent:{base:n,t:n}})};`:"",Lp=(t,n,{_:e,n:r})=>t.length>0?`${r}${n}var ${t.join(`,${e}`)};`:"",Mp=(t,n,e)=>zi(t.filter(r=>r.hoisted).map(r=>({name:r.exported,value:r.local})),n,e);function zi(t,n,{_:e,n:r}){return t.length===0?"":t.length===1?`exports('${t[0].name}',${e}${t[0].value});${r}${r}`:`exports({${r}`+t.map(({name:a,value:i})=>`${n}${a}:${e}${i}`).join(`,${r}`)+`${r}});${r}${r}`}const Dp=(t,n,e)=>zi(t.filter(r=>r.expression).map(r=>({name:r.exported,value:r.local})),n,e),Pp=(t,n,e)=>zi(t.filter(r=>r.local===ce).map(r=>({name:r.exported,value:ce})),n,e);function Fi(t,n,e){return t?`${n}${Kr(t,e)}`:"null"}var Op={amd:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,id:s,indent:o,intro:_,isEntryFacade:l,isModuleFacade:u,namedExportsMode:f,log:m,outro:h,snippets:v},{amd:d,esModule:g,externalLiveBindings:y,freeze:E,interop:b,namespaceToStringTag:x,strict:$}){Pi(m,e);const S=e.map(w=>`'${C_(w.importPath,d.forceJsExtensionForImports)}'`),A=e.map(w=>w.name),{n:N,getNonArrowFunctionIntro:k,_:I}=v;f&&i&&(A.unshift("exports"),S.unshift("'exports'")),n.has("require")&&(A.unshift("require"),S.unshift("'require'")),n.has("module")&&(A.unshift("module"),S.unshift("'module'"));const R=E_(d,s),P=(R?`'${R}',${I}`:"")+(S.length>0?`[${S.join(`,${I}`)}],${I}`:""),B=$?`${I}'use strict';`:"";t.prepend(`${_}${Jr(e,b,y,E,x,n,o,v)}`);const D=Hr(r,e,f,b,v,o,y);let z=Wr(f&&i,l&&(g===!0||g==="if-default-prop"&&a),u&&x,v);z&&(z=N+N+z),t.append(`${D}${z}${h}`).indent(o).prepend(`${d.define}(${P}(${k(A,{isAsync:!1,name:null})}{${B}${N}${N}`).append(`${N}${N}}));`)},cjs:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,indent:s,intro:o,isEntryFacade:_,isModuleFacade:l,namedExportsMode:u,outro:f,snippets:m},{compact:h,esModule:v,externalLiveBindings:d,freeze:g,interop:y,namespaceToStringTag:E,strict:b}){const{_:x,n:$}=m,S=b?`'use strict';${$}${$}`:"";let A=Wr(u&&i,_&&(v===!0||v==="if-default-prop"&&a),l&&E,m);A&&(A+=$+$);const N=function(R,{_:P,cnst:B,n:D},z){let w="",T=!1;for(const{importPath:F,name:K,reexports:rn,imports:an}of R)rn||an?(w+=z&&T?",":`${w?`;${D}`:""}${B} `,T=!0,w+=`${K}${P}=${P}require('${F}')`):(w&&(w+=z&&!T?",":`;${D}`),T=!1,w+=`require('${F}')`);return w?`${w};${D}${D}`:""}(e,m,h),k=Jr(e,y,d,g,E,n,s,m);t.prepend(`${S}${o}${A}${N}${k}`);const I=Hr(r,e,u,y,m,s,d,`module.exports${x}=${x}`);t.append(`${I}${f}`)},es:function(t,{accessedGlobals:n,indent:e,intro:r,outro:a,dependencies:i,exports:s,snippets:o},{externalLiveBindings:_,freeze:l,namespaceToStringTag:u}){const{n:f}=o,m=function(v,{_:d}){const g=[];for(const{importPath:y,reexports:E,imports:b,name:x,assertions:$}of v){const S=`'${y}'${$?`${d}assert${d}${$}`:""};`;if(E||b){if(b){let A=null,N=null;const k=[];for(const I of b)I.imported==="default"?A=I:I.imported==="*"?N=I:k.push(I);N&&g.push(`import${d}*${d}as ${N.local} from${d}${S}`),A&&k.length===0?g.push(`import ${A.local} from${d}${S}`):k.length>0&&g.push(`import ${A?`${A.local},${d}`:""}{${d}${k.map(I=>I.imported===I.local?I.imported:`${I.imported} as ${I.local}`).join(`,${d}`)}${d}}${d}from${d}${S}`)}if(E){let A=null;const N=[],k=[];for(const I of E)I.reexported==="*"?A=I:I.imported==="*"?N.push(I):k.push(I);if(A&&g.push(`export${d}*${d}from${d}${S}`),N.length>0){b&&b.some(I=>I.imported==="*"&&I.local===x)||g.push(`import${d}*${d}as ${x} from${d}${S}`);for(const I of N)g.push(`export${d}{${d}${x===I.reexported?x:`${x} as ${I.reexported}`} };`)}k.length>0&&g.push(`export${d}{${d}${k.map(I=>I.imported===I.reexported?I.imported:`${I.imported} as ${I.reexported}`).join(`,${d}`)}${d}}${d}from${d}${S}`)}}else g.push(`import${d}${S}`)}return g}(i,o);m.length>0&&(r+=m.join(f)+f+f),(r+=$i(null,n,e,o,_,l,u))&&t.prepend(r);const h=function(v,{_:d,cnst:g}){const y=[],E=[];for(const b of v)b.expression&&y.push(`${g} ${b.local}${d}=${d}${b.expression};`),E.push(b.exported===b.local?b.local:`${b.local} as ${b.exported}`);return E.length>0&&y.push(`export${d}{${d}${E.join(`,${d}`)}${d}};`),y}(s,o);h.length>0&&t.append(f+f+h.join(f).trim()),a&&t.append(a),t.trim()},iife:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,indent:s,intro:o,namedExportsMode:_,log:l,outro:u,snippets:f},{compact:m,esModule:h,extend:v,freeze:d,externalLiveBindings:g,globals:y,interop:E,name:b,namespaceToStringTag:x,strict:$}){const{_:S,getNonArrowFunctionIntro:A,getPropertyAccess:N,n:k}=f,I=b&&b.includes("."),R=!v&&!I;if(b&&R&&(Os(P=b)||Ps.test(P)))return L(function(_n){return{code:mm,message:`Given name "${_n}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`,url:wn(Qf)}}(b));var P;Pi(l,e);const B=S_(e),D=B.map(_n=>_n.globalName||"null"),z=B.map(_n=>_n.name);i&&!b&&l(V,{code:Us,message:'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.',url:wn(Gs)}),_&&i&&(v?(D.unshift(`this${Kr(b,N)}${S}=${S}this${Kr(b,N)}${S}||${S}{}`),z.unshift("exports")):(D.unshift("{}"),z.unshift("exports")));const w=$?`${s}'use strict';${k}`:"",T=Jr(e,E,g,d,x,n,s,f);t.prepend(`${o}${T}`);let F=`(${A(z,{isAsync:!1,name:null})}{${k}${w}${k}`;i&&(!b||v&&_||(F=(R?`var ${b}`:`this${Kr(b,N)}`)+`${S}=${S}${F}`),I&&(F=function(_n,ln,Cn,{_:sn,getPropertyAccess:Nn,s:Yt},Tn){const Sn=_n.split(".");Sn[0]=(typeof Cn=="function"?Cn(Sn[0]):Cn[Sn[0]])||Sn[0],Sn.pop();let he=ln;return Sn.map(fs=>(he+=Nn(fs),`${he}${sn}=${sn}${he}${sn}||${sn}{}${Yt}`)).join(Tn?",":`
`)+(Tn&&Sn.length>0?";":`
`)}(b,"this",y,f,m)+F));let K=`${k}${k}})(${D.join(`,${S}`)});`;i&&!v&&_&&(K=`${k}${k}${s}return exports;${K}`);const rn=Hr(r,e,_,E,f,s,g);let an=Wr(_&&i,h===!0||h==="if-default-prop"&&a,x,f);an&&(an=k+k+an),t.append(`${rn}${an}${u}`).indent(s).prepend(F).append(K)},system:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasExports:a,indent:i,intro:s,snippets:o,outro:_,usesTopLevelAwait:l},{externalLiveBindings:u,freeze:f,name:m,namespaceToStringTag:h,strict:v,systemNullSetters:d}){const{_:g,getFunctionIntro:y,getNonArrowFunctionIntro:E,n:b,s:x}=o,{importBindings:$,setters:S,starExcludes:A}=function(P,B,D,{_:z,cnst:w,getObject:T,getPropertyAccess:F,n:K}){const rn=[],an=[];let _n=null;for(const{imports:ln,reexports:Cn}of P){const sn=[];if(ln)for(const Nn of ln)rn.push(Nn.local),Nn.imported==="*"?sn.push(`${Nn.local}${z}=${z}module;`):sn.push(`${Nn.local}${z}=${z}module${F(Nn.imported)};`);if(Cn){const Nn=[];let Yt=!1;for(const{imported:Tn,reexported:Sn}of Cn)Sn==="*"?Yt=!0:Nn.push([Sn,Tn==="*"?"module":`module${F(Tn)}`]);if(Nn.length>1||Yt){const Tn=T(Nn,{lineBreakIndent:null});Yt?(_n||(_n=Tp({dependencies:P,exports:B})),sn.push(`${w} setter${z}=${z}${Tn};`,`for${z}(${w} name in module)${z}{`,`${D}if${z}(!_starExcludes[name])${z}setter[name]${z}=${z}module[name];`,"}","exports(setter);")):sn.push(`exports(${Tn});`)}else{const[Tn,Sn]=Nn[0];sn.push(`exports('${Tn}',${z}${Sn});`)}}an.push(sn.join(`${K}${D}${D}${D}`))}return{importBindings:rn,setters:an,starExcludes:_n}}(e,r,i,o),N=m?`'${m}',${g}`:"",k=n.has("module")?["exports","module"]:a?["exports"]:[];let I=`System.register(${N}[`+e.map(({importPath:P})=>`'${P}'`).join(`,${g}`)+`],${g}(${E(k,{isAsync:!1,name:null})}{${b}${i}${v?"'use strict';":""}`+jp(A,i,o)+Lp($,i,o)+`${b}${i}return${g}{${S.length>0?`${b}${i}${i}setters:${g}[${S.map(P=>P?`${y(["module"],{isAsync:!1,name:null})}{${b}${i}${i}${i}${P}${b}${i}${i}}`:d?"null":`${y([],{isAsync:!1,name:null})}{}`).join(`,${g}`)}],`:""}${b}`;I+=`${i}${i}execute:${g}(${E([],{isAsync:l,name:null})}{${b}${b}`;const R=`${i}${i}})${b}${i}}${x}${b}}));`;t.prepend(s+$i(null,n,i,o,u,f,h)+Mp(r,i,o)).append(`${_}${b}${b}`+Dp(r,i,o)+Pp(r,i,o)).indent(`${i}${i}${i}`).append(R).prepend(I)},umd:function(t,{accessedGlobals:n,dependencies:e,exports:r,hasDefaultExport:a,hasExports:i,id:s,indent:o,intro:_,namedExportsMode:l,log:u,outro:f,snippets:m},{amd:h,compact:v,esModule:d,extend:g,externalLiveBindings:y,freeze:E,interop:b,name:x,namespaceToStringTag:$,globals:S,noConflict:A,strict:N}){const{_:k,cnst:I,getFunctionIntro:R,getNonArrowFunctionIntro:P,getPropertyAccess:B,n:D,s:z}=m,w=v?"f":"factory",T=v?"g":"global";if(i&&!x)return L({code:Us,message:'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.',url:wn(Gs)});Pi(u,e);const F=e.map(Rn=>`'${C_(Rn.importPath,h.forceJsExtensionForImports)}'`),K=e.map(Rn=>`require('${Rn.importPath}')`),rn=S_(e),an=rn.map(Rn=>Fi(Rn.globalName,T,B)),_n=rn.map(Rn=>Rn.name);l&&(i||A)&&(F.unshift("'exports'"),K.unshift("exports"),an.unshift(Oi(x,T,S,(g?`${Fi(x,T,B)}${k}||${k}`:"")+"{}",m)),_n.unshift("exports"));const ln=E_(h,s),Cn=(ln?`'${ln}',${k}`:"")+(F.length>0?`[${F.join(`,${k}`)}],${k}`:""),sn=h.define,Nn=!l&&i?`module.exports${k}=${k}`:"",Yt=N?`${k}'use strict';${D}`:"";let Tn;if(A){const Rn=v?"e":"exports";let ms;!l&&i?ms=`${I} ${Rn}${k}=${k}${Oi(x,T,S,`${w}(${an.join(`,${k}`)})`,m)};`:ms=`${I} ${Rn}${k}=${k}${an.shift()};${D}${o}${o}${w}(${[Rn,...an].join(`,${k}`)});`,Tn=`(${R([],{isAsync:!1,name:null})}{${D}${o}${o}${I} current${k}=${k}${function(f1,m1,{_:nc,getPropertyAccess:p1}){let d1=m1;return f1.split(".").map(h1=>d1+=p1(h1)).join(`${nc}&&${nc}`)}(x,T,m)};${D}${o}${o}${ms}${D}${o}${o}${Rn}.noConflict${k}=${k}${R([],{isAsync:!1,name:null})}{${k}${Fi(x,T,B)}${k}=${k}current;${k}return ${Rn}${z}${k}};${D}${o}})()`}else Tn=`${w}(${an.join(`,${k}`)})`,!l&&i&&(Tn=Oi(x,T,S,Tn,m));const Sn=i||A&&l||an.length>0,he=[w];Sn&&he.unshift(T);const fs=Sn?`this,${k}`:"",s1=Sn?`(${T}${k}=${k}typeof globalThis${k}!==${k}'undefined'${k}?${k}globalThis${k}:${k}${T}${k}||${k}self,${k}`:"",o1=Sn?")":"",_1=Sn?`${o}typeof exports${k}===${k}'object'${k}&&${k}typeof module${k}!==${k}'undefined'${k}?${k}${Nn}${w}(${K.join(`,${k}`)})${k}:${D}`:"",l1=`(${P(he,{isAsync:!1,name:null})}{${D}`+_1+`${o}typeof ${sn}${k}===${k}'function'${k}&&${k}${sn}.amd${k}?${k}${sn}(${Cn}${w})${k}:${D}${o}${s1}${Tn}${o1};${D}})(${fs}(${P(_n,{isAsync:!1,name:null})}{${Yt}${D}`,c1=D+D+"}));";t.prepend(`${_}${Jr(e,b,y,E,$,n,o,m)}`);const u1=Hr(r,e,l,b,m,o,y);let ha=Wr(l&&i,d===!0||d==="if-default-prop"&&a,$,m);ha&&(ha=D+D+ha),t.append(`${u1}${ha}${f}`).trim().indent(o).append(c1).prepend(l1)}};const A_=(t,n)=>n?`${t}
${n}`:t,I_=(t,n)=>n?`${t}

${n}`:t;async function zp(t,n,e){try{let[s,o,_,l]=await Promise.all([n.hookReduceValue("banner",t.banner(e),[e],A_),n.hookReduceValue("footer",t.footer(e),[e],A_),n.hookReduceValue("intro",t.intro(e),[e],I_),n.hookReduceValue("outro",t.outro(e),[e],I_)]);return _&&(_+=`

`),l&&(l=`

${l}`),s&&(s+=`
`),o&&(o=`
`+o),{banner:s,footer:o,intro:_,outro:l}}catch(s){return L((r=s.message,a=s.hook,i=s.plugin,{code:rm,message:`Could not retrieve "${a}". Check configuration of plugin "${i}".
	Error Message: ${r}`}))}var r,a,i}const Fp={amd:Yr,cjs:Yr,es:N_,iife:Yr,system:N_,umd:Yr};function Bp(t,n,e,r,a,i,s,o,_,l,u,f,m,h){const v=[...t].reverse();for(const d of v)d.scope.addUsedOutsideNames(r,a,f,m);(function(d,g,y){for(const E of g){for(const b of E.scope.variables.values())b.included&&!(b.renderBaseName||b instanceof it&&b.getOriginalVariable()!==b)&&b.setRenderNames(null,et(b.name,d,b.forbiddenNames));if(y.has(E)){const b=E.namespace;b.setRenderNames(null,et(b.name,d,b.forbiddenNames))}}})(r,v,h),Fp[a](r,e,n,i,s,o,_,l,u);for(const d of v)d.scope.deconflict(a,f,m)}function N_(t,n,e,r,a,i,s,o,_){for(const l of e.dependencies)(a||l instanceof te)&&(l.variableName=et(l.suggestedVariableName,t,null));for(const l of n){const u=l.module,f=l.name;l.isNamespace&&(a||u instanceof fn)?l.setRenderNames(null,(u instanceof fn?o.get(u):s.get(u)).variableName):u instanceof fn&&f==="default"?l.setRenderNames(null,et([...u.exportedVariables].some(([m,h])=>h==="*"&&m.included)?u.suggestedVariableName+"__default":u.suggestedVariableName,t,l.forbiddenNames)):l.setRenderNames(null,et(f,t,l.forbiddenNames))}for(const l of _)l.setRenderNames(null,et(l.name,t,l.forbiddenNames))}function Yr(t,n,{deconflictedDefault:e,deconflictedNamespace:r,dependencies:a},i,s,o,_,l){for(const u of a)u.variableName=et(u.suggestedVariableName,t,null);for(const u of r)u.namespaceVariableName=et(`${u.suggestedVariableName}__namespace`,t,null);for(const u of e)u.defaultVariableName=r.has(u)&&fp(i(u.id),o)?u.namespaceVariableName:et(`${u.suggestedVariableName}__default`,t,null);for(const u of n){const f=u.module;if(f instanceof fn){const m=l.get(f),h=u.name;if(h==="default"){const v=i(f.id),d=qr[v]?m.defaultVariableName:m.variableName;Vr(v,o)?u.setRenderNames(d,"default"):u.setRenderNames(null,d)}else h==="*"?u.setRenderNames(null,qe[i(f.id)]?m.namespaceVariableName:m.variableName):u.setRenderNames(m.variableName,null)}else{const m=_.get(f);s&&u.isNamespace?u.setRenderNames(null,m.exportMode==="default"?m.namespaceVariableName:m.variableName):m.exportMode==="default"?u.setRenderNames(null,m.variableName):u.setRenderNames(m.variableName,m.getVariableExportName(u))}}}function Gp(t,{exports:n,name:e,format:r},a,i){const s=t.getExportNames();if(n==="default"){if(s.length!==1||s[0]!=="default")return L(to("default",s,a))}else if(n==="none"&&s.length>0)return L(to("none",s,a));return n==="auto"&&(s.length===0?n="none":s.length===1&&s[0]==="default"?n="default":(r!=="es"&&r!=="system"&&s.includes("default")&&i(V,function(o,_){return{code:$m,id:o,message:`Entry module "${H(o)}" is using named and default exports together. Consumers of your bundle will have to use \`${_||"chunk"}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,url:wn(Ra)}}(a,e)),n="named")),n}function Rp(t){const n=t.split(`
`),e=n.filter(i=>/^\t+/.test(i)),r=n.filter(i=>/^ {2,}/.test(i));if(e.length===0&&r.length===0)return null;if(e.length>=r.length)return"	";const a=r.reduce((i,s)=>{const o=/^ +/.exec(s)[0].length;return Math.min(o,i)},1/0);return" ".repeat(a)}function T_(t,n,e,r,a,i){const s=t.getDependenciesToBeIncluded();for(const o of s){if(o instanceof fn){n.push(i.get(o));continue}const _=a.get(o);_===r?e.has(o)||(e.add(o),T_(o,n,e,r,a,i)):n.push(_)}}const Bi="!~{",Gi="}~",Ri=new RegExp(`${Bi}[0-9a-zA-Z_$]{1,59}${Gi}`,"g"),Je=(t,n)=>t.replace(Ri,e=>n.get(e)||e),qp=(t,n,e)=>t.replace(Ri,r=>r===n?e:r),Vp=(t,n)=>{const e=new Set,r=t.replace(Ri,a=>n.has(a)?(e.add(a),`${Bi}${"0".repeat(a.length-5)}${Gi}`):a);return{containedPlaceholders:e,transformedCode:r}},Zr=Symbol("bundleKeys"),qi={type:"placeholder"};function j_(t,n,e){return dr(t)?L(Mn(`Invalid pattern "${t}" for "${n}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`)):t.replace(/\[(\w+)(:\d+)?]/g,(r,a,i)=>{if(!e.hasOwnProperty(a)||i&&a!=="hash")return L(Mn(`"[${a}${i||""}]" is not a valid placeholder in the "${n}" pattern.`));const s=e[a](i&&Number.parseInt(i.slice(1)));return dr(s)?L(Mn(`Invalid substitution "${s}" for placeholder "[${a}]" in "${n}" pattern, can be neither absolute nor relative path.`)):s})}function L_(t,{[Zr]:n}){if(!n.has(t.toLowerCase()))return t;const e=yt(t);t=t.slice(0,Math.max(0,t.length-e.length));let r,a=1;for(;n.has((r=t+ ++a+e).toLowerCase()););return r}const Xp=new Set([".js",".jsx",".ts",".tsx",".mjs",".mts",".cjs",".cts"]);function Up(t,n,e,r){return(typeof n=="function"?n(t.id):n[t.id])||(e?(r(V,(i=t.id,s=t.variableName,{code:vm,id:i,message:`No name was provided for external module "${i}" in "output.globals" – guessing "${s}".`,names:[s],url:wn(tm)})),t.variableName):void 0);var i,s}class At{constructor(n,e,r,a,i,s,o,_,l,u,f,m,h,v,d){this.orderedModules=n,this.inputOptions=e,this.outputOptions=r,this.unsetOptions=a,this.pluginDriver=i,this.modulesById=s,this.chunkByModule=o,this.externalChunkByModule=_,this.facadeChunkByModule=l,this.includedNamespaces=u,this.manualChunkAlias=f,this.getPlaceholder=m,this.bundle=h,this.inputBase=v,this.snippets=d,this.entryModules=[],this.exportMode="named",this.facadeModule=null,this.namespaceVariableName="",this.variableName="",this.accessedGlobalsByScope=new Map,this.dependencies=new Set,this.dynamicEntryModules=[],this.dynamicName=null,this.exportNamesByVariable=new Map,this.exports=new Set,this.exportsByName=new Map,this.fileName=null,this.implicitEntryModules=[],this.implicitlyLoadedBefore=new Set,this.imports=new Set,this.includedDynamicImports=null,this.includedReexportsByModule=new Map,this.isEmpty=!0,this.name=null,this.needsExportsShim=!1,this.preRenderedChunkInfo=null,this.preliminaryFileName=null,this.renderedChunkInfo=null,this.renderedDependencies=null,this.renderedModules=Object.create(null),this.sortedExportNames=null,this.strictFacade=!1,this.execIndex=n.length>0?n[0].execIndex:1/0;const g=new Set(n);for(const y of n){o.set(y,this),y.namespace.included&&!r.preserveModules&&u.add(y),this.isEmpty&&y.isIncluded()&&(this.isEmpty=!1),(y.info.isEntry||r.preserveModules)&&this.entryModules.push(y);for(const E of y.includedDynamicImporters)g.has(E)||(this.dynamicEntryModules.push(y),y.info.syntheticNamedExports&&(u.add(y),this.exports.add(y.namespace)));y.implicitlyLoadedAfter.size>0&&this.implicitEntryModules.push(y)}this.suggestedVariableName=za(this.generateVariableName())}static generateFacade(n,e,r,a,i,s,o,_,l,u,f,m,h,v,d){const g=new At([],n,e,r,a,i,s,o,_,l,null,m,h,v,d);g.assignFacadeName(f,u),_.has(u)||_.set(u,g);for(const y of u.getDependenciesToBeIncluded())g.dependencies.add(y instanceof hn?s.get(y):o.get(y));return!g.dependencies.has(s.get(u))&&u.info.moduleSideEffects&&u.hasEffects()&&g.dependencies.add(s.get(u)),g.ensureReexportsAreAvailableForModule(u),g.facadeModule=u,g.strictFacade=!0,g}canModuleBeFacade(n,e){const r=n.getExportNamesByVariable();for(const a of this.exports)if(!r.has(a))return!1;for(const a of e)if(!(a.module===n||r.has(a)||a instanceof Dn&&r.has(a.getBaseVariable())))return!1;return!0}finalizeChunk(n,e,r){const a=this.getRenderedChunkInfo(),i=o=>Je(o,r),s=this.fileName=i(a.fileName);return{...a,code:n,dynamicImports:a.dynamicImports.map(i),fileName:s,implicitlyLoadedBefore:a.implicitlyLoadedBefore.map(i),importedBindings:Object.fromEntries(Object.entries(a.importedBindings).map(([o,_])=>[i(o),_])),imports:a.imports.map(i),map:e,referencedFiles:a.referencedFiles.map(i)}}generateExports(){this.sortedExportNames=null;const n=new Set(this.exports);if(this.facadeModule!==null&&(this.facadeModule.preserveSignature!==!1||this.strictFacade)){const e=this.facadeModule.getExportNamesByVariable();for(const[r,a]of e){this.exportNamesByVariable.set(r,[...a]);for(const i of a)this.exportsByName.set(i,r);n.delete(r)}}this.outputOptions.minifyInternalExports?function(e,r,a){let i=0;for(const s of e){let[o]=s.name;if(r.has(o))do o=Tr(++i),o.charCodeAt(0)===49&&(i+=9*64**(o.length-1),o=Tr(i));while(vr.has(o)||r.has(o));r.set(o,s),a.set(s,[o])}}(n,this.exportsByName,this.exportNamesByVariable):function(e,r,a){for(const i of e){let s=0,o=i.name;for(;r.has(o);)o=i.name+"$"+ ++s;r.set(o,i),a.set(i,[o])}}(n,this.exportsByName,this.exportNamesByVariable),(this.outputOptions.preserveModules||this.facadeModule&&this.facadeModule.info.isEntry)&&(this.exportMode=Gp(this,this.outputOptions,this.facadeModule.id,this.inputOptions.onLog))}generateFacades(){var a;const n=[],e=new Set([...this.entryModules,...this.implicitEntryModules]),r=new Set(this.dynamicEntryModules.map(({namespace:i})=>i));for(const i of e)if(i.preserveSignature)for(const s of i.getExportNamesByVariable().keys())this.chunkByModule.get(s.module)===this&&r.add(s);for(const i of e){const s=Array.from(new Set(i.chunkNames.filter(({isUserDefined:o})=>o).map(({name:o})=>o)),o=>({name:o}));if(s.length===0&&i.isUserDefinedEntryPoint&&s.push({}),s.push(...Array.from(i.chunkFileNames,o=>({fileName:o}))),s.length===0&&s.push({}),!this.facadeModule){const o=!this.outputOptions.preserveModules&&(i.preserveSignature==="strict"||i.preserveSignature==="exports-only"&&i.getExportNamesByVariable().size>0);o&&!this.canModuleBeFacade(i,r)||(this.facadeModule=i,this.facadeChunkByModule.set(i,this),i.preserveSignature&&(this.strictFacade=o),this.assignFacadeName(s.shift(),i,this.outputOptions.preserveModules))}for(const o of s)n.push(At.generateFacade(this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.modulesById,this.chunkByModule,this.externalChunkByModule,this.facadeChunkByModule,this.includedNamespaces,i,o,this.getPlaceholder,this.bundle,this.inputBase,this.snippets))}for(const i of this.dynamicEntryModules)i.info.syntheticNamedExports||(!this.facadeModule&&this.canModuleBeFacade(i,r)?(this.facadeModule=i,this.facadeChunkByModule.set(i,this),this.strictFacade=!0,this.dynamicName=Vi(i)):this.facadeModule===i&&!this.strictFacade&&this.canModuleBeFacade(i,r)?this.strictFacade=!0:(a=this.facadeChunkByModule.get(i))!=null&&a.strictFacade||(this.includedNamespaces.add(i),this.exports.add(i.namespace)));return this.outputOptions.preserveModules||this.addNecessaryImportsForFacades(),n}getChunkName(){return this.name??(this.name=this.outputOptions.sanitizeFileName(this.getFallbackChunkName()))}getExportNames(){return this.sortedExportNames??(this.sortedExportNames=[...this.exportsByName.keys()].sort())}getFileName(){return this.fileName||this.getPreliminaryFileName().fileName}getImportPath(n){return pr(Ts(n,this.getFileName(),this.outputOptions.format==="amd"&&!this.outputOptions.amd.forceJsExtensionForImports,!0))}getPreliminaryFileName(){var _;if(this.preliminaryFileName)return this.preliminaryFileName;let n,e=null;const{chunkFileNames:r,entryFileNames:a,file:i,format:s,preserveModules:o}=this.outputOptions;if(i)n=ft(i);else if(this.fileName===null){const[l,u]=o||(_=this.facadeModule)!=null&&_.isUserDefinedEntryPoint?[a,"output.entryFileNames"]:[r,"output.chunkFileNames"];n=j_(typeof l=="function"?l(this.getPreRenderedChunkInfo()):l,u,{format:()=>s,hash:f=>e||(e=this.getPlaceholder(u,f)),name:()=>this.getChunkName()}),e||(n=L_(n,this.bundle))}else n=this.fileName;return e||(this.bundle[n]=qi),this.preliminaryFileName={fileName:n,hashPlaceholder:e}}getRenderedChunkInfo(){return this.renderedChunkInfo?this.renderedChunkInfo:this.renderedChunkInfo={...this.getPreRenderedChunkInfo(),dynamicImports:this.getDynamicDependencies().map(Qr),fileName:this.getFileName(),implicitlyLoadedBefore:Array.from(this.implicitlyLoadedBefore,Qr),importedBindings:Hp(this.getRenderedDependencies(),Qr),imports:Array.from(this.dependencies,Qr),modules:this.renderedModules,referencedFiles:this.getReferencedFiles()}}getVariableExportName(n){return this.outputOptions.preserveModules&&n instanceof Ue?"*":this.exportNamesByVariable.get(n)[0]}link(){this.dependencies=function(n,e,r,a){const i=[],s=new Set;for(let _=e.length-1;_>=0;_--){const l=e[_];if(!s.has(l)){const u=[];T_(l,u,s,n,r,a),i.unshift(u)}}const o=new Set;for(const _ of i)for(const l of _)o.add(l);return o}(this,this.orderedModules,this.chunkByModule,this.externalChunkByModule);for(const n of this.orderedModules)this.addImplicitlyLoadedBeforeFromModule(n),this.setUpChunkImportsAndExportsForModule(n)}async render(){const{dependencies:n,exportMode:e,facadeModule:r,inputOptions:{onLog:a},outputOptions:i,pluginDriver:s,snippets:o}=this,{format:_,hoistTransitiveImports:l,preserveModules:u}=i;if(l&&!u&&r!==null)for(const I of n)I instanceof At&&this.inlineChunkDependencies(I);const f=this.getPreliminaryFileName(),{accessedGlobals:m,indent:h,magicString:v,renderedSource:d,usedModules:g,usesTopLevelAwait:y}=this.renderModules(f.fileName),E=[...this.getRenderedDependencies().values()],b=e==="none"?[]:this.getChunkExportDeclarations(_);let x=b.length>0,$=!1;for(const I of E){const{reexports:R}=I;R!=null&&R.length&&(x=!0,!$&&R.some(P=>P.reexported==="default")&&($=!0),_==="es"&&(I.reexports=R.filter(({reexported:P})=>!b.find(({exported:B})=>B===P))))}if(!$){for(const{exported:I}of b)if(I==="default"){$=!0;break}}const{intro:S,outro:A,banner:N,footer:k}=await zp(i,s,this.getRenderedChunkInfo());return Op[_](d,{accessedGlobals:m,dependencies:E,exports:b,hasDefaultExport:$,hasExports:x,id:f.fileName,indent:h,intro:S,isEntryFacade:u||r!==null&&r.info.isEntry,isModuleFacade:r!==null,log:a,namedExportsMode:e!=="default",outro:A,snippets:o,usesTopLevelAwait:y},i),N&&v.prepend(N),k&&v.append(k),{chunk:this,magicString:v,preliminaryFileName:f,usedModules:g}}addImplicitlyLoadedBeforeFromModule(n){const{chunkByModule:e,implicitlyLoadedBefore:r}=this;for(const a of n.implicitlyLoadedBefore){const i=e.get(a);i&&i!==this&&r.add(i)}}addNecessaryImportsForFacades(){for(const[n,e]of this.includedReexportsByModule)if(this.includedNamespaces.has(n))for(const r of e)this.imports.add(r)}assignFacadeName({fileName:n,name:e},r,a){n?this.fileName=n:this.name=this.outputOptions.sanitizeFileName(e||(a?this.getPreserveModulesChunkNameFromModule(r):Vi(r)))}checkCircularDependencyImport(n,e){var l;const r=n.module;if(r instanceof hn){const u=this.chunkByModule.get(r);let f;do f=e.alternativeReexportModules.get(n),f&&(this.chunkByModule.get(f)!==u&&this.inputOptions.onLog(V,(a=((l=r.getExportNamesByVariable().get(n))==null?void 0:l[0])||"*",i=r.id,s=f.id,o=e.id,_=this.outputOptions.preserveModules,{code:"CYCLIC_CROSS_CHUNK_REEXPORT",exporter:i,id:o,message:`Export "${a}" of module "${H(i)}" was reexported through module "${H(s)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in "${H(o)}" to point directly to the exporting module or ${_?'do not use "output.preserveModules"':'reconfigure "output.manualChunks"'} to ensure these modules end up in the same chunk.`,reexporter:s})),e=f);while(f)}var a,i,s,o,_}ensureReexportsAreAvailableForModule(n){const e=[],r=n.getExportNamesByVariable();for(const a of r.keys()){const i=a instanceof Dn,s=i?a.getBaseVariable():a;if(this.checkCircularDependencyImport(s,n),!(s instanceof Ue&&this.outputOptions.preserveModules)){const o=s.module;if(o instanceof hn){const _=this.chunkByModule.get(o);_&&_!==this&&(_.exports.add(s),e.push(s),i&&this.imports.add(s))}}}e.length>0&&this.includedReexportsByModule.set(n,e)}generateVariableName(){if(this.manualChunkAlias)return this.manualChunkAlias;const n=this.entryModules[0]||this.implicitEntryModules[0]||this.dynamicEntryModules[0]||this.orderedModules[this.orderedModules.length-1];return n?Vi(n):"chunk"}getChunkExportDeclarations(n){const e=[];for(const r of this.getExportNames()){if(r[0]==="*")continue;const a=this.exportsByName.get(r);if(!(a instanceof Dn)){const _=a.module;if(_){const l=this.chunkByModule.get(_);if(l!==this){if(!l||n!=="es")continue;const u=this.renderedDependencies.get(l);if(!u)continue;const{imports:f,reexports:m}=u,h=m==null?void 0:m.find(({reexported:d})=>d===r);if(!(f==null?void 0:f.find(({imported:d})=>d===(h==null?void 0:h.imported))))continue}}}let i=null,s=!1,o=a.getName(this.snippets.getPropertyAccess);if(a instanceof pt){for(const _ of a.declarations)if(_.parent instanceof Ge||_ instanceof Fr&&_.declaration instanceof Ge){s=!0;break}}else a instanceof Dn&&(i=o,n==="es"&&(o=a.renderName));e.push({exported:r,expression:i,hoisted:s,local:o})}return e}getDependenciesToBeDeconflicted(n,e,r){const a=new Set,i=new Set,s=new Set;for(const o of[...this.exportNamesByVariable.keys(),...this.imports])if(n||o.isNamespace){const _=o.module;if(_ instanceof fn){const l=this.externalChunkByModule.get(_);a.add(l),n&&(o.name==="default"?qr[r(_.id)]&&i.add(l):o.name==="*"&&qe[r(_.id)]&&s.add(l))}else{const l=this.chunkByModule.get(_);l!==this&&(a.add(l),n&&l.exportMode==="default"&&o.isNamespace&&s.add(l))}}if(e)for(const o of this.dependencies)a.add(o);return{deconflictedDefault:i,deconflictedNamespace:s,dependencies:a}}getDynamicDependencies(){return this.getIncludedDynamicImports().map(n=>n.facadeChunk||n.chunk||n.externalChunk||n.resolution).filter(n=>n!==this&&(n instanceof At||n instanceof te))}getDynamicImportStringAndAssertions(n,e){if(n instanceof fn){const r=this.externalChunkByModule.get(n);return[`'${r.getImportPath(e)}'`,r.getImportAssertions(this.snippets)]}return[n||"",this.outputOptions.format==="es"&&this.outputOptions.externalImportAssertions||null]}getFallbackChunkName(){return this.manualChunkAlias?this.manualChunkAlias:this.dynamicName?this.dynamicName:this.fileName?La(this.fileName):La(this.orderedModules[this.orderedModules.length-1].id)}getImportSpecifiers(){const{interop:n}=this.outputOptions,e=new Map;for(const r of this.imports){const a=r.module;let i,s;if(a instanceof fn){if(i=this.externalChunkByModule.get(a),s=r.name,s!=="default"&&s!=="*"&&n(a.id)==="defaultOnly")return L(ro(a.id,s,!1))}else i=this.chunkByModule.get(a),s=i.getVariableExportName(r);zn(e,i,js).push({imported:s,local:r.getName(this.snippets.getPropertyAccess)})}return e}getIncludedDynamicImports(){if(this.includedDynamicImports)return this.includedDynamicImports;const n=[];for(const e of this.orderedModules)for(const{node:r,resolution:a}of e.dynamicImports)r.included&&n.push(a instanceof hn?{chunk:this.chunkByModule.get(a),externalChunk:null,facadeChunk:this.facadeChunkByModule.get(a),node:r,resolution:a}:a instanceof fn?{chunk:null,externalChunk:this.externalChunkByModule.get(a),facadeChunk:null,node:r,resolution:a}:{chunk:null,externalChunk:null,facadeChunk:null,node:r,resolution:a});return this.includedDynamicImports=n}getPreRenderedChunkInfo(){if(this.preRenderedChunkInfo)return this.preRenderedChunkInfo;const{dynamicEntryModules:n,facadeModule:e,implicitEntryModules:r,orderedModules:a}=this;return this.preRenderedChunkInfo={exports:this.getExportNames(),facadeModuleId:e&&e.id,isDynamicEntry:n.length>0,isEntry:!!(e!=null&&e.info.isEntry),isImplicitEntry:r.length>0,moduleIds:a.map(({id:i})=>i),name:this.getChunkName(),type:"chunk"}}getPreserveModulesChunkNameFromModule(n){const e=M_(n);if(e)return e;const{preserveModulesRoot:r,sanitizeFileName:a}=this.outputOptions,i=a(Ee(n.id.split(Wp,1)[0])),s=yt(i),o=Xp.has(s)?i.slice(0,-s.length):i;return vt(o)?r&&Jn(o).startsWith(r)?o.slice(r.length).replace(/^[/\\]/,""):ne(this.inputBase,o):`_virtual/${ft(o)}`}getReexportSpecifiers(){const{externalLiveBindings:n,interop:e}=this.outputOptions,r=new Map;for(let a of this.getExportNames()){let i,s,o=!1;if(a[0]==="*"){const _=a.slice(1);e(_)==="defaultOnly"&&this.inputOptions.onLog(V,Lm(_)),o=n,i=this.externalChunkByModule.get(this.modulesById.get(_)),s=a="*"}else{const _=this.exportsByName.get(a);if(_ instanceof Dn)continue;const l=_.module;if(l instanceof hn){if(i=this.chunkByModule.get(l),i===this)continue;s=i.getVariableExportName(_),o=_.isReassigned}else{if(i=this.externalChunkByModule.get(l),s=_.name,s!=="default"&&s!=="*"&&e(l.id)==="defaultOnly")return L(ro(l.id,s,!0));o=n&&(s!=="default"||Vr(e(l.id),!0))}}zn(r,i,js).push({imported:s,needsLiveBinding:o,reexported:a})}return r}getReferencedFiles(){const n=new Set;for(const e of this.orderedModules)for(const r of e.importMetas){const a=r.getReferencedFileName(this.pluginDriver);a&&n.add(a)}return[...n]}getRenderedDependencies(){if(this.renderedDependencies)return this.renderedDependencies;const n=this.getImportSpecifiers(),e=this.getReexportSpecifiers(),r=new Map,a=this.getFileName();for(const i of this.dependencies){const s=n.get(i)||null,o=e.get(i)||null,_=i instanceof te||i.exportMode!=="default",l=i.getImportPath(a);r.set(i,{assertions:i instanceof te?i.getImportAssertions(this.snippets):null,defaultVariableName:i.defaultVariableName,globalName:i instanceof te&&(this.outputOptions.format==="umd"||this.outputOptions.format==="iife")&&Up(i,this.outputOptions.globals,(s||o)!==null,this.inputOptions.onLog),importPath:l,imports:s,isChunk:i instanceof At,name:i.variableName,namedExportsMode:_,namespaceVariableName:i.namespaceVariableName,reexports:o})}return this.renderedDependencies=r}inlineChunkDependencies(n){for(const e of n.dependencies)this.dependencies.has(e)||(this.dependencies.add(e),e instanceof At&&this.inlineChunkDependencies(e))}renderModules(n){const{accessedGlobalsByScope:e,dependencies:r,exportNamesByVariable:a,includedNamespaces:i,inputOptions:{onLog:s},isEmpty:o,orderedModules:_,outputOptions:l,pluginDriver:u,renderedModules:f,snippets:m}=this,{compact:h,dynamicImportFunction:v,format:d,freeze:g,namespaceToStringTag:y}=l,{_:E,cnst:b,n:x}=m;this.setDynamicImportResolutions(n),this.setImportMetaResolutions(n),this.setIdentifierRenderResolutions();const $=new class tc{constructor(w={}){this.intro=w.intro||"",this.separator=w.separator!==void 0?w.separator:`
`,this.sources=[],this.uniqueSources=[],this.uniqueSourceIndexByFilename={}}addSource(w){if(w instanceof Lt)return this.addSource({content:w,filename:w.filename,separator:this.separator});if(!As(w)||!w.content)throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");if(["filename","ignoreList","indentExclusionRanges","separator"].forEach(T=>{Ns.call(w,T)||(w[T]=w.content[T])}),w.separator===void 0&&(w.separator=this.separator),w.filename)if(Ns.call(this.uniqueSourceIndexByFilename,w.filename)){const T=this.uniqueSources[this.uniqueSourceIndexByFilename[w.filename]];if(w.content.original!==T.content)throw new Error(`Illegal source: same filename (${w.filename}), different contents`)}else this.uniqueSourceIndexByFilename[w.filename]=this.uniqueSources.length,this.uniqueSources.push({filename:w.filename,content:w.content.original});return this.sources.push(w),this}append(w,T){return this.addSource({content:new Lt(w),separator:T&&T.separator||""}),this}clone(){const w=new tc({intro:this.intro,separator:this.separator});return this.sources.forEach(T=>{w.addSource({filename:T.filename,content:T.content.clone(),separator:T.separator})}),w}generateDecodedMap(w={}){const T=[];let F;this.sources.forEach(rn=>{Object.keys(rn.content.storedNames).forEach(an=>{~T.indexOf(an)||T.push(an)})});const K=new Is(w.hires);return this.intro&&K.advance(this.intro),this.sources.forEach((rn,an)=>{an>0&&K.advance(this.separator);const _n=rn.filename?this.uniqueSourceIndexByFilename[rn.filename]:-1,ln=rn.content,Cn=Ta(ln.original);ln.intro&&K.advance(ln.intro),ln.firstChunk.eachNext(sn=>{const Nn=Cn(sn.start);sn.intro.length&&K.advance(sn.intro),rn.filename?sn.edited?K.addEdit(_n,sn.content,Nn,sn.storeName?T.indexOf(sn.original):-1):K.addUneditedChunk(_n,sn,ln.original,Nn,ln.sourcemapLocations):K.advance(sn.content),sn.outro.length&&K.advance(sn.outro)}),ln.outro&&K.advance(ln.outro),rn.ignoreList&&_n!==-1&&(F===void 0&&(F=[]),F.push(_n))}),{file:w.file?w.file.split(/[/\\]/).pop():void 0,sources:this.uniqueSources.map(rn=>w.file?Ss(w.file,rn.filename):rn.filename),sourcesContent:this.uniqueSources.map(rn=>w.includeContent?rn.content:null),names:T,mappings:K.raw,x_google_ignoreList:F}}generateMap(w){return new mr(this.generateDecodedMap(w))}getIndentString(){const w={};return this.sources.forEach(T=>{const F=T.content._getRawIndentString();F!==null&&(w[F]||(w[F]=0),w[F]+=1)}),Object.keys(w).sort((T,F)=>w[T]-w[F])[0]||"	"}indent(w){if(arguments.length||(w=this.getIndentString()),w==="")return this;let T=!this.intro||this.intro.slice(-1)===`
`;return this.sources.forEach((F,K)=>{const rn=F.separator!==void 0?F.separator:this.separator,an=T||K>0&&/\r?\n$/.test(rn);F.content.indent(w,{exclude:F.indentExclusionRanges,indentStart:an}),T=F.content.lastChar()===`
`}),this.intro&&(this.intro=w+this.intro.replace(/^[^\n]/gm,(F,K)=>K>0?w+F:F)),this}prepend(w){return this.intro=w+this.intro,this}toString(){const w=this.sources.map((T,F)=>{const K=T.separator!==void 0?T.separator:this.separator;return(F>0?K:"")+T.content.toString()}).join("");return this.intro+w}isEmpty(){return!(this.intro.length&&this.intro.trim()||this.sources.some(w=>!w.content.isEmpty()))}length(){return this.sources.reduce((w,T)=>w+T.content.length(),this.intro.length)}trimLines(){return this.trim("[\\r\\n]")}trim(w){return this.trimStart(w).trimEnd(w)}trimStart(w){const T=new RegExp("^"+(w||"\\s")+"+");if(this.intro=this.intro.replace(T,""),!this.intro){let F,K=0;do if(F=this.sources[K++],!F)break;while(!F.content.trimStartAborted(w))}return this}trimEnd(w){const T=new RegExp((w||"\\s")+"+$");let F,K=this.sources.length-1;do if(F=this.sources[K--],!F){this.intro=this.intro.replace(T,"");break}while(!F.content.trimEndAborted(w));return this}}({separator:`${x}${x}`}),S=function(z,w){if(w.indent!==!0)return w.indent;for(const T of z){const F=Rp(T.originalCode);if(F!==null)return F}return"	"}(_,l),A=[];let N="";const k=new Set,I=new Map,R={dynamicImportFunction:v,exportNamesByVariable:a,format:d,freeze:g,indent:S,namespaceToStringTag:y,pluginDriver:u,snippets:m,useOriginalName:null};let P=!1;for(const z of _){let w,T=0;if(z.isIncluded()||i.has(z)){const rn=z.render(R);({source:w}=rn),P||(P=rn.usesTopLevelAwait),T=w.length(),T&&(h&&w.lastLine().includes("//")&&w.append(`
`),I.set(z,w),$.addSource(w),A.push(z));const an=z.namespace;if(i.has(z)){const ln=an.renderBlock(R);an.renderFirst()?N+=x+ln:$.addSource(new Lt(ln))}const _n=e.get(z.scope);if(_n)for(const ln of _n)k.add(ln)}const{renderedExports:F,removedExports:K}=z.getRenderedExports();f[z.id]={get code(){return(w==null?void 0:w.toString())??null},originalLength:z.originalCode.length,removedExports:K,renderedExports:F,renderedLength:T}}N&&$.prepend(N+x+x),this.needsExportsShim&&$.prepend(`${x}${b} ${ce}${E}=${E}void 0;${x}${x}`);const B=h?$:$.trim();var D;return o&&this.getExportNames().length===0&&r.size===0&&s(V,{code:"EMPTY_BUNDLE",message:`Generated an empty chunk: "${D=this.getChunkName()}".`,names:[D]}),{accessedGlobals:k,indent:S,magicString:$,renderedSource:B,usedModules:A,usesTopLevelAwait:P}}setDynamicImportResolutions(n){const{accessedGlobalsByScope:e,outputOptions:r,pluginDriver:a,snippets:i}=this;for(const s of this.getIncludedDynamicImports())if(s.chunk){const{chunk:o,facadeChunk:_,node:l,resolution:u}=s;o===this?l.setInternalResolution(u.namespace):l.setExternalResolution((_||o).exportMode,u,r,i,a,e,`'${(_||o).getImportPath(n)}'`,!(_!=null&&_.strictFacade)&&o.exportNamesByVariable.get(u.namespace)[0],null)}else{const{node:o,resolution:_}=s,[l,u]=this.getDynamicImportStringAndAssertions(_,n);o.setExternalResolution("external",_,r,i,a,e,l,!1,u)}}setIdentifierRenderResolutions(){const{format:n,interop:e,namespaceToStringTag:r,preserveModules:a,externalLiveBindings:i}=this.outputOptions,s=new Set;for(const _ of this.getExportNames()){const l=this.exportsByName.get(_);n!=="es"&&n!=="system"&&l.isReassigned&&!l.isId?l.setRenderNames("exports",_):l instanceof Dn?s.add(l):l.setRenderNames(null,null)}for(const _ of this.orderedModules)if(_.needsExportShim){this.needsExportsShim=!0;break}const o=new Set(["Object","Promise"]);switch(this.needsExportsShim&&o.add(ce),r&&o.add("Symbol"),n){case"system":o.add("module").add("exports");break;case"es":break;case"cjs":o.add("module").add("require").add("__filename").add("__dirname");default:o.add("exports");for(const _ of Ci)o.add(_)}Bp(this.orderedModules,this.getDependenciesToBeDeconflicted(n!=="es"&&n!=="system",n==="amd"||n==="umd"||n==="iife",e),this.imports,o,n,e,a,i,this.chunkByModule,this.externalChunkByModule,s,this.exportNamesByVariable,this.accessedGlobalsByScope,this.includedNamespaces)}setImportMetaResolutions(n){const{accessedGlobalsByScope:e,includedNamespaces:r,orderedModules:a,outputOptions:{format:i}}=this;for(const s of a){for(const o of s.importMetas)o.setResolution(i,e,n);r.has(s)&&s.namespace.prepare(e)}}setUpChunkImportsAndExportsForModule(n){const e=new Set(n.includedImports);if(!this.outputOptions.preserveModules&&this.includedNamespaces.has(n)){const r=n.namespace.getMemberVariables();for(const a of Object.values(r))e.add(a)}for(let r of e){r instanceof it&&(r=r.getOriginalVariable()),r instanceof Dn&&(r=r.getBaseVariable());const a=this.chunkByModule.get(r.module);a!==this&&(this.imports.add(r),r.module instanceof hn&&(this.checkCircularDependencyImport(r,n),r instanceof Ue&&this.outputOptions.preserveModules||a.exports.add(r)))}(this.includedNamespaces.has(n)||n.info.isEntry&&n.preserveSignature!==!1||n.includedDynamicImporters.some(r=>this.chunkByModule.get(r)!==this))&&this.ensureReexportsAreAvailableForModule(n);for(const{node:r,resolution:a}of n.dynamicImports)r.included&&a instanceof hn&&this.chunkByModule.get(a)===this&&!this.includedNamespaces.has(a)&&(this.includedNamespaces.add(a),this.ensureReexportsAreAvailableForModule(a))}}function Vi(t){return M_(t)??La(t.id)}function M_(t){var n,e;return((n=t.chunkNames.find(({isUserDefined:r})=>r))==null?void 0:n.name)??((e=t.chunkNames[0])==null?void 0:e.name)}function Hp(t,n){const e={};for(const[r,a]of t){const i=new Set;if(a.imports)for(const{imported:s}of a.imports)i.add(s);if(a.reexports)for(const{imported:s}of a.reexports)i.add(s);e[n(r)]=[...i]}return e}const Wp=/[#?]/,Qr=t=>t.getFileName();function*D_(t){for(const n of t)yield*n}function Jp(t,n,e,r){const{chunkDefinitions:a,modulesInManualChunks:i}=function(f){const m=[],h=new Set(f.keys()),v=Object.create(null);for(const[d,g]of f)Kp(d,v[g]||(v[g]=[]),h);for(const[d,g]of Object.entries(v))m.push({alias:d,modules:g});return{chunkDefinitions:m,modulesInManualChunks:h}}(n),{allEntries:s,dependentEntriesByModule:o,dynamicallyDependentEntriesByDynamicEntry:_,dynamicImportsByEntry:l}=function(f){const m=new Set,h=new Map,v=[],d=new Set(f);let g=0;for(const x of d){const $=new Set;v.push($);const S=new Set([x]);for(const A of S){zn(h,A,Dt).add(g);for(const N of A.getDependenciesToBeIncluded())N instanceof fn||S.add(N);for(const{resolution:N}of A.dynamicImports)N instanceof hn&&N.includedDynamicImporters.length>0&&!d.has(N)&&(m.add(N),d.add(N),$.add(N));for(const N of A.implicitlyLoadedBefore)d.has(N)||(m.add(N),d.add(N))}g++}const y=[...d],{dynamicEntries:E,dynamicImportsByEntry:b}=function(x,$,S){const A=new Map,N=new Set;for(const[I,R]of x.entries())A.set(R,I),$.has(R)&&N.add(I);const k=[];for(const I of S){const R=new Set;for(const P of I)R.add(A.get(P));k.push(R)}return{dynamicEntries:N,dynamicImportsByEntry:k}}(y,m,v);return{allEntries:y,dependentEntriesByModule:h,dynamicallyDependentEntriesByDynamicEntry:Yp(h,E,y),dynamicImportsByEntry:b}}(t),u=P_(function*(f,m){for(const[h,v]of f)m.has(h)||(yield{dependentEntries:v,modules:[h]})}(o,i));return function(f,m,h,v){const d=v.map(()=>0n),g=v.map((b,x)=>m.has(x)?-1n:0n);let y=1n;for(const{dependentEntries:b}of f){for(const x of b)d[x]|=y;y<<=1n}const E=m;for(const[b,x]of E){E.delete(b);const $=g[b];let S=$;for(const A of x)S&=d[A]|g[A];if(S!==$){g[b]=S;for(const A of h[b])zn(E,A,Dt).add(b)}}y=1n;for(const{dependentEntries:b}of f){for(const x of b)(g[x]&y)===y&&b.delete(x);y<<=1n}}(u,_,l,s),a.push(...function(f,m,h,v){$n("optimize chunks",3);const d=function(g,y,E){const b=[],x=[],$=new Map,S=[];let A=0n,N=1n;for(const{dependentEntries:k,modules:I}of g){const R={containedAtoms:N,correlatedAtoms:0n,dependencies:new Set,dependentChunks:new Set,dependentEntries:k,modules:I,pure:!0,size:0};let P=0,B=!0;for(const D of I)$.set(D,R),D.isIncluded()&&(B&&(B=!D.hasEffects()),P+=E>1?D.estimateSize():1);R.pure=B,R.size=P,S.push(P),B||(A|=N),(P<E?b:x).push(R),N<<=1n}return b.length===0?null:(A|=function(k,I,R,P){const B=new Map;let D=0n;const z=[];for(let w=0;w<R;w++)z.push(0n);for(const w of k){w.sort(Qp);for(const T of w){const{dependencies:F,dependentEntries:K,modules:rn}=T;for(const _n of rn)for(const ln of _n.getDependenciesToBeIncluded())if(ln instanceof fn)ln.info.moduleSideEffects&&(T.containedAtoms|=zn(B,ln,()=>{const Cn=P;return P<<=1n,D|=Cn,Cn}));else{const Cn=I.get(ln);Cn&&Cn!==T&&(F.add(Cn),Cn.dependentChunks.add(T))}const{containedAtoms:an}=T;for(const _n of K)z[_n]|=an}}for(const w of k)for(const T of w){const{dependentEntries:F}=T;T.correlatedAtoms=-1n;for(const K of F)T.correlatedAtoms&=z[K]}return D}([x,b],$,y,N),{big:new Set(x),sideEffectAtoms:A,sizeByAtom:S,small:new Set(b)})}(f,m,h);return d?(h>1&&v("info",eo(f.length,d.small.size,"Initially")),function(g,y){const{small:E}=g;for(const b of E){const x=Zp(b,g,y<=1?1:1/0);if(x){const{containedAtoms:$,correlatedAtoms:S,modules:A,pure:N,size:k}=b;E.delete(b),O_(x,y,g).delete(x),x.modules.push(...A),x.size+=k,x.pure&&(x.pure=N);const{dependencies:I,dependentChunks:R,dependentEntries:P}=x;x.correlatedAtoms&=S,x.containedAtoms|=$;for(const B of b.dependentEntries)P.add(B);for(const B of b.dependencies)I.add(B),B.dependentChunks.delete(b),B.dependentChunks.add(x);for(const B of b.dependentChunks)R.add(B),B.dependencies.delete(b),B.dependencies.add(x);I.delete(x),R.delete(x),O_(x,y,g).add(x)}}}(d,h),h>1&&v("info",eo(d.small.size+d.big.size,d.small.size,"After merging chunks")),yn("optimize chunks",3),[...d.small,...d.big]):(yn("optimize chunks",3),f)}(P_(u),s.length,e,r).map(({modules:f})=>({alias:null,modules:f}))),a}function Kp(t,n,e){const r=new Set([t]);for(const a of r){e.add(a),n.push(a);for(const i of a.dependencies)i instanceof fn||e.has(i)||r.add(i)}}function Yp(t,n,e){const r=new Map;for(const a of n){const i=zn(r,a,Dt),s=e[a];for(const o of D_([s.includedDynamicImporters,s.implicitlyLoadedAfter]))for(const _ of t.get(o))i.add(_)}return r}function P_(t){var n;const e=Object.create(null);for(const{dependentEntries:r,modules:a}of t){let i=0n;for(const s of r)i|=1n<<BigInt(s);(e[n=String(i)]||(e[n]={dependentEntries:new Set(r),modules:[]})).modules.push(...a)}return Object.values(e)}function Zp(t,{big:n,sideEffectAtoms:e,sizeByAtom:r,small:a},i){let s=null;for(const o of D_([a,n])){if(t===o)continue;const _=nd(t,o,i,e,r);if(_<i){if(s=o,_===0)break;i=_}}return s}function O_(t,n,e){return t.size<n?e.small:e.big}function Qp({size:t},{size:n}){return t-n}function nd(t,n,e,r,a){const i=z_(t,n,e,r,a);return i<e?i+z_(n,t,e-i,r,a):1/0}function z_(t,n,e,r,a){const{correlatedAtoms:i}=n;let s=t.containedAtoms;const o=s&r;if((i&o)!==o)return 1/0;const _=new Set(t.dependencies);for(const{dependencies:l,containedAtoms:u}of _){s|=u;const f=u&r;if((i&f)!==f)return 1/0;for(const m of l){if(m===n)return 1/0;_.add(m)}}return function(l,u,f){let m=0,h=0,v=1n;const{length:d}=f;for(;h<d;h++)if((l&v)===v&&(m+=f[h]),v<<=1n,m>=u)return 1/0;return m}(s&~i,e,a)}const td=(t,n)=>t.execIndex>n.execIndex?1:-1;function ed(t,n,e){const r=Symbol(t.id),a=[t.id];let i=n;for(t.cycles.add(r);i!==t;)i.cycles.add(r),a.push(i.id),i=e.get(i);return a.push(a[0]),a.reverse(),a}const F_=(t,n)=>n?`(${t})`:t,B_=/^(?!\d)[\w$]+$/;class G_{constructor(n,e){this.isOriginal=!0,this.filename=n,this.content=e}traceSegment(n,e,r){return{column:e,line:n,name:r,source:this}}}class na{constructor(n,e){this.sources=e,this.names=n.names,this.mappings=n.mappings}traceMappings(){const n=[],e=new Map,r=[],a=[],i=new Map,s=[];for(const o of this.mappings){const _=[];for(const l of o){if(l.length===1)continue;const u=this.sources[l[1]];if(!u)continue;const f=u.traceSegment(l[2],l[3],l.length===5?this.names[l[4]]:"");if(f){const{column:m,line:h,name:v,source:{content:d,filename:g}}=f;let y=e.get(g);if(y===void 0)y=n.length,n.push(g),e.set(g,y),r[y]=d;else if(r[y]==null)r[y]=d;else if(d!=null&&r[y]!==d)return L(jm(g));const E=[l[0],y,h,m];if(v){let b=i.get(v);b===void 0&&(b=a.length,a.push(v),i.set(v,b)),E[4]=b}_.push(E)}}s.push(_)}return{mappings:s,names:a,sources:n,sourcesContent:r}}traceSegment(n,e,r){const a=this.mappings[n];if(!a)return null;let i=0,s=a.length-1;for(;i<=s;){const o=i+s>>1,_=a[o];if(_[0]===e||i===s){if(_.length==1)return null;const l=this.sources[_[1]];return l?l.traceSegment(_[2],_[3],_.length===5?this.names[_[4]]:r):null}_[0]>e?s=o-1:i=o+1}return null}}function R_(t){return function(n,e){return e.mappings?new na(e,[n]):(t(V,(r=e.plugin,{code:Hs,message:`Sourcemap is likely to be incorrect: a plugin (${r}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,plugin:r,url:wn(Zf)})),new na({mappings:[],names:[]},[n]));var r}}function q_(t,n,e,r,a){let i;if(e){const s=e.sources,o=e.sourcesContent||[],_=Mt(t)||".",l=e.sourceRoot||".",u=s.map((f,m)=>new G_(Jn(_,l,f),o[m]));i=new na(e,u)}else i=new G_(t,n);return r.reduce(a,i)}var en={},Xi=V_;function V_(t,n){if(!t)throw new Error(n||"Assertion failed")}V_.equal=function(t,n,e){if(t!=n)throw new Error(e||"Assertion failed: "+t+" != "+n)};var Ui={exports:{}};typeof Object.create=="function"?Ui.exports=function(t,n){n&&(t.super_=n,t.prototype=Object.create(n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:Ui.exports=function(t,n){if(n){t.super_=n;var e=function(){};e.prototype=n.prototype,t.prototype=new e,t.prototype.constructor=t}};var rd=Ui.exports,ad=Xi,id=rd;function sd(t,n){return(64512&t.charCodeAt(n))==55296&&!(n<0||n+1>=t.length)&&(64512&t.charCodeAt(n+1))==56320}function X_(t){return(t>>>24|t>>>8&65280|t<<8&16711680|(255&t)<<24)>>>0}function U_(t){return t.length===1?"0"+t:t}function H_(t){return t.length===7?"0"+t:t.length===6?"00"+t:t.length===5?"000"+t:t.length===4?"0000"+t:t.length===3?"00000"+t:t.length===2?"000000"+t:t.length===1?"0000000"+t:t}en.inherits=id,en.toArray=function(t,n){if(Array.isArray(t))return t.slice();if(!t)return[];var e=[];if(typeof t=="string")if(n){if(n==="hex")for((t=t.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(t="0"+t),a=0;a<t.length;a+=2)e.push(parseInt(t[a]+t[a+1],16))}else for(var r=0,a=0;a<t.length;a++){var i=t.charCodeAt(a);i<128?e[r++]=i:i<2048?(e[r++]=i>>6|192,e[r++]=63&i|128):sd(t,a)?(i=65536+((1023&i)<<10)+(1023&t.charCodeAt(++a)),e[r++]=i>>18|240,e[r++]=i>>12&63|128,e[r++]=i>>6&63|128,e[r++]=63&i|128):(e[r++]=i>>12|224,e[r++]=i>>6&63|128,e[r++]=63&i|128)}else for(a=0;a<t.length;a++)e[a]=0|t[a];return e},en.toHex=function(t){for(var n="",e=0;e<t.length;e++)n+=U_(t[e].toString(16));return n},en.htonl=X_,en.toHex32=function(t,n){for(var e="",r=0;r<t.length;r++){var a=t[r];n==="little"&&(a=X_(a)),e+=H_(a.toString(16))}return e},en.zero2=U_,en.zero8=H_,en.join32=function(t,n,e,r){var a=e-n;ad(a%4==0);for(var i=new Array(a/4),s=0,o=n;s<i.length;s++,o+=4){var _;_=r==="big"?t[o]<<24|t[o+1]<<16|t[o+2]<<8|t[o+3]:t[o+3]<<24|t[o+2]<<16|t[o+1]<<8|t[o],i[s]=_>>>0}return i},en.split32=function(t,n){for(var e=new Array(4*t.length),r=0,a=0;r<t.length;r++,a+=4){var i=t[r];n==="big"?(e[a]=i>>>24,e[a+1]=i>>>16&255,e[a+2]=i>>>8&255,e[a+3]=255&i):(e[a+3]=i>>>24,e[a+2]=i>>>16&255,e[a+1]=i>>>8&255,e[a]=255&i)}return e},en.rotr32=function(t,n){return t>>>n|t<<32-n},en.rotl32=function(t,n){return t<<n|t>>>32-n},en.sum32=function(t,n){return t+n>>>0},en.sum32_3=function(t,n,e){return t+n+e>>>0},en.sum32_4=function(t,n,e,r){return t+n+e+r>>>0},en.sum32_5=function(t,n,e,r,a){return t+n+e+r+a>>>0},en.sum64=function(t,n,e,r){var a=t[n],i=r+t[n+1]>>>0,s=(i<r?1:0)+e+a;t[n]=s>>>0,t[n+1]=i},en.sum64_hi=function(t,n,e,r){return(n+r>>>0<n?1:0)+t+e>>>0},en.sum64_lo=function(t,n,e,r){return n+r>>>0},en.sum64_4_hi=function(t,n,e,r,a,i,s,o){var _=0,l=n;return _+=(l=l+r>>>0)<n?1:0,_+=(l=l+i>>>0)<i?1:0,t+e+a+s+(_+=(l=l+o>>>0)<o?1:0)>>>0},en.sum64_4_lo=function(t,n,e,r,a,i,s,o){return n+r+i+o>>>0},en.sum64_5_hi=function(t,n,e,r,a,i,s,o,_,l){var u=0,f=n;return u+=(f=f+r>>>0)<n?1:0,u+=(f=f+i>>>0)<i?1:0,u+=(f=f+o>>>0)<o?1:0,t+e+a+s+_+(u+=(f=f+l>>>0)<l?1:0)>>>0},en.sum64_5_lo=function(t,n,e,r,a,i,s,o,_,l){return n+r+i+o+l>>>0},en.rotr64_hi=function(t,n,e){return(n<<32-e|t>>>e)>>>0},en.rotr64_lo=function(t,n,e){return(t<<32-e|n>>>e)>>>0},en.shr64_hi=function(t,n,e){return t>>>e},en.shr64_lo=function(t,n,e){return(t<<32-e|n>>>e)>>>0};var W_={},J_=en,od=Xi;function ta(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}W_.BlockHash=ta,ta.prototype.update=function(t,n){if(t=J_.toArray(t,n),this.pending?this.pending=this.pending.concat(t):this.pending=t,this.pendingTotal+=t.length,this.pending.length>=this._delta8){var e=(t=this.pending).length%this._delta8;this.pending=t.slice(t.length-e,t.length),this.pending.length===0&&(this.pending=null),t=J_.join32(t,0,t.length-e,this.endian);for(var r=0;r<t.length;r+=this._delta32)this._update(t,r,r+this._delta32)}return this},ta.prototype.digest=function(t){return this.update(this._pad()),od(this.pending===null),this._digest(t)},ta.prototype._pad=function(){var t=this.pendingTotal,n=this._delta8,e=n-(t+this.padLength)%n,r=new Array(e+this.padLength);r[0]=128;for(var a=1;a<e;a++)r[a]=0;if(t<<=3,this.endian==="big"){for(var i=8;i<this.padLength;i++)r[a++]=0;r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=t>>>24&255,r[a++]=t>>>16&255,r[a++]=t>>>8&255,r[a++]=255&t}else for(r[a++]=255&t,r[a++]=t>>>8&255,r[a++]=t>>>16&255,r[a++]=t>>>24&255,r[a++]=0,r[a++]=0,r[a++]=0,r[a++]=0,i=8;i<this.padLength;i++)r[a++]=0;return r};var ht={},st=en.rotr32;function K_(t,n,e){return t&n^~t&e}function Y_(t,n,e){return t&n^t&e^n&e}function Z_(t,n,e){return t^n^e}ht.ft_1=function(t,n,e,r){return t===0?K_(n,e,r):t===1||t===3?Z_(n,e,r):t===2?Y_(n,e,r):void 0},ht.ch32=K_,ht.maj32=Y_,ht.p32=Z_,ht.s0_256=function(t){return st(t,2)^st(t,13)^st(t,22)},ht.s1_256=function(t){return st(t,6)^st(t,11)^st(t,25)},ht.g0_256=function(t){return st(t,7)^st(t,18)^t>>>3},ht.g1_256=function(t){return st(t,17)^st(t,19)^t>>>10};var ue=en,_d=W_,fe=ht,ld=Xi,Zn=ue.sum32,cd=ue.sum32_4,ud=ue.sum32_5,fd=fe.ch32,md=fe.maj32,pd=fe.s0_256,dd=fe.s1_256,hd=fe.g0_256,gd=fe.g1_256,Q_=_d.BlockHash,bd=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function ot(){if(!(this instanceof ot))return new ot;Q_.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=bd,this.W=new Array(64)}ue.inherits(ot,Q_);var vd=ot;ot.blockSize=512,ot.outSize=256,ot.hmacStrength=192,ot.padLength=64,ot.prototype._update=function(t,n){for(var e=this.W,r=0;r<16;r++)e[r]=t[n+r];for(;r<e.length;r++)e[r]=cd(gd(e[r-2]),e[r-7],hd(e[r-15]),e[r-16]);var a=this.h[0],i=this.h[1],s=this.h[2],o=this.h[3],_=this.h[4],l=this.h[5],u=this.h[6],f=this.h[7];for(ld(this.k.length===e.length),r=0;r<e.length;r++){var m=ud(f,dd(_),fd(_,l,u),this.k[r],e[r]),h=Zn(pd(a),md(a,i,s));f=u,u=l,l=_,_=Zn(o,m),o=s,s=i,i=a,a=Zn(m,h)}this.h[0]=Zn(this.h[0],a),this.h[1]=Zn(this.h[1],i),this.h[2]=Zn(this.h[2],s),this.h[3]=Zn(this.h[3],o),this.h[4]=Zn(this.h[4],_),this.h[5]=Zn(this.h[5],l),this.h[6]=Zn(this.h[6],u),this.h[7]=Zn(this.h[7],f)},ot.prototype._digest=function(t){return t==="hex"?ue.toHex32(this.h,"big"):ue.split32(this.h,"big")};var yd=Es(vd);const Ke=()=>yd();function Hi(t){if(!t)return null;if(typeof t=="string"&&(t=JSON.parse(t)),t.mappings==="")return{mappings:[],names:[],sources:[],version:3};const n=typeof t.mappings=="string"?ws.decode(t.mappings):t.mappings;return{...t,mappings:n}}async function xd(t,n,e,r,a){$n("render chunks",2),function(f){for(const m of f)m.facadeModule&&m.facadeModule.isUserDefinedEntryPoint&&m.getPreliminaryFileName()}(t);const i=await Promise.all(t.map(f=>f.render()));yn("render chunks",2),$n("transform chunks",2);const s=function(f){return Object.fromEntries(f.map(m=>{const h=m.getRenderedChunkInfo();return[h.fileName,h]}))}(t),{nonHashedChunksWithPlaceholders:o,renderedChunksByPlaceholder:_,hashDependenciesByPlaceholder:l}=await async function(f,m,h,v,d){const g=[],y=new Map,E=new Map,b=new Set;for(const{preliminaryFileName:{hashPlaceholder:x}}of f)x&&b.add(x);return await Promise.all(f.map(async({chunk:x,preliminaryFileName:{fileName:$,hashPlaceholder:S},magicString:A,usedModules:N})=>{const k={chunk:x,fileName:$,...await $d(A,$,N,m,h,v,d)},{code:I}=k;if(S){const{containedPlaceholders:R,transformedCode:P}=Vp(I,b),B=Ke().update(P),D=v.hookReduceValueSync("augmentChunkHash","",[x.getRenderedChunkInfo()],(z,w)=>(w&&(z+=w),z));D&&B.update(D),y.set(S,k),E.set(S,{containedPlaceholders:R,contentHash:B.digest("hex")})}else g.push(k)})),{hashDependenciesByPlaceholder:E,nonHashedChunksWithPlaceholders:g,renderedChunksByPlaceholder:y}}(i,s,r,e,a),u=function(f,m,h){const v=new Map;for(const[d,{fileName:g}]of f){let y=Ke();const E=new Set([d]);for(const $ of E){const{containedPlaceholders:S,contentHash:A}=m.get($);y.update(A);for(const N of S)E.add(N)}let b,x;do x&&(y=Ke().update(x)),x=y.digest("hex").slice(0,d.length),b=qp(g,d,x);while(h[Zr].has(b.toLowerCase()));h[b]=qi,v.set(d,x)}return v}(_,l,n);(function(f,m,h,v,d,g){for(const{chunk:y,code:E,fileName:b,map:x}of f.values()){let $=Je(E,m);const S=Je(b,m);x&&(x.file=Je(x.file,m),$+=nl(S,x,d,g)),h[S]=y.finalizeChunk($,x,m)}for(const{chunk:y,code:E,fileName:b,map:x}of v){let $=m.size>0?Je(E,m):E;x&&($+=nl(b,x,d,g)),h[b]=y.finalizeChunk($,x,m)}})(_,u,n,o,e,r),yn("transform chunks",2)}async function $d(t,n,e,r,a,i,s){let o=null;const _=[];let l=await i.hookReduceArg0("renderChunk",[t.toString(),r[n],a,{chunks:r}],(E,b,x)=>{if(b==null)return E;if(typeof b=="string"&&(b={code:b,map:void 0}),b.map!==null){const $=Hi(b.map);_.push($||{missing:!0,plugin:x.name})}return b.code});const{compact:u,dir:f,file:m,sourcemap:h,sourcemapExcludeSources:v,sourcemapFile:d,sourcemapPathTransform:g,sourcemapIgnoreList:y}=a;if(u||l[l.length-1]===`
`||(l+=`
`),h){let E;$n("sourcemaps",3),E=m?Jn(d||m):f?Jn(f,n):Jn(n),o=function(b,x,$,S,A,N){const k=R_(N),I=$.filter(T=>!T.excludeFromSourcemap).map(T=>q_(T.id,T.originalCode,T.originalSourcemap,T.sourcemapChain,k)),R=new na(x,I),P=S.reduce(k,R);let{sources:B,sourcesContent:D,names:z,mappings:w}=P.traceMappings();if(b){const T=Mt(b);B=B.map(F=>ne(T,F)),b=ft(b)}return D=A?null:D,new mr({file:b,mappings:w,names:z,sources:B,sourcesContent:D})}(E,t.generateDecodedMap({}),e,_,v,s);for(let b=0;b<o.sources.length;++b){let x=o.sources[b];const $=`${E}.map`,S=y(x,$);typeof S!="boolean"&&L(Mn("sourcemapIgnoreList function must return a boolean.")),S&&(o.x_google_ignoreList===void 0&&(o.x_google_ignoreList=[]),o.x_google_ignoreList.includes(b)||o.x_google_ignoreList.push(b)),g&&(x=g(x,$),typeof x!="string"&&L(Mn("sourcemapPathTransform function must return a string."))),o.sources[b]=Ee(x)}yn("sourcemaps",3)}return{code:l,map:o}}function nl(t,n,e,{sourcemap:r,sourcemapBaseUrl:a}){let i;if(r==="inline")i=n.toUrl();else{const s=`${ft(t)}.map`;i=a?new URL(s,a).toString():s,e.emitFile({fileName:`${t}.map`,source:n.toString(),type:"asset"})}return r==="hidden"?"":`//# ${ni}=${i}
`}class Ed{constructor(n,e,r,a,i){this.outputOptions=n,this.unsetOptions=e,this.inputOptions=r,this.pluginDriver=a,this.graph=i,this.facadeChunkByModule=new Map,this.includedNamespaces=new Set}async generate(n){$n("GENERATE",1);const e=Object.create(null),r=(a=>{const i=new Set;return new Proxy(a,{deleteProperty:(s,o)=>(typeof o=="string"&&i.delete(o.toLowerCase()),Reflect.deleteProperty(s,o)),get:(s,o)=>o===Zr?i:Reflect.get(s,o),set:(s,o,_)=>(typeof o=="string"&&i.add(o.toLowerCase()),Reflect.set(s,o,_))})})(e);this.pluginDriver.setOutputBundle(r,this.outputOptions);try{$n("initialize render",2),await this.pluginDriver.hookParallel("renderStart",[this.outputOptions,this.inputOptions]),yn("initialize render",2),$n("generate chunks",2);const a=(()=>{let s=0;return(o,_=8)=>{if(_>64)return L(Mn(`Hashes cannot be longer than 64 characters, received ${_}. Check the "${o}" option.`));const l=`${Bi}${Tr(++s).padStart(_-5,"0")}${Gi}`;return l.length>_?L(Mn(`To generate hashes for this number of chunks (currently ${s}), you need a minimum hash size of ${l.length}, received ${_}. Check the "${o}" option.`)):l}})(),i=await this.generateChunks(r,a);i.length>1&&function(s,o){if(s.format==="umd"||s.format==="iife")return L(vn("output.format",Bs,"UMD and IIFE output formats are not supported for code-splitting builds",s.format));if(typeof s.file=="string")return L(vn("output.file",Ce,'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));if(s.sourcemapFile)return L(vn("output.sourcemapFile",em,'"output.sourcemapFile" is only supported for single-file builds'));!s.amd.autoId&&s.amd.id&&o(V,vn("output.amd.id",Fs,'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'))}(this.outputOptions,this.inputOptions.onLog),this.pluginDriver.setChunkInformation(this.facadeChunkByModule);for(const s of i)s.generateExports();yn("generate chunks",2),await xd(i,r,this.pluginDriver,this.outputOptions,this.inputOptions.onLog)}catch(a){throw await this.pluginDriver.hookParallel("renderError",[a]),a}return(a=>{const i=new Set,s=Object.values(a);for(const o of s)o.type==="asset"&&o.needsCodeReference&&i.add(o.fileName);for(const o of s)if(o.type==="chunk")for(const _ of o.referencedFiles)i.has(_)&&i.delete(_);for(const o of i)delete a[o]})(r),$n("generate bundle",2),await this.pluginDriver.hookSeq("generateBundle",[this.outputOptions,r,n]),this.finaliseAssets(r),yn("generate bundle",2),yn("GENERATE",1),e}async addManualChunks(n){const e=new Map,r=await Promise.all(Object.entries(n).map(async([a,i])=>({alias:a,entries:await this.graph.moduleLoader.addAdditionalModules(i)})));for(const{alias:a,entries:i}of r)for(const s of i)tl(a,s,e);return e}assignManualChunks(n){const e=[],r={getModuleIds:()=>this.graph.modulesById.keys(),getModuleInfo:this.graph.getModuleInfo};for(const i of this.graph.modulesById.values())if(i instanceof hn){const s=n(i.id,r);typeof s=="string"&&e.push([s,i])}e.sort(([i],[s])=>i>s?1:i<s?-1:0);const a=new Map;for(const[i,s]of e)tl(i,s,a);return a}finaliseAssets(n){if(this.outputOptions.validate){for(const e of Object.values(n))if("code"in e)try{this.graph.contextParse(e.code,{ecmaVersion:"latest"})}catch(r){this.inputOptions.onLog(V,Am(e,r))}}this.pluginDriver.finaliseAssets()}async generateChunks(n,e){const{experimentalMinChunkSize:r,inlineDynamicImports:a,manualChunks:i,preserveModules:s}=this.outputOptions,o=typeof i=="object"?await this.addManualChunks(i):this.assignManualChunks(i),_=function({compact:d,generatedCode:{arrowFunctions:g,constBindings:y,objectShorthand:E,reservedNamesAsProps:b}}){const{_:x,n:$,s:S}=d?{_:"",n:"",s:""}:{_:" ",n:`
`,s:";"},A=y?"const":"var",N=(P,{isAsync:B,name:D})=>`${B?"async ":""}function${D?` ${D}`:""}${x}(${P.join(`,${x}`)})${x}`,k=g?(P,{isAsync:B,name:D})=>{const z=P.length===1;return`${D?`${A} ${D}${x}=${x}`:""}${B?`async${z?" ":x}`:""}${z?P[0]:`(${P.join(`,${x}`)})`}${x}=>${x}`}:N,I=(P,{functionReturn:B,lineBreakIndent:D,name:z})=>[`${k(P,{isAsync:!1,name:z})}${g?D?`${$}${D.base}${D.t}`:"":`{${D?`${$}${D.base}${D.t}`:x}${B?"return ":""}`}`,g?`${z?";":""}${D?`${$}${D.base}`:""}`:`${S}${D?`${$}${D.base}`:x}}`],R=b?P=>B_.test(P):P=>!vr.has(P)&&B_.test(P);return{_:x,cnst:A,getDirectReturnFunction:I,getDirectReturnIifeLeft:(P,B,{needsArrowReturnParens:D,needsWrappedFunction:z})=>{const[w,T]=I(P,{functionReturn:!0,lineBreakIndent:null,name:null});return`${F_(`${w}${F_(B,g&&D)}${T}`,g||z)}(`},getFunctionIntro:k,getNonArrowFunctionIntro:N,getObject(P,{lineBreakIndent:B}){const D=B?`${$}${B.base}${B.t}`:x;return`{${P.map(([z,w])=>{if(z===null)return`${D}${w}`;const T=!R(z);return z===w&&E&&!T?D+z:`${D}${T?`'${z}'`:z}:${x}${w}`}).join(",")}${P.length===0?"":B?`${$}${B.base}`:x}}`},getPropertyAccess:P=>R(P)?`.${P}`:`[${JSON.stringify(P)}]`,n:$,s:S}}(this.outputOptions),l=function(d){const g=[];for(const y of d.values())y instanceof hn&&(y.isIncluded()||y.info.isEntry||y.includedDynamicImporters.length>0)&&g.push(y);return g}(this.graph.modulesById),u=function(d){if(d.length===0)return"/";if(d.length===1)return Mt(d[0]);const g=d.slice(1).reduce((y,E)=>{const b=E.split(/\/+|\\+/);let x;for(x=0;y[x]===b[x]&&x<Math.min(y.length,b.length);x++);return y.slice(0,x)},d[0].split(/\/+|\\+/));return g.length>1?g.join("/"):"/"}(function(d,g){const y=[];for(const E of d)(E.info.isEntry||g)&&vt(E.id)&&y.push(E.id);return y}(l,s)),f=function(d,g,y){const E=new Map;for(const b of d.values())b instanceof fn&&E.set(b,new te(b,g,y));return E}(this.graph.modulesById,this.outputOptions,u),m=[],h=new Map;for(const{alias:d,modules:g}of a?[{alias:null,modules:l}]:s?l.map(y=>({alias:null,modules:[y]})):Jp(this.graph.entryModules,o,r,this.inputOptions.onLog)){g.sort(td);const y=new At(g,this.inputOptions,this.outputOptions,this.unsetOptions,this.pluginDriver,this.graph.modulesById,h,f,this.facadeChunkByModule,this.includedNamespaces,d,e,n,u,_);m.push(y)}for(const d of m)d.link();const v=[];for(const d of m)v.push(...d.generateFacades());return[...m,...v]}}function tl(t,n,e){const r=e.get(n);if(typeof r=="string"&&r!==t)return L((a=n.id,i=t,s=r,{code:pm,message:`Cannot assign "${H(a)}" to the "${i}" chunk as it is already in the "${s}" chunk.`}));var a,i,s;e.set(n,t)}var kd=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,81,2,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,9,5351,0,7,14,13835,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,983,6,110,6,6,9,4759,9,787719,239],el=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,4026,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,757,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,3104,541,1507,4938,6,4191],rl="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",Wi={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"},Ji="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",wd={5:Ji,"5module":Ji+" export import",6:Ji+" const class extends export import super"},Cd=/^in(stanceof)?$/,Sd=new RegExp("["+rl+"]"),Ad=new RegExp("["+rl+"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿]");function Ki(t,n){for(var e=65536,r=0;r<n.length;r+=2){if((e+=n[r])>t)return!1;if((e+=n[r+1])>=t)return!0}return!1}function _t(t,n){return t<65?t===36:t<91||(t<97?t===95:t<123||(t<=65535?t>=170&&Sd.test(String.fromCharCode(t)):n!==!1&&Ki(t,el)))}function Wt(t,n){return t<48?t===36:t<58||!(t<65)&&(t<91||(t<97?t===95:t<123||(t<=65535?t>=170&&Ad.test(String.fromCharCode(t)):n!==!1&&(Ki(t,el)||Ki(t,kd)))))}var Q=function(t,n){n===void 0&&(n={}),this.label=t,this.keyword=n.keyword,this.beforeExpr=!!n.beforeExpr,this.startsExpr=!!n.startsExpr,this.isLoop=!!n.isLoop,this.isAssign=!!n.isAssign,this.prefix=!!n.prefix,this.postfix=!!n.postfix,this.binop=n.binop||null,this.updateContext=null};function Xn(t,n){return new Q(t,{beforeExpr:!0,binop:n})}var Un={beforeExpr:!0},Pn={startsExpr:!0},ea={};function Z(t,n){return n===void 0&&(n={}),n.keyword=t,ea[t]=new Q(t,n)}var p={num:new Q("num",Pn),regexp:new Q("regexp",Pn),string:new Q("string",Pn),name:new Q("name",Pn),privateId:new Q("privateId",Pn),eof:new Q("eof"),bracketL:new Q("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new Q("]"),braceL:new Q("{",{beforeExpr:!0,startsExpr:!0}),braceR:new Q("}"),parenL:new Q("(",{beforeExpr:!0,startsExpr:!0}),parenR:new Q(")"),comma:new Q(",",Un),semi:new Q(";",Un),colon:new Q(":",Un),dot:new Q("."),question:new Q("?",Un),questionDot:new Q("?."),arrow:new Q("=>",Un),template:new Q("template"),invalidTemplate:new Q("invalidTemplate"),ellipsis:new Q("...",Un),backQuote:new Q("`",Pn),dollarBraceL:new Q("${",{beforeExpr:!0,startsExpr:!0}),eq:new Q("=",{beforeExpr:!0,isAssign:!0}),assign:new Q("_=",{beforeExpr:!0,isAssign:!0}),incDec:new Q("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new Q("!/~",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:Xn("||",1),logicalAND:Xn("&&",2),bitwiseOR:Xn("|",3),bitwiseXOR:Xn("^",4),bitwiseAND:Xn("&",5),equality:Xn("==/!=/===/!==",6),relational:Xn("</>/<=/>=",7),bitShift:Xn("<</>>/>>>",8),plusMin:new Q("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:Xn("%",10),star:Xn("*",10),slash:Xn("/",10),starstar:new Q("**",{beforeExpr:!0}),coalesce:Xn("??",1),_break:Z("break"),_case:Z("case",Un),_catch:Z("catch"),_continue:Z("continue"),_debugger:Z("debugger"),_default:Z("default",Un),_do:Z("do",{isLoop:!0,beforeExpr:!0}),_else:Z("else",Un),_finally:Z("finally"),_for:Z("for",{isLoop:!0}),_function:Z("function",Pn),_if:Z("if"),_return:Z("return",Un),_switch:Z("switch"),_throw:Z("throw",Un),_try:Z("try"),_var:Z("var"),_const:Z("const"),_while:Z("while",{isLoop:!0}),_with:Z("with"),_new:Z("new",{beforeExpr:!0,startsExpr:!0}),_this:Z("this",Pn),_super:Z("super",Pn),_class:Z("class",Pn),_extends:Z("extends",Un),_export:Z("export"),_import:Z("import",Pn),_null:Z("null",Pn),_true:Z("true",Pn),_false:Z("false",Pn),_in:Z("in",{beforeExpr:!0,binop:7}),_instanceof:Z("instanceof",{beforeExpr:!0,binop:7}),_typeof:Z("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_void:Z("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),_delete:Z("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},Gn=/\r\n?|\n|\u2028|\u2029/,al=new RegExp(Gn.source,"g");function Jt(t){return t===10||t===13||t===8232||t===8233}function il(t,n,e){e===void 0&&(e=t.length);for(var r=n;r<e;r++){var a=t.charCodeAt(r);if(Jt(a))return r<e-1&&a===13&&t.charCodeAt(r+1)===10?r+2:r+1}return-1}var Yi=/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Hn=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,sl=Object.prototype,Id=sl.hasOwnProperty,Nd=sl.toString,Ye=Object.hasOwn||function(t,n){return Id.call(t,n)},ol=Array.isArray||function(t){return Nd.call(t)==="[object Array]"};function Kt(t){return new RegExp("^(?:"+t.replace(/ /g,"|")+")$")}function It(t){return t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10),56320+(1023&t)))}var Td=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,me=function(t,n){this.line=t,this.column=n};me.prototype.offset=function(t){return new me(this.line,this.column+t)};var Ze=function(t,n,e){this.start=n,this.end=e,t.sourceFile!==null&&(this.source=t.sourceFile)};function Zi(t,n){for(var e=1,r=0;;){var a=il(t,r,n);if(a<0)return new me(e,n-r);++e,r=a}}var ra={ecmaVersion:null,sourceType:"script",onInsertedSemicolon:null,onTrailingComma:null,allowReserved:null,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowAwaitOutsideFunction:null,allowSuperOutsideMethod:null,allowHashBang:!1,locations:!1,onToken:null,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null,preserveParens:!1},_l=!1;function jd(t){var n={};for(var e in ra)n[e]=t&&Ye(t,e)?t[e]:ra[e];if(n.ecmaVersion==="latest"?n.ecmaVersion=1e8:n.ecmaVersion==null?(!_l&&typeof console=="object"&&console.warn&&(_l=!0,console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),n.ecmaVersion=11):n.ecmaVersion>=2015&&(n.ecmaVersion-=2009),n.allowReserved==null&&(n.allowReserved=n.ecmaVersion<5),t&&t.allowHashBang!=null||(n.allowHashBang=n.ecmaVersion>=14),ol(n.onToken)){var r=n.onToken;n.onToken=function(a){return r.push(a)}}return ol(n.onComment)&&(n.onComment=function(a,i){return function(s,o,_,l,u,f){var m={type:s?"Block":"Line",value:o,start:_,end:l};a.locations&&(m.loc=new Ze(this,u,f)),a.ranges&&(m.range=[_,l]),i.push(m)}}(n,n.onComment)),n}var ll=256;function Qi(t,n){return 2|(t?4:0)|(n?8:0)}var pn=function(t,n,e){this.options=t=jd(t),this.sourceFile=t.sourceFile,this.keywords=Kt(wd[t.ecmaVersion>=6?6:t.sourceType==="module"?"5module":5]);var r="";t.allowReserved!==!0&&(r=Wi[t.ecmaVersion>=6?6:t.ecmaVersion===5?5:3],t.sourceType==="module"&&(r+=" await")),this.reservedWords=Kt(r);var a=(r?r+" ":"")+Wi.strict;this.reservedWordsStrict=Kt(a),this.reservedWordsStrictBind=Kt(a+" "+Wi.strictBind),this.input=String(n),this.containsEsc=!1,e?(this.pos=e,this.lineStart=this.input.lastIndexOf(`
`,e-1)+1,this.curLine=this.input.slice(0,this.lineStart).split(Gn).length):(this.pos=this.lineStart=0,this.curLine=1),this.type=p.eof,this.value=null,this.start=this.end=this.pos,this.startLoc=this.endLoc=this.curPosition(),this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,this.context=this.initialContext(),this.exprAllowed=!0,this.inModule=t.sourceType==="module",this.strict=this.inModule||this.strictDirective(this.pos),this.potentialArrowAt=-1,this.potentialArrowInForAwait=!1,this.yieldPos=this.awaitPos=this.awaitIdentPos=0,this.labels=[],this.undefinedExports=Object.create(null),this.pos===0&&t.allowHashBang&&this.input.slice(0,2)==="#!"&&this.skipLineComment(2),this.scopeStack=[],this.enterScope(1),this.regexpState=null,this.privateNameStack=[]},lt={inFunction:{configurable:!0},inGenerator:{configurable:!0},inAsync:{configurable:!0},canAwait:{configurable:!0},allowSuper:{configurable:!0},allowDirectSuper:{configurable:!0},treatFunctionsAsVar:{configurable:!0},allowNewDotTarget:{configurable:!0},inClassStaticBlock:{configurable:!0}};pn.prototype.parse=function(){var t=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(t)},lt.inFunction.get=function(){return(2&this.currentVarScope().flags)>0},lt.inGenerator.get=function(){return(8&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},lt.inAsync.get=function(){return(4&this.currentVarScope().flags)>0&&!this.currentVarScope().inClassFieldInit},lt.canAwait.get=function(){for(var t=this.scopeStack.length-1;t>=0;t--){var n=this.scopeStack[t];if(n.inClassFieldInit||n.flags&ll)return!1;if(2&n.flags)return(4&n.flags)>0}return this.inModule&&this.options.ecmaVersion>=13||this.options.allowAwaitOutsideFunction},lt.allowSuper.get=function(){var t=this.currentThisScope(),n=t.flags,e=t.inClassFieldInit;return(64&n)>0||e||this.options.allowSuperOutsideMethod},lt.allowDirectSuper.get=function(){return(128&this.currentThisScope().flags)>0},lt.treatFunctionsAsVar.get=function(){return this.treatFunctionsAsVarInScope(this.currentScope())},lt.allowNewDotTarget.get=function(){var t=this.currentThisScope(),n=t.flags,e=t.inClassFieldInit;return(258&n)>0||e},lt.inClassStaticBlock.get=function(){return(this.currentVarScope().flags&ll)>0},pn.extend=function(){for(var t=[],n=arguments.length;n--;)t[n]=arguments[n];for(var e=this,r=0;r<t.length;r++)e=t[r](e);return e},pn.parse=function(t,n){return new this(n,t).parse()},pn.parseExpressionAt=function(t,n,e){var r=new this(e,t,n);return r.nextToken(),r.parseExpression()},pn.tokenizer=function(t,n){return new this(n,t)},Object.defineProperties(pn.prototype,lt);var Ln=pn.prototype,Ld=/^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;Ln.strictDirective=function(t){if(this.options.ecmaVersion<5)return!1;for(;;){Hn.lastIndex=t,t+=Hn.exec(this.input)[0].length;var n=Ld.exec(this.input.slice(t));if(!n)return!1;if((n[1]||n[2])==="use strict"){Hn.lastIndex=t+n[0].length;var e=Hn.exec(this.input),r=e.index+e[0].length,a=this.input.charAt(r);return a===";"||a==="}"||Gn.test(e[0])&&!(/[(`.[+\-/*%<>=,?^&]/.test(a)||a==="!"&&this.input.charAt(r+1)==="=")}t+=n[0].length,Hn.lastIndex=t,t+=Hn.exec(this.input)[0].length,this.input[t]===";"&&t++}},Ln.eat=function(t){return this.type===t&&(this.next(),!0)},Ln.isContextual=function(t){return this.type===p.name&&this.value===t&&!this.containsEsc},Ln.eatContextual=function(t){return!!this.isContextual(t)&&(this.next(),!0)},Ln.expectContextual=function(t){this.eatContextual(t)||this.unexpected()},Ln.canInsertSemicolon=function(){return this.type===p.eof||this.type===p.braceR||Gn.test(this.input.slice(this.lastTokEnd,this.start))},Ln.insertSemicolon=function(){if(this.canInsertSemicolon())return this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0},Ln.semicolon=function(){this.eat(p.semi)||this.insertSemicolon()||this.unexpected()},Ln.afterTrailingComma=function(t,n){if(this.type===t)return this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),n||this.next(),!0},Ln.expect=function(t){this.eat(t)||this.unexpected()},Ln.unexpected=function(t){this.raise(t??this.start,"Unexpected token")};var aa=function(){this.shorthandAssign=this.trailingComma=this.parenthesizedAssign=this.parenthesizedBind=this.doubleProto=-1};Ln.checkPatternErrors=function(t,n){if(t){t.trailingComma>-1&&this.raiseRecoverable(t.trailingComma,"Comma is not permitted after the rest element");var e=n?t.parenthesizedAssign:t.parenthesizedBind;e>-1&&this.raiseRecoverable(e,n?"Assigning to rvalue":"Parenthesized pattern")}},Ln.checkExpressionErrors=function(t,n){if(!t)return!1;var e=t.shorthandAssign,r=t.doubleProto;if(!n)return e>=0||r>=0;e>=0&&this.raise(e,"Shorthand property assignments are valid only in destructuring patterns"),r>=0&&this.raiseRecoverable(r,"Redefinition of __proto__ property")},Ln.checkYieldAwaitInDefaultParams=function(){this.yieldPos&&(!this.awaitPos||this.yieldPos<this.awaitPos)&&this.raise(this.yieldPos,"Yield expression cannot be a default value"),this.awaitPos&&this.raise(this.awaitPos,"Await expression cannot be a default value")},Ln.isSimpleAssignTarget=function(t){return t.type==="ParenthesizedExpression"?this.isSimpleAssignTarget(t.expression):t.type==="Identifier"||t.type==="MemberExpression"};var q=pn.prototype;q.parseTopLevel=function(t){var n=Object.create(null);for(t.body||(t.body=[]);this.type!==p.eof;){var e=this.parseStatement(null,!0,n);t.body.push(e)}if(this.inModule)for(var r=0,a=Object.keys(this.undefinedExports);r<a.length;r+=1){var i=a[r];this.raiseRecoverable(this.undefinedExports[i].start,"Export '"+i+"' is not defined")}return this.adaptDirectivePrologue(t.body),this.next(),t.sourceType=this.options.sourceType,this.finishNode(t,"Program")};var ns={kind:"loop"},Md={kind:"switch"};q.isLet=function(t){if(this.options.ecmaVersion<6||!this.isContextual("let"))return!1;Hn.lastIndex=this.pos;var n=Hn.exec(this.input),e=this.pos+n[0].length,r=this.input.charCodeAt(e);if(r===91||r===92)return!0;if(t)return!1;if(r===123||r>55295&&r<56320)return!0;if(_t(r,!0)){for(var a=e+1;Wt(r=this.input.charCodeAt(a),!0);)++a;if(r===92||r>55295&&r<56320)return!0;var i=this.input.slice(e,a);if(!Cd.test(i))return!0}return!1},q.isAsyncFunction=function(){if(this.options.ecmaVersion<8||!this.isContextual("async"))return!1;Hn.lastIndex=this.pos;var t,n=Hn.exec(this.input),e=this.pos+n[0].length;return!(Gn.test(this.input.slice(this.pos,e))||this.input.slice(e,e+8)!=="function"||e+8!==this.input.length&&(Wt(t=this.input.charCodeAt(e+8))||t>55295&&t<56320))},q.parseStatement=function(t,n,e){var r,a=this.type,i=this.startNode();switch(this.isLet(t)&&(a=p._var,r="let"),a){case p._break:case p._continue:return this.parseBreakContinueStatement(i,a.keyword);case p._debugger:return this.parseDebuggerStatement(i);case p._do:return this.parseDoStatement(i);case p._for:return this.parseForStatement(i);case p._function:return t&&(this.strict||t!=="if"&&t!=="label")&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(i,!1,!t);case p._class:return t&&this.unexpected(),this.parseClass(i,!0);case p._if:return this.parseIfStatement(i);case p._return:return this.parseReturnStatement(i);case p._switch:return this.parseSwitchStatement(i);case p._throw:return this.parseThrowStatement(i);case p._try:return this.parseTryStatement(i);case p._const:case p._var:return r=r||this.value,t&&r!=="var"&&this.unexpected(),this.parseVarStatement(i,r);case p._while:return this.parseWhileStatement(i);case p._with:return this.parseWithStatement(i);case p.braceL:return this.parseBlock(!0,i);case p.semi:return this.parseEmptyStatement(i);case p._export:case p._import:if(this.options.ecmaVersion>10&&a===p._import){Hn.lastIndex=this.pos;var s=Hn.exec(this.input),o=this.pos+s[0].length,_=this.input.charCodeAt(o);if(_===40||_===46)return this.parseExpressionStatement(i,this.parseExpression())}return this.options.allowImportExportEverywhere||(n||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),a===p._import?this.parseImport(i):this.parseExport(i,e);default:if(this.isAsyncFunction())return t&&this.unexpected(),this.next(),this.parseFunctionStatement(i,!0,!t);var l=this.value,u=this.parseExpression();return a===p.name&&u.type==="Identifier"&&this.eat(p.colon)?this.parseLabeledStatement(i,l,u,t):this.parseExpressionStatement(i,u)}},q.parseBreakContinueStatement=function(t,n){var e=n==="break";this.next(),this.eat(p.semi)||this.insertSemicolon()?t.label=null:this.type!==p.name?this.unexpected():(t.label=this.parseIdent(),this.semicolon());for(var r=0;r<this.labels.length;++r){var a=this.labels[r];if((t.label==null||a.name===t.label.name)&&(a.kind!=null&&(e||a.kind==="loop")||t.label&&e))break}return r===this.labels.length&&this.raise(t.start,"Unsyntactic "+n),this.finishNode(t,e?"BreakStatement":"ContinueStatement")},q.parseDebuggerStatement=function(t){return this.next(),this.semicolon(),this.finishNode(t,"DebuggerStatement")},q.parseDoStatement=function(t){return this.next(),this.labels.push(ns),t.body=this.parseStatement("do"),this.labels.pop(),this.expect(p._while),t.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(p.semi):this.semicolon(),this.finishNode(t,"DoWhileStatement")},q.parseForStatement=function(t){this.next();var n=this.options.ecmaVersion>=9&&this.canAwait&&this.eatContextual("await")?this.lastTokStart:-1;if(this.labels.push(ns),this.enterScope(0),this.expect(p.parenL),this.type===p.semi)return n>-1&&this.unexpected(n),this.parseFor(t,null);var e=this.isLet();if(this.type===p._var||this.type===p._const||e){var r=this.startNode(),a=e?"let":this.value;return this.next(),this.parseVar(r,!0,a),this.finishNode(r,"VariableDeclaration"),(this.type===p._in||this.options.ecmaVersion>=6&&this.isContextual("of"))&&r.declarations.length===1?(this.options.ecmaVersion>=9&&(this.type===p._in?n>-1&&this.unexpected(n):t.await=n>-1),this.parseForIn(t,r)):(n>-1&&this.unexpected(n),this.parseFor(t,r))}var i=this.isContextual("let"),s=!1,o=new aa,_=this.parseExpression(!(n>-1)||"await",o);return this.type===p._in||(s=this.options.ecmaVersion>=6&&this.isContextual("of"))?(this.options.ecmaVersion>=9&&(this.type===p._in?n>-1&&this.unexpected(n):t.await=n>-1),i&&s&&this.raise(_.start,"The left-hand side of a for-of loop may not start with 'let'."),this.toAssignable(_,!1,o),this.checkLValPattern(_),this.parseForIn(t,_)):(this.checkExpressionErrors(o,!0),n>-1&&this.unexpected(n),this.parseFor(t,_))},q.parseFunctionStatement=function(t,n,e){return this.next(),this.parseFunction(t,Qe|(e?0:ts),!1,n)},q.parseIfStatement=function(t){return this.next(),t.test=this.parseParenExpression(),t.consequent=this.parseStatement("if"),t.alternate=this.eat(p._else)?this.parseStatement("if"):null,this.finishNode(t,"IfStatement")},q.parseReturnStatement=function(t){return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(p.semi)||this.insertSemicolon()?t.argument=null:(t.argument=this.parseExpression(),this.semicolon()),this.finishNode(t,"ReturnStatement")},q.parseSwitchStatement=function(t){var n;this.next(),t.discriminant=this.parseParenExpression(),t.cases=[],this.expect(p.braceL),this.labels.push(Md),this.enterScope(0);for(var e=!1;this.type!==p.braceR;)if(this.type===p._case||this.type===p._default){var r=this.type===p._case;n&&this.finishNode(n,"SwitchCase"),t.cases.push(n=this.startNode()),n.consequent=[],this.next(),r?n.test=this.parseExpression():(e&&this.raiseRecoverable(this.lastTokStart,"Multiple default clauses"),e=!0,n.test=null),this.expect(p.colon)}else n||this.unexpected(),n.consequent.push(this.parseStatement(null));return this.exitScope(),n&&this.finishNode(n,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(t,"SwitchStatement")},q.parseThrowStatement=function(t){return this.next(),Gn.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),t.argument=this.parseExpression(),this.semicolon(),this.finishNode(t,"ThrowStatement")};var Dd=[];q.parseTryStatement=function(t){if(this.next(),t.block=this.parseBlock(),t.handler=null,this.type===p._catch){var n=this.startNode();if(this.next(),this.eat(p.parenL)){n.param=this.parseBindingAtom();var e=n.param.type==="Identifier";this.enterScope(e?32:0),this.checkLValPattern(n.param,e?4:2),this.expect(p.parenR)}else this.options.ecmaVersion<10&&this.unexpected(),n.param=null,this.enterScope(0);n.body=this.parseBlock(!1),this.exitScope(),t.handler=this.finishNode(n,"CatchClause")}return t.finalizer=this.eat(p._finally)?this.parseBlock():null,t.handler||t.finalizer||this.raise(t.start,"Missing catch or finally clause"),this.finishNode(t,"TryStatement")},q.parseVarStatement=function(t,n){return this.next(),this.parseVar(t,!1,n),this.semicolon(),this.finishNode(t,"VariableDeclaration")},q.parseWhileStatement=function(t){return this.next(),t.test=this.parseParenExpression(),this.labels.push(ns),t.body=this.parseStatement("while"),this.labels.pop(),this.finishNode(t,"WhileStatement")},q.parseWithStatement=function(t){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),t.object=this.parseParenExpression(),t.body=this.parseStatement("with"),this.finishNode(t,"WithStatement")},q.parseEmptyStatement=function(t){return this.next(),this.finishNode(t,"EmptyStatement")},q.parseLabeledStatement=function(t,n,e,r){for(var a=0,i=this.labels;a<i.length;a+=1)i[a].name===n&&this.raise(e.start,"Label '"+n+"' is already declared");for(var s=this.type.isLoop?"loop":this.type===p._switch?"switch":null,o=this.labels.length-1;o>=0;o--){var _=this.labels[o];if(_.statementStart!==t.start)break;_.statementStart=this.start,_.kind=s}return this.labels.push({name:n,kind:s,statementStart:this.start}),t.body=this.parseStatement(r?r.indexOf("label")===-1?r+"label":r:"label"),this.labels.pop(),t.label=e,this.finishNode(t,"LabeledStatement")},q.parseExpressionStatement=function(t,n){return t.expression=n,this.semicolon(),this.finishNode(t,"ExpressionStatement")},q.parseBlock=function(t,n,e){for(t===void 0&&(t=!0),n===void 0&&(n=this.startNode()),n.body=[],this.expect(p.braceL),t&&this.enterScope(0);this.type!==p.braceR;){var r=this.parseStatement(null);n.body.push(r)}return e&&(this.strict=!1),this.next(),t&&this.exitScope(),this.finishNode(n,"BlockStatement")},q.parseFor=function(t,n){return t.init=n,this.expect(p.semi),t.test=this.type===p.semi?null:this.parseExpression(),this.expect(p.semi),t.update=this.type===p.parenR?null:this.parseExpression(),this.expect(p.parenR),t.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(t,"ForStatement")},q.parseForIn=function(t,n){var e=this.type===p._in;return this.next(),n.type==="VariableDeclaration"&&n.declarations[0].init!=null&&(!e||this.options.ecmaVersion<8||this.strict||n.kind!=="var"||n.declarations[0].id.type!=="Identifier")&&this.raise(n.start,(e?"for-in":"for-of")+" loop variable declaration may not have an initializer"),t.left=n,t.right=e?this.parseExpression():this.parseMaybeAssign(),this.expect(p.parenR),t.body=this.parseStatement("for"),this.exitScope(),this.labels.pop(),this.finishNode(t,e?"ForInStatement":"ForOfStatement")},q.parseVar=function(t,n,e){for(t.declarations=[],t.kind=e;;){var r=this.startNode();if(this.parseVarId(r,e),this.eat(p.eq)?r.init=this.parseMaybeAssign(n):e!=="const"||this.type===p._in||this.options.ecmaVersion>=6&&this.isContextual("of")?r.id.type==="Identifier"||n&&(this.type===p._in||this.isContextual("of"))?r.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),t.declarations.push(this.finishNode(r,"VariableDeclarator")),!this.eat(p.comma))break}return t},q.parseVarId=function(t,n){t.id=this.parseBindingAtom(),this.checkLValPattern(t.id,n==="var"?1:2,!1)};var Qe=1,ts=2;function Pd(t,n){var e=n.key.name,r=t[e],a="true";return n.type!=="MethodDefinition"||n.kind!=="get"&&n.kind!=="set"||(a=(n.static?"s":"i")+n.kind),r==="iget"&&a==="iset"||r==="iset"&&a==="iget"||r==="sget"&&a==="sset"||r==="sset"&&a==="sget"?(t[e]="true",!1):!!r||(t[e]=a,!1)}function ia(t,n){var e=t.computed,r=t.key;return!e&&(r.type==="Identifier"&&r.name===n||r.type==="Literal"&&r.value===n)}q.parseFunction=function(t,n,e,r,a){this.initFunction(t),(this.options.ecmaVersion>=9||this.options.ecmaVersion>=6&&!r)&&(this.type===p.star&&n&ts&&this.unexpected(),t.generator=this.eat(p.star)),this.options.ecmaVersion>=8&&(t.async=!!r),n&Qe&&(t.id=4&n&&this.type!==p.name?null:this.parseIdent(),!t.id||n&ts||this.checkLValSimple(t.id,this.strict||t.generator||t.async?this.treatFunctionsAsVar?1:2:3));var i=this.yieldPos,s=this.awaitPos,o=this.awaitIdentPos;return this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(Qi(t.async,t.generator)),n&Qe||(t.id=this.type===p.name?this.parseIdent():null),this.parseFunctionParams(t),this.parseFunctionBody(t,e,!1,a),this.yieldPos=i,this.awaitPos=s,this.awaitIdentPos=o,this.finishNode(t,n&Qe?"FunctionDeclaration":"FunctionExpression")},q.parseFunctionParams=function(t){this.expect(p.parenL),t.params=this.parseBindingList(p.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams()},q.parseClass=function(t,n){this.next();var e=this.strict;this.strict=!0,this.parseClassId(t,n),this.parseClassSuper(t);var r=this.enterClassBody(),a=this.startNode(),i=!1;for(a.body=[],this.expect(p.braceL);this.type!==p.braceR;){var s=this.parseClassElement(t.superClass!==null);s&&(a.body.push(s),s.type==="MethodDefinition"&&s.kind==="constructor"?(i&&this.raise(s.start,"Duplicate constructor in the same class"),i=!0):s.key&&s.key.type==="PrivateIdentifier"&&Pd(r,s)&&this.raiseRecoverable(s.key.start,"Identifier '#"+s.key.name+"' has already been declared"))}return this.strict=e,this.next(),t.body=this.finishNode(a,"ClassBody"),this.exitClassBody(),this.finishNode(t,n?"ClassDeclaration":"ClassExpression")},q.parseClassElement=function(t){if(this.eat(p.semi))return null;var n=this.options.ecmaVersion,e=this.startNode(),r="",a=!1,i=!1,s="method",o=!1;if(this.eatContextual("static")){if(n>=13&&this.eat(p.braceL))return this.parseClassStaticBlock(e),e;this.isClassElementNameStart()||this.type===p.star?o=!0:r="static"}if(e.static=o,!r&&n>=8&&this.eatContextual("async")&&(!this.isClassElementNameStart()&&this.type!==p.star||this.canInsertSemicolon()?r="async":i=!0),!r&&(n>=9||!i)&&this.eat(p.star)&&(a=!0),!r&&!i&&!a){var _=this.value;(this.eatContextual("get")||this.eatContextual("set"))&&(this.isClassElementNameStart()?s=_:r=_)}if(r?(e.computed=!1,e.key=this.startNodeAt(this.lastTokStart,this.lastTokStartLoc),e.key.name=r,this.finishNode(e.key,"Identifier")):this.parseClassElementName(e),n<13||this.type===p.parenL||s!=="method"||a||i){var l=!e.static&&ia(e,"constructor"),u=l&&t;l&&s!=="method"&&this.raise(e.key.start,"Constructor can't have get/set modifier"),e.kind=l?"constructor":s,this.parseClassMethod(e,a,i,u)}else this.parseClassField(e);return e},q.isClassElementNameStart=function(){return this.type===p.name||this.type===p.privateId||this.type===p.num||this.type===p.string||this.type===p.bracketL||this.type.keyword},q.parseClassElementName=function(t){this.type===p.privateId?(this.value==="constructor"&&this.raise(this.start,"Classes can't have an element named '#constructor'"),t.computed=!1,t.key=this.parsePrivateIdent()):this.parsePropertyName(t)},q.parseClassMethod=function(t,n,e,r){var a=t.key;t.kind==="constructor"?(n&&this.raise(a.start,"Constructor can't be a generator"),e&&this.raise(a.start,"Constructor can't be an async method")):t.static&&ia(t,"prototype")&&this.raise(a.start,"Classes may not have a static property named prototype");var i=t.value=this.parseMethod(n,e,r);return t.kind==="get"&&i.params.length!==0&&this.raiseRecoverable(i.start,"getter should have no params"),t.kind==="set"&&i.params.length!==1&&this.raiseRecoverable(i.start,"setter should have exactly one param"),t.kind==="set"&&i.params[0].type==="RestElement"&&this.raiseRecoverable(i.params[0].start,"Setter cannot use rest params"),this.finishNode(t,"MethodDefinition")},q.parseClassField=function(t){if(ia(t,"constructor")?this.raise(t.key.start,"Classes can't have a field named 'constructor'"):t.static&&ia(t,"prototype")&&this.raise(t.key.start,"Classes can't have a static field named 'prototype'"),this.eat(p.eq)){var n=this.currentThisScope(),e=n.inClassFieldInit;n.inClassFieldInit=!0,t.value=this.parseMaybeAssign(),n.inClassFieldInit=e}else t.value=null;return this.semicolon(),this.finishNode(t,"PropertyDefinition")},q.parseClassStaticBlock=function(t){t.body=[];var n=this.labels;for(this.labels=[],this.enterScope(320);this.type!==p.braceR;){var e=this.parseStatement(null);t.body.push(e)}return this.next(),this.exitScope(),this.labels=n,this.finishNode(t,"StaticBlock")},q.parseClassId=function(t,n){this.type===p.name?(t.id=this.parseIdent(),n&&this.checkLValSimple(t.id,2,!1)):(n===!0&&this.unexpected(),t.id=null)},q.parseClassSuper=function(t){t.superClass=this.eat(p._extends)?this.parseExprSubscripts(null,!1):null},q.enterClassBody=function(){var t={declared:Object.create(null),used:[]};return this.privateNameStack.push(t),t.declared},q.exitClassBody=function(){for(var t=this.privateNameStack.pop(),n=t.declared,e=t.used,r=this.privateNameStack.length,a=r===0?null:this.privateNameStack[r-1],i=0;i<e.length;++i){var s=e[i];Ye(n,s.name)||(a?a.used.push(s):this.raiseRecoverable(s.start,"Private field '#"+s.name+"' must be declared in an enclosing class"))}},q.parseExport=function(t,n){if(this.next(),this.eat(p.star))return this.options.ecmaVersion>=11&&(this.eatContextual("as")?(t.exported=this.parseModuleExportName(),this.checkExport(n,t.exported,this.lastTokStart)):t.exported=null),this.expectContextual("from"),this.type!==p.string&&this.unexpected(),t.source=this.parseExprAtom(),this.semicolon(),this.finishNode(t,"ExportAllDeclaration");if(this.eat(p._default)){var e;if(this.checkExport(n,"default",this.lastTokStart),this.type===p._function||(e=this.isAsyncFunction())){var r=this.startNode();this.next(),e&&this.next(),t.declaration=this.parseFunction(r,4|Qe,!1,e)}else if(this.type===p._class){var a=this.startNode();t.declaration=this.parseClass(a,"nullableID")}else t.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(t,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())t.declaration=this.parseStatement(null),t.declaration.type==="VariableDeclaration"?this.checkVariableExport(n,t.declaration.declarations):this.checkExport(n,t.declaration.id,t.declaration.id.start),t.specifiers=[],t.source=null;else{if(t.declaration=null,t.specifiers=this.parseExportSpecifiers(n),this.eatContextual("from"))this.type!==p.string&&this.unexpected(),t.source=this.parseExprAtom();else{for(var i=0,s=t.specifiers;i<s.length;i+=1){var o=s[i];this.checkUnreserved(o.local),this.checkLocalExport(o.local),o.local.type==="Literal"&&this.raise(o.local.start,"A string literal cannot be used as an exported binding without `from`.")}t.source=null}this.semicolon()}return this.finishNode(t,"ExportNamedDeclaration")},q.checkExport=function(t,n,e){t&&(typeof n!="string"&&(n=n.type==="Identifier"?n.name:n.value),Ye(t,n)&&this.raiseRecoverable(e,"Duplicate export '"+n+"'"),t[n]=!0)},q.checkPatternExport=function(t,n){var e=n.type;if(e==="Identifier")this.checkExport(t,n,n.start);else if(e==="ObjectPattern")for(var r=0,a=n.properties;r<a.length;r+=1){var i=a[r];this.checkPatternExport(t,i)}else if(e==="ArrayPattern")for(var s=0,o=n.elements;s<o.length;s+=1){var _=o[s];_&&this.checkPatternExport(t,_)}else e==="Property"?this.checkPatternExport(t,n.value):e==="AssignmentPattern"?this.checkPatternExport(t,n.left):e==="RestElement"?this.checkPatternExport(t,n.argument):e==="ParenthesizedExpression"&&this.checkPatternExport(t,n.expression)},q.checkVariableExport=function(t,n){if(t)for(var e=0,r=n;e<r.length;e+=1){var a=r[e];this.checkPatternExport(t,a.id)}},q.shouldParseExportStatement=function(){return this.type.keyword==="var"||this.type.keyword==="const"||this.type.keyword==="class"||this.type.keyword==="function"||this.isLet()||this.isAsyncFunction()},q.parseExportSpecifiers=function(t){var n=[],e=!0;for(this.expect(p.braceL);!this.eat(p.braceR);){if(e)e=!1;else if(this.expect(p.comma),this.afterTrailingComma(p.braceR))break;var r=this.startNode();r.local=this.parseModuleExportName(),r.exported=this.eatContextual("as")?this.parseModuleExportName():r.local,this.checkExport(t,r.exported,r.exported.start),n.push(this.finishNode(r,"ExportSpecifier"))}return n},q.parseImport=function(t){return this.next(),this.type===p.string?(t.specifiers=Dd,t.source=this.parseExprAtom()):(t.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),t.source=this.type===p.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(t,"ImportDeclaration")},q.parseImportSpecifiers=function(){var t=[],n=!0;if(this.type===p.name){var e=this.startNode();if(e.local=this.parseIdent(),this.checkLValSimple(e.local,2),t.push(this.finishNode(e,"ImportDefaultSpecifier")),!this.eat(p.comma))return t}if(this.type===p.star){var r=this.startNode();return this.next(),this.expectContextual("as"),r.local=this.parseIdent(),this.checkLValSimple(r.local,2),t.push(this.finishNode(r,"ImportNamespaceSpecifier")),t}for(this.expect(p.braceL);!this.eat(p.braceR);){if(n)n=!1;else if(this.expect(p.comma),this.afterTrailingComma(p.braceR))break;var a=this.startNode();a.imported=this.parseModuleExportName(),this.eatContextual("as")?a.local=this.parseIdent():(this.checkUnreserved(a.imported),a.local=a.imported),this.checkLValSimple(a.local,2),t.push(this.finishNode(a,"ImportSpecifier"))}return t},q.parseModuleExportName=function(){if(this.options.ecmaVersion>=13&&this.type===p.string){var t=this.parseLiteral(this.value);return Td.test(t.value)&&this.raise(t.start,"An export name cannot include a lone surrogate."),t}return this.parseIdent(!0)},q.adaptDirectivePrologue=function(t){for(var n=0;n<t.length&&this.isDirectiveCandidate(t[n]);++n)t[n].directive=t[n].expression.raw.slice(1,-1)},q.isDirectiveCandidate=function(t){return this.options.ecmaVersion>=5&&t.type==="ExpressionStatement"&&t.expression.type==="Literal"&&typeof t.expression.value=="string"&&(this.input[t.start]==='"'||this.input[t.start]==="'")};var Qn=pn.prototype;Qn.toAssignable=function(t,n,e){if(this.options.ecmaVersion>=6&&t)switch(t.type){case"Identifier":this.inAsync&&t.name==="await"&&this.raise(t.start,"Cannot use 'await' as identifier inside an async function");break;case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":case"RestElement":break;case"ObjectExpression":t.type="ObjectPattern",e&&this.checkPatternErrors(e,!0);for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];this.toAssignable(i,n),i.type!=="RestElement"||i.argument.type!=="ArrayPattern"&&i.argument.type!=="ObjectPattern"||this.raise(i.argument.start,"Unexpected token")}break;case"Property":t.kind!=="init"&&this.raise(t.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(t.value,n);break;case"ArrayExpression":t.type="ArrayPattern",e&&this.checkPatternErrors(e,!0),this.toAssignableList(t.elements,n);break;case"SpreadElement":t.type="RestElement",this.toAssignable(t.argument,n),t.argument.type==="AssignmentPattern"&&this.raise(t.argument.start,"Rest elements cannot have a default value");break;case"AssignmentExpression":t.operator!=="="&&this.raise(t.left.end,"Only '=' operator can be used for specifying default value."),t.type="AssignmentPattern",delete t.operator,this.toAssignable(t.left,n);break;case"ParenthesizedExpression":this.toAssignable(t.expression,n,e);break;case"ChainExpression":this.raiseRecoverable(t.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":if(!n)break;default:this.raise(t.start,"Assigning to rvalue")}else e&&this.checkPatternErrors(e,!0);return t},Qn.toAssignableList=function(t,n){for(var e=t.length,r=0;r<e;r++){var a=t[r];a&&this.toAssignable(a,n)}if(e){var i=t[e-1];this.options.ecmaVersion===6&&n&&i&&i.type==="RestElement"&&i.argument.type!=="Identifier"&&this.unexpected(i.argument.start)}return t},Qn.parseSpread=function(t){var n=this.startNode();return this.next(),n.argument=this.parseMaybeAssign(!1,t),this.finishNode(n,"SpreadElement")},Qn.parseRestBinding=function(){var t=this.startNode();return this.next(),this.options.ecmaVersion===6&&this.type!==p.name&&this.unexpected(),t.argument=this.parseBindingAtom(),this.finishNode(t,"RestElement")},Qn.parseBindingAtom=function(){if(this.options.ecmaVersion>=6)switch(this.type){case p.bracketL:var t=this.startNode();return this.next(),t.elements=this.parseBindingList(p.bracketR,!0,!0),this.finishNode(t,"ArrayPattern");case p.braceL:return this.parseObj(!0)}return this.parseIdent()},Qn.parseBindingList=function(t,n,e){for(var r=[],a=!0;!this.eat(t);)if(a?a=!1:this.expect(p.comma),n&&this.type===p.comma)r.push(null);else{if(e&&this.afterTrailingComma(t))break;if(this.type===p.ellipsis){var i=this.parseRestBinding();this.parseBindingListItem(i),r.push(i),this.type===p.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.expect(t);break}var s=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(s),r.push(s)}return r},Qn.parseBindingListItem=function(t){return t},Qn.parseMaybeDefault=function(t,n,e){if(e=e||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(p.eq))return e;var r=this.startNodeAt(t,n);return r.left=e,r.right=this.parseMaybeAssign(),this.finishNode(r,"AssignmentPattern")},Qn.checkLValSimple=function(t,n,e){n===void 0&&(n=0);var r=n!==0;switch(t.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(t.name)&&this.raiseRecoverable(t.start,(r?"Binding ":"Assigning to ")+t.name+" in strict mode"),r&&(n===2&&t.name==="let"&&this.raiseRecoverable(t.start,"let is disallowed as a lexically bound name"),e&&(Ye(e,t.name)&&this.raiseRecoverable(t.start,"Argument name clash"),e[t.name]=!0),n!==5&&this.declareName(t.name,n,t.start));break;case"ChainExpression":this.raiseRecoverable(t.start,"Optional chaining cannot appear in left-hand side");break;case"MemberExpression":r&&this.raiseRecoverable(t.start,"Binding member expression");break;case"ParenthesizedExpression":return r&&this.raiseRecoverable(t.start,"Binding parenthesized expression"),this.checkLValSimple(t.expression,n,e);default:this.raise(t.start,(r?"Binding":"Assigning to")+" rvalue")}},Qn.checkLValPattern=function(t,n,e){switch(n===void 0&&(n=0),t.type){case"ObjectPattern":for(var r=0,a=t.properties;r<a.length;r+=1){var i=a[r];this.checkLValInnerPattern(i,n,e)}break;case"ArrayPattern":for(var s=0,o=t.elements;s<o.length;s+=1){var _=o[s];_&&this.checkLValInnerPattern(_,n,e)}break;default:this.checkLValSimple(t,n,e)}},Qn.checkLValInnerPattern=function(t,n,e){switch(n===void 0&&(n=0),t.type){case"Property":this.checkLValInnerPattern(t.value,n,e);break;case"AssignmentPattern":this.checkLValPattern(t.left,n,e);break;case"RestElement":this.checkLValPattern(t.argument,n,e);break;default:this.checkLValPattern(t,n,e)}};var Wn=function(t,n,e,r,a){this.token=t,this.isExpr=!!n,this.preserveSpace=!!e,this.override=r,this.generator=!!a},un={b_stat:new Wn("{",!1),b_expr:new Wn("{",!0),b_tmpl:new Wn("${",!1),p_stat:new Wn("(",!1),p_expr:new Wn("(",!0),q_tmpl:new Wn("`",!0,!0,function(t){return t.tryReadTemplateToken()}),f_stat:new Wn("function",!1),f_expr:new Wn("function",!0),f_expr_gen:new Wn("function",!0,!1,null,!0),f_gen:new Wn("function",!1,!1,null,!0)},pe=pn.prototype;pe.initialContext=function(){return[un.b_stat]},pe.curContext=function(){return this.context[this.context.length-1]},pe.braceIsBlock=function(t){var n=this.curContext();return n===un.f_expr||n===un.f_stat||(t!==p.colon||n!==un.b_stat&&n!==un.b_expr?t===p._return||t===p.name&&this.exprAllowed?Gn.test(this.input.slice(this.lastTokEnd,this.start)):t===p._else||t===p.semi||t===p.eof||t===p.parenR||t===p.arrow||(t===p.braceL?n===un.b_stat:t!==p._var&&t!==p._const&&t!==p.name&&!this.exprAllowed):!n.isExpr)},pe.inGeneratorContext=function(){for(var t=this.context.length-1;t>=1;t--){var n=this.context[t];if(n.token==="function")return n.generator}return!1},pe.updateContext=function(t){var n,e=this.type;e.keyword&&t===p.dot?this.exprAllowed=!1:(n=e.updateContext)?n.call(this,t):this.exprAllowed=e.beforeExpr},pe.overrideContext=function(t){this.curContext()!==t&&(this.context[this.context.length-1]=t)},p.parenR.updateContext=p.braceR.updateContext=function(){if(this.context.length!==1){var t=this.context.pop();t===un.b_stat&&this.curContext().token==="function"&&(t=this.context.pop()),this.exprAllowed=!t.isExpr}else this.exprAllowed=!0},p.braceL.updateContext=function(t){this.context.push(this.braceIsBlock(t)?un.b_stat:un.b_expr),this.exprAllowed=!0},p.dollarBraceL.updateContext=function(){this.context.push(un.b_tmpl),this.exprAllowed=!0},p.parenL.updateContext=function(t){var n=t===p._if||t===p._for||t===p._with||t===p._while;this.context.push(n?un.p_stat:un.p_expr),this.exprAllowed=!0},p.incDec.updateContext=function(){},p._function.updateContext=p._class.updateContext=function(t){!t.beforeExpr||t===p._else||t===p.semi&&this.curContext()!==un.p_stat||t===p._return&&Gn.test(this.input.slice(this.lastTokEnd,this.start))||(t===p.colon||t===p.braceL)&&this.curContext()===un.b_stat?this.context.push(un.f_stat):this.context.push(un.f_expr),this.exprAllowed=!1},p.backQuote.updateContext=function(){this.curContext()===un.q_tmpl?this.context.pop():this.context.push(un.q_tmpl),this.exprAllowed=!1},p.star.updateContext=function(t){if(t===p._function){var n=this.context.length-1;this.context[n]===un.f_expr?this.context[n]=un.f_expr_gen:this.context[n]=un.f_gen}this.exprAllowed=!0},p.name.updateContext=function(t){var n=!1;this.options.ecmaVersion>=6&&t!==p.dot&&(this.value==="of"&&!this.exprAllowed||this.value==="yield"&&this.inGeneratorContext())&&(n=!0),this.exprAllowed=n};var W=pn.prototype;function cl(t){return t.type==="MemberExpression"&&t.property.type==="PrivateIdentifier"||t.type==="ChainExpression"&&cl(t.expression)}W.checkPropClash=function(t,n,e){if(!(this.options.ecmaVersion>=9&&t.type==="SpreadElement"||this.options.ecmaVersion>=6&&(t.computed||t.method||t.shorthand))){var r,a=t.key;switch(a.type){case"Identifier":r=a.name;break;case"Literal":r=String(a.value);break;default:return}var i=t.kind;if(this.options.ecmaVersion>=6)r==="__proto__"&&i==="init"&&(n.proto&&(e?e.doubleProto<0&&(e.doubleProto=a.start):this.raiseRecoverable(a.start,"Redefinition of __proto__ property")),n.proto=!0);else{var s=n[r="$"+r];s?(i==="init"?this.strict&&s.init||s.get||s.set:s.init||s[i])&&this.raiseRecoverable(a.start,"Redefinition of property"):s=n[r]={init:!1,get:!1,set:!1},s[i]=!0}}},W.parseExpression=function(t,n){var e=this.start,r=this.startLoc,a=this.parseMaybeAssign(t,n);if(this.type===p.comma){var i=this.startNodeAt(e,r);for(i.expressions=[a];this.eat(p.comma);)i.expressions.push(this.parseMaybeAssign(t,n));return this.finishNode(i,"SequenceExpression")}return a},W.parseMaybeAssign=function(t,n,e){if(this.isContextual("yield")){if(this.inGenerator)return this.parseYield(t);this.exprAllowed=!1}var r=!1,a=-1,i=-1,s=-1;n?(a=n.parenthesizedAssign,i=n.trailingComma,s=n.doubleProto,n.parenthesizedAssign=n.trailingComma=-1):(n=new aa,r=!0);var o=this.start,_=this.startLoc;this.type!==p.parenL&&this.type!==p.name||(this.potentialArrowAt=this.start,this.potentialArrowInForAwait=t==="await");var l=this.parseMaybeConditional(t,n);if(e&&(l=e.call(this,l,o,_)),this.type.isAssign){var u=this.startNodeAt(o,_);return u.operator=this.value,this.type===p.eq&&(l=this.toAssignable(l,!1,n)),r||(n.parenthesizedAssign=n.trailingComma=n.doubleProto=-1),n.shorthandAssign>=l.start&&(n.shorthandAssign=-1),this.type===p.eq?this.checkLValPattern(l):this.checkLValSimple(l),u.left=l,this.next(),u.right=this.parseMaybeAssign(t),s>-1&&(n.doubleProto=s),this.finishNode(u,"AssignmentExpression")}return r&&this.checkExpressionErrors(n,!0),a>-1&&(n.parenthesizedAssign=a),i>-1&&(n.trailingComma=i),l},W.parseMaybeConditional=function(t,n){var e=this.start,r=this.startLoc,a=this.parseExprOps(t,n);if(this.checkExpressionErrors(n))return a;if(this.eat(p.question)){var i=this.startNodeAt(e,r);return i.test=a,i.consequent=this.parseMaybeAssign(),this.expect(p.colon),i.alternate=this.parseMaybeAssign(t),this.finishNode(i,"ConditionalExpression")}return a},W.parseExprOps=function(t,n){var e=this.start,r=this.startLoc,a=this.parseMaybeUnary(n,!1,!1,t);return this.checkExpressionErrors(n)||a.start===e&&a.type==="ArrowFunctionExpression"?a:this.parseExprOp(a,e,r,-1,t)},W.parseExprOp=function(t,n,e,r,a){var i=this.type.binop;if(i!=null&&(!a||this.type!==p._in)&&i>r){var s=this.type===p.logicalOR||this.type===p.logicalAND,o=this.type===p.coalesce;o&&(i=p.logicalAND.binop);var _=this.value;this.next();var l=this.start,u=this.startLoc,f=this.parseExprOp(this.parseMaybeUnary(null,!1,!1,a),l,u,i,a),m=this.buildBinary(n,e,t,f,_,s||o);return(s&&this.type===p.coalesce||o&&(this.type===p.logicalOR||this.type===p.logicalAND))&&this.raiseRecoverable(this.start,"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"),this.parseExprOp(m,n,e,r,a)}return t},W.buildBinary=function(t,n,e,r,a,i){r.type==="PrivateIdentifier"&&this.raise(r.start,"Private identifier can only be left side of binary expression");var s=this.startNodeAt(t,n);return s.left=e,s.operator=a,s.right=r,this.finishNode(s,i?"LogicalExpression":"BinaryExpression")},W.parseMaybeUnary=function(t,n,e,r){var a,i=this.start,s=this.startLoc;if(this.isContextual("await")&&this.canAwait)a=this.parseAwait(r),n=!0;else if(this.type.prefix){var o=this.startNode(),_=this.type===p.incDec;o.operator=this.value,o.prefix=!0,this.next(),o.argument=this.parseMaybeUnary(null,!0,_,r),this.checkExpressionErrors(t,!0),_?this.checkLValSimple(o.argument):this.strict&&o.operator==="delete"&&o.argument.type==="Identifier"?this.raiseRecoverable(o.start,"Deleting local variable in strict mode"):o.operator==="delete"&&cl(o.argument)?this.raiseRecoverable(o.start,"Private fields can not be deleted"):n=!0,a=this.finishNode(o,_?"UpdateExpression":"UnaryExpression")}else if(n||this.type!==p.privateId){if(a=this.parseExprSubscripts(t,r),this.checkExpressionErrors(t))return a;for(;this.type.postfix&&!this.canInsertSemicolon();){var l=this.startNodeAt(i,s);l.operator=this.value,l.prefix=!1,l.argument=a,this.checkLValSimple(a),this.next(),a=this.finishNode(l,"UpdateExpression")}}else(r||this.privateNameStack.length===0)&&this.unexpected(),a=this.parsePrivateIdent(),this.type!==p._in&&this.unexpected();return e||!this.eat(p.starstar)?a:n?void this.unexpected(this.lastTokStart):this.buildBinary(i,s,a,this.parseMaybeUnary(null,!1,!1,r),"**",!1)},W.parseExprSubscripts=function(t,n){var e=this.start,r=this.startLoc,a=this.parseExprAtom(t,n);if(a.type==="ArrowFunctionExpression"&&this.input.slice(this.lastTokStart,this.lastTokEnd)!==")")return a;var i=this.parseSubscripts(a,e,r,!1,n);return t&&i.type==="MemberExpression"&&(t.parenthesizedAssign>=i.start&&(t.parenthesizedAssign=-1),t.parenthesizedBind>=i.start&&(t.parenthesizedBind=-1),t.trailingComma>=i.start&&(t.trailingComma=-1)),i},W.parseSubscripts=function(t,n,e,r,a){for(var i=this.options.ecmaVersion>=8&&t.type==="Identifier"&&t.name==="async"&&this.lastTokEnd===t.end&&!this.canInsertSemicolon()&&t.end-t.start==5&&this.potentialArrowAt===t.start,s=!1;;){var o=this.parseSubscript(t,n,e,r,i,s,a);if(o.optional&&(s=!0),o===t||o.type==="ArrowFunctionExpression"){if(s){var _=this.startNodeAt(n,e);_.expression=o,o=this.finishNode(_,"ChainExpression")}return o}t=o}},W.parseSubscript=function(t,n,e,r,a,i,s){var o=this.options.ecmaVersion>=11,_=o&&this.eat(p.questionDot);r&&_&&this.raise(this.lastTokStart,"Optional chaining cannot appear in the callee of new expressions");var l=this.eat(p.bracketL);if(l||_&&this.type!==p.parenL&&this.type!==p.backQuote||this.eat(p.dot)){var u=this.startNodeAt(n,e);u.object=t,l?(u.property=this.parseExpression(),this.expect(p.bracketR)):this.type===p.privateId&&t.type!=="Super"?u.property=this.parsePrivateIdent():u.property=this.parseIdent(this.options.allowReserved!=="never"),u.computed=!!l,o&&(u.optional=_),t=this.finishNode(u,"MemberExpression")}else if(!r&&this.eat(p.parenL)){var f=new aa,m=this.yieldPos,h=this.awaitPos,v=this.awaitIdentPos;this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0;var d=this.parseExprList(p.parenR,this.options.ecmaVersion>=8,!1,f);if(a&&!_&&!this.canInsertSemicolon()&&this.eat(p.arrow))return this.checkPatternErrors(f,!1),this.checkYieldAwaitInDefaultParams(),this.awaitIdentPos>0&&this.raise(this.awaitIdentPos,"Cannot use 'await' as identifier inside an async function"),this.yieldPos=m,this.awaitPos=h,this.awaitIdentPos=v,this.parseArrowExpression(this.startNodeAt(n,e),d,!0,s);this.checkExpressionErrors(f,!0),this.yieldPos=m||this.yieldPos,this.awaitPos=h||this.awaitPos,this.awaitIdentPos=v||this.awaitIdentPos;var g=this.startNodeAt(n,e);g.callee=t,g.arguments=d,o&&(g.optional=_),t=this.finishNode(g,"CallExpression")}else if(this.type===p.backQuote){(_||i)&&this.raise(this.start,"Optional chaining cannot appear in the tag of tagged template expressions");var y=this.startNodeAt(n,e);y.tag=t,y.quasi=this.parseTemplate({isTagged:!0}),t=this.finishNode(y,"TaggedTemplateExpression")}return t},W.parseExprAtom=function(t,n){this.type===p.slash&&this.readRegexp();var e,r=this.potentialArrowAt===this.start;switch(this.type){case p._super:return this.allowSuper||this.raise(this.start,"'super' keyword outside a method"),e=this.startNode(),this.next(),this.type!==p.parenL||this.allowDirectSuper||this.raise(e.start,"super() call outside constructor of a subclass"),this.type!==p.dot&&this.type!==p.bracketL&&this.type!==p.parenL&&this.unexpected(),this.finishNode(e,"Super");case p._this:return e=this.startNode(),this.next(),this.finishNode(e,"ThisExpression");case p.name:var a=this.start,i=this.startLoc,s=this.containsEsc,o=this.parseIdent(!1);if(this.options.ecmaVersion>=8&&!s&&o.name==="async"&&!this.canInsertSemicolon()&&this.eat(p._function))return this.overrideContext(un.f_expr),this.parseFunction(this.startNodeAt(a,i),0,!1,!0,n);if(r&&!this.canInsertSemicolon()){if(this.eat(p.arrow))return this.parseArrowExpression(this.startNodeAt(a,i),[o],!1,n);if(this.options.ecmaVersion>=8&&o.name==="async"&&this.type===p.name&&!s&&(!this.potentialArrowInForAwait||this.value!=="of"||this.containsEsc))return o=this.parseIdent(!1),!this.canInsertSemicolon()&&this.eat(p.arrow)||this.unexpected(),this.parseArrowExpression(this.startNodeAt(a,i),[o],!0,n)}return o;case p.regexp:var _=this.value;return(e=this.parseLiteral(_.value)).regex={pattern:_.pattern,flags:_.flags},e;case p.num:case p.string:return this.parseLiteral(this.value);case p._null:case p._true:case p._false:return(e=this.startNode()).value=this.type===p._null?null:this.type===p._true,e.raw=this.type.keyword,this.next(),this.finishNode(e,"Literal");case p.parenL:var l=this.start,u=this.parseParenAndDistinguishExpression(r,n);return t&&(t.parenthesizedAssign<0&&!this.isSimpleAssignTarget(u)&&(t.parenthesizedAssign=l),t.parenthesizedBind<0&&(t.parenthesizedBind=l)),u;case p.bracketL:return e=this.startNode(),this.next(),e.elements=this.parseExprList(p.bracketR,!0,!0,t),this.finishNode(e,"ArrayExpression");case p.braceL:return this.overrideContext(un.b_expr),this.parseObj(!1,t);case p._function:return e=this.startNode(),this.next(),this.parseFunction(e,0);case p._class:return this.parseClass(this.startNode(),!1);case p._new:return this.parseNew();case p.backQuote:return this.parseTemplate();case p._import:return this.options.ecmaVersion>=11?this.parseExprImport():this.unexpected();default:this.unexpected()}},W.parseExprImport=function(){var t=this.startNode();this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword import");var n=this.parseIdent(!0);switch(this.type){case p.parenL:return this.parseDynamicImport(t);case p.dot:return t.meta=n,this.parseImportMeta(t);default:this.unexpected()}},W.parseDynamicImport=function(t){if(this.next(),t.source=this.parseMaybeAssign(),!this.eat(p.parenR)){var n=this.start;this.eat(p.comma)&&this.eat(p.parenR)?this.raiseRecoverable(n,"Trailing comma is not allowed in import()"):this.unexpected(n)}return this.finishNode(t,"ImportExpression")},W.parseImportMeta=function(t){this.next();var n=this.containsEsc;return t.property=this.parseIdent(!0),t.property.name!=="meta"&&this.raiseRecoverable(t.property.start,"The only valid meta property for import is 'import.meta'"),n&&this.raiseRecoverable(t.start,"'import.meta' must not contain escaped characters"),this.options.sourceType==="module"||this.options.allowImportExportEverywhere||this.raiseRecoverable(t.start,"Cannot use 'import.meta' outside a module"),this.finishNode(t,"MetaProperty")},W.parseLiteral=function(t){var n=this.startNode();return n.value=t,n.raw=this.input.slice(this.start,this.end),n.raw.charCodeAt(n.raw.length-1)===110&&(n.bigint=n.raw.slice(0,-1).replace(/_/g,"")),this.next(),this.finishNode(n,"Literal")},W.parseParenExpression=function(){this.expect(p.parenL);var t=this.parseExpression();return this.expect(p.parenR),t},W.parseParenAndDistinguishExpression=function(t,n){var e,r=this.start,a=this.startLoc,i=this.options.ecmaVersion>=8;if(this.options.ecmaVersion>=6){this.next();var s,o=this.start,_=this.startLoc,l=[],u=!0,f=!1,m=new aa,h=this.yieldPos,v=this.awaitPos;for(this.yieldPos=0,this.awaitPos=0;this.type!==p.parenR;){if(u?u=!1:this.expect(p.comma),i&&this.afterTrailingComma(p.parenR,!0)){f=!0;break}if(this.type===p.ellipsis){s=this.start,l.push(this.parseParenItem(this.parseRestBinding())),this.type===p.comma&&this.raise(this.start,"Comma is not permitted after the rest element");break}l.push(this.parseMaybeAssign(!1,m,this.parseParenItem))}var d=this.lastTokEnd,g=this.lastTokEndLoc;if(this.expect(p.parenR),t&&!this.canInsertSemicolon()&&this.eat(p.arrow))return this.checkPatternErrors(m,!1),this.checkYieldAwaitInDefaultParams(),this.yieldPos=h,this.awaitPos=v,this.parseParenArrowList(r,a,l,n);l.length&&!f||this.unexpected(this.lastTokStart),s&&this.unexpected(s),this.checkExpressionErrors(m,!0),this.yieldPos=h||this.yieldPos,this.awaitPos=v||this.awaitPos,l.length>1?((e=this.startNodeAt(o,_)).expressions=l,this.finishNodeAt(e,"SequenceExpression",d,g)):e=l[0]}else e=this.parseParenExpression();if(this.options.preserveParens){var y=this.startNodeAt(r,a);return y.expression=e,this.finishNode(y,"ParenthesizedExpression")}return e},W.parseParenItem=function(t){return t},W.parseParenArrowList=function(t,n,e,r){return this.parseArrowExpression(this.startNodeAt(t,n),e,!1,r)};var Od=[];W.parseNew=function(){this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword new");var t=this.startNode(),n=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(p.dot)){t.meta=n;var e=this.containsEsc;return t.property=this.parseIdent(!0),t.property.name!=="target"&&this.raiseRecoverable(t.property.start,"The only valid meta property for new is 'new.target'"),e&&this.raiseRecoverable(t.start,"'new.target' must not contain escaped characters"),this.allowNewDotTarget||this.raiseRecoverable(t.start,"'new.target' can only be used in functions and class static block"),this.finishNode(t,"MetaProperty")}var r=this.start,a=this.startLoc,i=this.type===p._import;return t.callee=this.parseSubscripts(this.parseExprAtom(),r,a,!0,!1),i&&t.callee.type==="ImportExpression"&&this.raise(r,"Cannot use new with import()"),this.eat(p.parenL)?t.arguments=this.parseExprList(p.parenR,this.options.ecmaVersion>=8,!1):t.arguments=Od,this.finishNode(t,"NewExpression")},W.parseTemplateElement=function(t){var n=t.isTagged,e=this.startNode();return this.type===p.invalidTemplate?(n||this.raiseRecoverable(this.start,"Bad escape sequence in untagged template literal"),e.value={raw:this.value,cooked:null}):e.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,`
`),cooked:this.value},this.next(),e.tail=this.type===p.backQuote,this.finishNode(e,"TemplateElement")},W.parseTemplate=function(t){t===void 0&&(t={});var n=t.isTagged;n===void 0&&(n=!1);var e=this.startNode();this.next(),e.expressions=[];var r=this.parseTemplateElement({isTagged:n});for(e.quasis=[r];!r.tail;)this.type===p.eof&&this.raise(this.pos,"Unterminated template literal"),this.expect(p.dollarBraceL),e.expressions.push(this.parseExpression()),this.expect(p.braceR),e.quasis.push(r=this.parseTemplateElement({isTagged:n}));return this.next(),this.finishNode(e,"TemplateLiteral")},W.isAsyncProp=function(t){return!t.computed&&t.key.type==="Identifier"&&t.key.name==="async"&&(this.type===p.name||this.type===p.num||this.type===p.string||this.type===p.bracketL||this.type.keyword||this.options.ecmaVersion>=9&&this.type===p.star)&&!Gn.test(this.input.slice(this.lastTokEnd,this.start))},W.parseObj=function(t,n){var e=this.startNode(),r=!0,a={};for(e.properties=[],this.next();!this.eat(p.braceR);){if(r)r=!1;else if(this.expect(p.comma),this.options.ecmaVersion>=5&&this.afterTrailingComma(p.braceR))break;var i=this.parseProperty(t,n);t||this.checkPropClash(i,a,n),e.properties.push(i)}return this.finishNode(e,t?"ObjectPattern":"ObjectExpression")},W.parseProperty=function(t,n){var e,r,a,i,s=this.startNode();if(this.options.ecmaVersion>=9&&this.eat(p.ellipsis))return t?(s.argument=this.parseIdent(!1),this.type===p.comma&&this.raise(this.start,"Comma is not permitted after the rest element"),this.finishNode(s,"RestElement")):(s.argument=this.parseMaybeAssign(!1,n),this.type===p.comma&&n&&n.trailingComma<0&&(n.trailingComma=this.start),this.finishNode(s,"SpreadElement"));this.options.ecmaVersion>=6&&(s.method=!1,s.shorthand=!1,(t||n)&&(a=this.start,i=this.startLoc),t||(e=this.eat(p.star)));var o=this.containsEsc;return this.parsePropertyName(s),!t&&!o&&this.options.ecmaVersion>=8&&!e&&this.isAsyncProp(s)?(r=!0,e=this.options.ecmaVersion>=9&&this.eat(p.star),this.parsePropertyName(s)):r=!1,this.parsePropertyValue(s,t,e,r,a,i,n,o),this.finishNode(s,"Property")},W.parsePropertyValue=function(t,n,e,r,a,i,s,o){if((e||r)&&this.type===p.colon&&this.unexpected(),this.eat(p.colon))t.value=n?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,s),t.kind="init";else if(this.options.ecmaVersion>=6&&this.type===p.parenL)n&&this.unexpected(),t.kind="init",t.method=!0,t.value=this.parseMethod(e,r);else if(n||o||!(this.options.ecmaVersion>=5)||t.computed||t.key.type!=="Identifier"||t.key.name!=="get"&&t.key.name!=="set"||this.type===p.comma||this.type===p.braceR||this.type===p.eq)this.options.ecmaVersion>=6&&!t.computed&&t.key.type==="Identifier"?((e||r)&&this.unexpected(),this.checkUnreserved(t.key),t.key.name!=="await"||this.awaitIdentPos||(this.awaitIdentPos=a),t.kind="init",n?t.value=this.parseMaybeDefault(a,i,this.copyNode(t.key)):this.type===p.eq&&s?(s.shorthandAssign<0&&(s.shorthandAssign=this.start),t.value=this.parseMaybeDefault(a,i,this.copyNode(t.key))):t.value=this.copyNode(t.key),t.shorthand=!0):this.unexpected();else{(e||r)&&this.unexpected(),t.kind=t.key.name,this.parsePropertyName(t),t.value=this.parseMethod(!1);var _=t.kind==="get"?0:1;if(t.value.params.length!==_){var l=t.value.start;t.kind==="get"?this.raiseRecoverable(l,"getter should have no params"):this.raiseRecoverable(l,"setter should have exactly one param")}else t.kind==="set"&&t.value.params[0].type==="RestElement"&&this.raiseRecoverable(t.value.params[0].start,"Setter cannot use rest params")}},W.parsePropertyName=function(t){if(this.options.ecmaVersion>=6){if(this.eat(p.bracketL))return t.computed=!0,t.key=this.parseMaybeAssign(),this.expect(p.bracketR),t.key;t.computed=!1}return t.key=this.type===p.num||this.type===p.string?this.parseExprAtom():this.parseIdent(this.options.allowReserved!=="never")},W.initFunction=function(t){t.id=null,this.options.ecmaVersion>=6&&(t.generator=t.expression=!1),this.options.ecmaVersion>=8&&(t.async=!1)},W.parseMethod=function(t,n,e){var r=this.startNode(),a=this.yieldPos,i=this.awaitPos,s=this.awaitIdentPos;return this.initFunction(r),this.options.ecmaVersion>=6&&(r.generator=t),this.options.ecmaVersion>=8&&(r.async=!!n),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,this.enterScope(64|Qi(n,r.generator)|(e?128:0)),this.expect(p.parenL),r.params=this.parseBindingList(p.parenR,!1,this.options.ecmaVersion>=8),this.checkYieldAwaitInDefaultParams(),this.parseFunctionBody(r,!1,!0,!1),this.yieldPos=a,this.awaitPos=i,this.awaitIdentPos=s,this.finishNode(r,"FunctionExpression")},W.parseArrowExpression=function(t,n,e,r){var a=this.yieldPos,i=this.awaitPos,s=this.awaitIdentPos;return this.enterScope(16|Qi(e,!1)),this.initFunction(t),this.options.ecmaVersion>=8&&(t.async=!!e),this.yieldPos=0,this.awaitPos=0,this.awaitIdentPos=0,t.params=this.toAssignableList(n,!0),this.parseFunctionBody(t,!0,!1,r),this.yieldPos=a,this.awaitPos=i,this.awaitIdentPos=s,this.finishNode(t,"ArrowFunctionExpression")},W.parseFunctionBody=function(t,n,e,r){var a=n&&this.type!==p.braceL,i=this.strict,s=!1;if(a)t.body=this.parseMaybeAssign(r),t.expression=!0,this.checkParams(t,!1);else{var o=this.options.ecmaVersion>=7&&!this.isSimpleParamList(t.params);i&&!o||(s=this.strictDirective(this.end))&&o&&this.raiseRecoverable(t.start,"Illegal 'use strict' directive in function with non-simple parameter list");var _=this.labels;this.labels=[],s&&(this.strict=!0),this.checkParams(t,!i&&!s&&!n&&!e&&this.isSimpleParamList(t.params)),this.strict&&t.id&&this.checkLValSimple(t.id,5),t.body=this.parseBlock(!1,void 0,s&&!i),t.expression=!1,this.adaptDirectivePrologue(t.body.body),this.labels=_}this.exitScope()},W.isSimpleParamList=function(t){for(var n=0,e=t;n<e.length;n+=1)if(e[n].type!=="Identifier")return!1;return!0},W.checkParams=function(t,n){for(var e=Object.create(null),r=0,a=t.params;r<a.length;r+=1){var i=a[r];this.checkLValInnerPattern(i,1,n?null:e)}},W.parseExprList=function(t,n,e,r){for(var a=[],i=!0;!this.eat(t);){if(i)i=!1;else if(this.expect(p.comma),n&&this.afterTrailingComma(t))break;var s=void 0;e&&this.type===p.comma?s=null:this.type===p.ellipsis?(s=this.parseSpread(r),r&&this.type===p.comma&&r.trailingComma<0&&(r.trailingComma=this.start)):s=this.parseMaybeAssign(!1,r),a.push(s)}return a},W.checkUnreserved=function(t){var n=t.start,e=t.end,r=t.name;this.inGenerator&&r==="yield"&&this.raiseRecoverable(n,"Cannot use 'yield' as identifier inside a generator"),this.inAsync&&r==="await"&&this.raiseRecoverable(n,"Cannot use 'await' as identifier inside an async function"),this.currentThisScope().inClassFieldInit&&r==="arguments"&&this.raiseRecoverable(n,"Cannot use 'arguments' in class field initializer"),!this.inClassStaticBlock||r!=="arguments"&&r!=="await"||this.raise(n,"Cannot use "+r+" in class static initialization block"),this.keywords.test(r)&&this.raise(n,"Unexpected keyword '"+r+"'"),this.options.ecmaVersion<6&&this.input.slice(n,e).indexOf("\\")!==-1||(this.strict?this.reservedWordsStrict:this.reservedWords).test(r)&&(this.inAsync||r!=="await"||this.raiseRecoverable(n,"Cannot use keyword 'await' outside an async function"),this.raiseRecoverable(n,"The keyword '"+r+"' is reserved"))},W.parseIdent=function(t){var n=this.startNode();return this.type===p.name?n.name=this.value:this.type.keyword?(n.name=this.type.keyword,n.name!=="class"&&n.name!=="function"||this.lastTokEnd===this.lastTokStart+1&&this.input.charCodeAt(this.lastTokStart)===46||this.context.pop()):this.unexpected(),this.next(!!t),this.finishNode(n,"Identifier"),t||(this.checkUnreserved(n),n.name!=="await"||this.awaitIdentPos||(this.awaitIdentPos=n.start)),n},W.parsePrivateIdent=function(){var t=this.startNode();return this.type===p.privateId?t.name=this.value:this.unexpected(),this.next(),this.finishNode(t,"PrivateIdentifier"),this.privateNameStack.length===0?this.raise(t.start,"Private field '#"+t.name+"' must be declared in an enclosing class"):this.privateNameStack[this.privateNameStack.length-1].used.push(t),t},W.parseYield=function(t){this.yieldPos||(this.yieldPos=this.start);var n=this.startNode();return this.next(),this.type===p.semi||this.canInsertSemicolon()||this.type!==p.star&&!this.type.startsExpr?(n.delegate=!1,n.argument=null):(n.delegate=this.eat(p.star),n.argument=this.parseMaybeAssign(t)),this.finishNode(n,"YieldExpression")},W.parseAwait=function(t){this.awaitPos||(this.awaitPos=this.start);var n=this.startNode();return this.next(),n.argument=this.parseMaybeUnary(null,!0,!1,t),this.finishNode(n,"AwaitExpression")};var sa=pn.prototype;sa.raise=function(t,n){var e=Zi(this.input,t);n+=" ("+e.line+":"+e.column+")";var r=new SyntaxError(n);throw r.pos=t,r.loc=e,r.raisedAt=this.pos,r},sa.raiseRecoverable=sa.raise,sa.curPosition=function(){if(this.options.locations)return new me(this.curLine,this.pos-this.lineStart)};var Nt=pn.prototype,zd=function(t){this.flags=t,this.var=[],this.lexical=[],this.functions=[],this.inClassFieldInit=!1};Nt.enterScope=function(t){this.scopeStack.push(new zd(t))},Nt.exitScope=function(){this.scopeStack.pop()},Nt.treatFunctionsAsVarInScope=function(t){return 2&t.flags||!this.inModule&&1&t.flags},Nt.declareName=function(t,n,e){var r=!1;if(n===2){var a=this.currentScope();r=a.lexical.indexOf(t)>-1||a.functions.indexOf(t)>-1||a.var.indexOf(t)>-1,a.lexical.push(t),this.inModule&&1&a.flags&&delete this.undefinedExports[t]}else if(n===4)this.currentScope().lexical.push(t);else if(n===3){var i=this.currentScope();r=this.treatFunctionsAsVar?i.lexical.indexOf(t)>-1:i.lexical.indexOf(t)>-1||i.var.indexOf(t)>-1,i.functions.push(t)}else for(var s=this.scopeStack.length-1;s>=0;--s){var o=this.scopeStack[s];if(o.lexical.indexOf(t)>-1&&!(32&o.flags&&o.lexical[0]===t)||!this.treatFunctionsAsVarInScope(o)&&o.functions.indexOf(t)>-1){r=!0;break}if(o.var.push(t),this.inModule&&1&o.flags&&delete this.undefinedExports[t],259&o.flags)break}r&&this.raiseRecoverable(e,"Identifier '"+t+"' has already been declared")},Nt.checkLocalExport=function(t){this.scopeStack[0].lexical.indexOf(t.name)===-1&&this.scopeStack[0].var.indexOf(t.name)===-1&&(this.undefinedExports[t.name]=t)},Nt.currentScope=function(){return this.scopeStack[this.scopeStack.length-1]},Nt.currentVarScope=function(){for(var t=this.scopeStack.length-1;;t--){var n=this.scopeStack[t];if(259&n.flags)return n}},Nt.currentThisScope=function(){for(var t=this.scopeStack.length-1;;t--){var n=this.scopeStack[t];if(259&n.flags&&!(16&n.flags))return n}};var nr=function(t,n,e){this.type="",this.start=n,this.end=0,t.options.locations&&(this.loc=new Ze(t,e)),t.options.directSourceFile&&(this.sourceFile=t.options.directSourceFile),t.options.ranges&&(this.range=[n,0])},tr=pn.prototype;function ul(t,n,e,r){return t.type=n,t.end=e,this.options.locations&&(t.loc.end=r),this.options.ranges&&(t.range[1]=e),t}tr.startNode=function(){return new nr(this,this.start,this.startLoc)},tr.startNodeAt=function(t,n){return new nr(this,t,n)},tr.finishNode=function(t,n){return ul.call(this,t,n,this.lastTokEnd,this.lastTokEndLoc)},tr.finishNodeAt=function(t,n,e,r){return ul.call(this,t,n,e,r)},tr.copyNode=function(t){var n=new nr(this,t.start,this.startLoc);for(var e in t)n[e]=t[e];return n};var fl="ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",es=fl+" Extended_Pictographic",rs=es+" EBase EComp EMod EPres ExtPict",Fd={9:fl,10:es,11:es,12:rs,13:rs,14:rs},ml="Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",pl="Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",dl=pl+" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",hl=dl+" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",gl=hl+" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",bl=gl+" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",Bd={9:pl,10:dl,11:hl,12:gl,13:bl,14:bl+" Kawi Nag_Mundari Nagm"},vl={};function Gd(t){var n=vl[t]={binary:Kt(Fd[t]+" "+ml),nonBinary:{General_Category:Kt(ml),Script:Kt(Bd[t])}};n.nonBinary.Script_Extensions=n.nonBinary.Script,n.nonBinary.gc=n.nonBinary.General_Category,n.nonBinary.sc=n.nonBinary.Script,n.nonBinary.scx=n.nonBinary.Script_Extensions}for(var as=0,yl=[9,10,11,12,13,14];as<yl.length;as+=1)Gd(yl[as]);var G=pn.prototype,gt=function(t){this.parser=t,this.validFlags="gim"+(t.options.ecmaVersion>=6?"uy":"")+(t.options.ecmaVersion>=9?"s":"")+(t.options.ecmaVersion>=13?"d":""),this.unicodeProperties=vl[t.options.ecmaVersion>=14?14:t.options.ecmaVersion],this.source="",this.flags="",this.start=0,this.switchU=!1,this.switchN=!1,this.pos=0,this.lastIntValue=0,this.lastStringValue="",this.lastAssertionIsQuantifiable=!1,this.numCapturingParens=0,this.maxBackReference=0,this.groupNames=[],this.backReferenceNames=[]};function xl(t){return t===36||t>=40&&t<=43||t===46||t===63||t>=91&&t<=94||t>=123&&t<=125}function $l(t){return t>=65&&t<=90||t>=97&&t<=122}function El(t){return $l(t)||t===95}function Rd(t){return El(t)||oa(t)}function oa(t){return t>=48&&t<=57}function kl(t){return t>=48&&t<=57||t>=65&&t<=70||t>=97&&t<=102}function wl(t){return t>=65&&t<=70?t-65+10:t>=97&&t<=102?t-97+10:t-48}function Cl(t){return t>=48&&t<=55}gt.prototype.reset=function(t,n,e){var r=e.indexOf("u")!==-1;this.start=0|t,this.source=n+"",this.flags=e,this.switchU=r&&this.parser.options.ecmaVersion>=6,this.switchN=r&&this.parser.options.ecmaVersion>=9},gt.prototype.raise=function(t){this.parser.raiseRecoverable(this.start,"Invalid regular expression: /"+this.source+"/: "+t)},gt.prototype.at=function(t,n){n===void 0&&(n=!1);var e=this.source,r=e.length;if(t>=r)return-1;var a=e.charCodeAt(t);if(!n&&!this.switchU||a<=55295||a>=57344||t+1>=r)return a;var i=e.charCodeAt(t+1);return i>=56320&&i<=57343?(a<<10)+i-56613888:a},gt.prototype.nextIndex=function(t,n){n===void 0&&(n=!1);var e=this.source,r=e.length;if(t>=r)return r;var a,i=e.charCodeAt(t);return!n&&!this.switchU||i<=55295||i>=57344||t+1>=r||(a=e.charCodeAt(t+1))<56320||a>57343?t+1:t+2},gt.prototype.current=function(t){return t===void 0&&(t=!1),this.at(this.pos,t)},gt.prototype.lookahead=function(t){return t===void 0&&(t=!1),this.at(this.nextIndex(this.pos,t),t)},gt.prototype.advance=function(t){t===void 0&&(t=!1),this.pos=this.nextIndex(this.pos,t)},gt.prototype.eat=function(t,n){return n===void 0&&(n=!1),this.current(n)===t&&(this.advance(n),!0)},G.validateRegExpFlags=function(t){for(var n=t.validFlags,e=t.flags,r=0;r<e.length;r++){var a=e.charAt(r);n.indexOf(a)===-1&&this.raise(t.start,"Invalid regular expression flag"),e.indexOf(a,r+1)>-1&&this.raise(t.start,"Duplicate regular expression flag")}},G.validateRegExpPattern=function(t){this.regexp_pattern(t),!t.switchN&&this.options.ecmaVersion>=9&&t.groupNames.length>0&&(t.switchN=!0,this.regexp_pattern(t))},G.regexp_pattern=function(t){t.pos=0,t.lastIntValue=0,t.lastStringValue="",t.lastAssertionIsQuantifiable=!1,t.numCapturingParens=0,t.maxBackReference=0,t.groupNames.length=0,t.backReferenceNames.length=0,this.regexp_disjunction(t),t.pos!==t.source.length&&(t.eat(41)&&t.raise("Unmatched ')'"),(t.eat(93)||t.eat(125))&&t.raise("Lone quantifier brackets")),t.maxBackReference>t.numCapturingParens&&t.raise("Invalid escape");for(var n=0,e=t.backReferenceNames;n<e.length;n+=1){var r=e[n];t.groupNames.indexOf(r)===-1&&t.raise("Invalid named capture referenced")}},G.regexp_disjunction=function(t){for(this.regexp_alternative(t);t.eat(124);)this.regexp_alternative(t);this.regexp_eatQuantifier(t,!0)&&t.raise("Nothing to repeat"),t.eat(123)&&t.raise("Lone quantifier brackets")},G.regexp_alternative=function(t){for(;t.pos<t.source.length&&this.regexp_eatTerm(t););},G.regexp_eatTerm=function(t){return this.regexp_eatAssertion(t)?(t.lastAssertionIsQuantifiable&&this.regexp_eatQuantifier(t)&&t.switchU&&t.raise("Invalid quantifier"),!0):!!(t.switchU?this.regexp_eatAtom(t):this.regexp_eatExtendedAtom(t))&&(this.regexp_eatQuantifier(t),!0)},G.regexp_eatAssertion=function(t){var n=t.pos;if(t.lastAssertionIsQuantifiable=!1,t.eat(94)||t.eat(36))return!0;if(t.eat(92)){if(t.eat(66)||t.eat(98))return!0;t.pos=n}if(t.eat(40)&&t.eat(63)){var e=!1;if(this.options.ecmaVersion>=9&&(e=t.eat(60)),t.eat(61)||t.eat(33))return this.regexp_disjunction(t),t.eat(41)||t.raise("Unterminated group"),t.lastAssertionIsQuantifiable=!e,!0}return t.pos=n,!1},G.regexp_eatQuantifier=function(t,n){return n===void 0&&(n=!1),!!this.regexp_eatQuantifierPrefix(t,n)&&(t.eat(63),!0)},G.regexp_eatQuantifierPrefix=function(t,n){return t.eat(42)||t.eat(43)||t.eat(63)||this.regexp_eatBracedQuantifier(t,n)},G.regexp_eatBracedQuantifier=function(t,n){var e=t.pos;if(t.eat(123)){var r=0,a=-1;if(this.regexp_eatDecimalDigits(t)&&(r=t.lastIntValue,t.eat(44)&&this.regexp_eatDecimalDigits(t)&&(a=t.lastIntValue),t.eat(125)))return a!==-1&&a<r&&!n&&t.raise("numbers out of order in {} quantifier"),!0;t.switchU&&!n&&t.raise("Incomplete quantifier"),t.pos=e}return!1},G.regexp_eatAtom=function(t){return this.regexp_eatPatternCharacters(t)||t.eat(46)||this.regexp_eatReverseSolidusAtomEscape(t)||this.regexp_eatCharacterClass(t)||this.regexp_eatUncapturingGroup(t)||this.regexp_eatCapturingGroup(t)},G.regexp_eatReverseSolidusAtomEscape=function(t){var n=t.pos;if(t.eat(92)){if(this.regexp_eatAtomEscape(t))return!0;t.pos=n}return!1},G.regexp_eatUncapturingGroup=function(t){var n=t.pos;if(t.eat(40)){if(t.eat(63)&&t.eat(58)){if(this.regexp_disjunction(t),t.eat(41))return!0;t.raise("Unterminated group")}t.pos=n}return!1},G.regexp_eatCapturingGroup=function(t){if(t.eat(40)){if(this.options.ecmaVersion>=9?this.regexp_groupSpecifier(t):t.current()===63&&t.raise("Invalid group"),this.regexp_disjunction(t),t.eat(41))return t.numCapturingParens+=1,!0;t.raise("Unterminated group")}return!1},G.regexp_eatExtendedAtom=function(t){return t.eat(46)||this.regexp_eatReverseSolidusAtomEscape(t)||this.regexp_eatCharacterClass(t)||this.regexp_eatUncapturingGroup(t)||this.regexp_eatCapturingGroup(t)||this.regexp_eatInvalidBracedQuantifier(t)||this.regexp_eatExtendedPatternCharacter(t)},G.regexp_eatInvalidBracedQuantifier=function(t){return this.regexp_eatBracedQuantifier(t,!0)&&t.raise("Nothing to repeat"),!1},G.regexp_eatSyntaxCharacter=function(t){var n=t.current();return!!xl(n)&&(t.lastIntValue=n,t.advance(),!0)},G.regexp_eatPatternCharacters=function(t){for(var n=t.pos,e=0;(e=t.current())!==-1&&!xl(e);)t.advance();return t.pos!==n},G.regexp_eatExtendedPatternCharacter=function(t){var n=t.current();return!(n===-1||n===36||n>=40&&n<=43||n===46||n===63||n===91||n===94||n===124)&&(t.advance(),!0)},G.regexp_groupSpecifier=function(t){if(t.eat(63)){if(this.regexp_eatGroupName(t))return t.groupNames.indexOf(t.lastStringValue)!==-1&&t.raise("Duplicate capture group name"),void t.groupNames.push(t.lastStringValue);t.raise("Invalid group")}},G.regexp_eatGroupName=function(t){if(t.lastStringValue="",t.eat(60)){if(this.regexp_eatRegExpIdentifierName(t)&&t.eat(62))return!0;t.raise("Invalid capture group name")}return!1},G.regexp_eatRegExpIdentifierName=function(t){if(t.lastStringValue="",this.regexp_eatRegExpIdentifierStart(t)){for(t.lastStringValue+=It(t.lastIntValue);this.regexp_eatRegExpIdentifierPart(t);)t.lastStringValue+=It(t.lastIntValue);return!0}return!1},G.regexp_eatRegExpIdentifierStart=function(t){var n=t.pos,e=this.options.ecmaVersion>=11,r=t.current(e);return t.advance(e),r===92&&this.regexp_eatRegExpUnicodeEscapeSequence(t,e)&&(r=t.lastIntValue),function(a){return _t(a,!0)||a===36||a===95}(r)?(t.lastIntValue=r,!0):(t.pos=n,!1)},G.regexp_eatRegExpIdentifierPart=function(t){var n=t.pos,e=this.options.ecmaVersion>=11,r=t.current(e);return t.advance(e),r===92&&this.regexp_eatRegExpUnicodeEscapeSequence(t,e)&&(r=t.lastIntValue),function(a){return Wt(a,!0)||a===36||a===95||a===8204||a===8205}(r)?(t.lastIntValue=r,!0):(t.pos=n,!1)},G.regexp_eatAtomEscape=function(t){return!!(this.regexp_eatBackReference(t)||this.regexp_eatCharacterClassEscape(t)||this.regexp_eatCharacterEscape(t)||t.switchN&&this.regexp_eatKGroupName(t))||(t.switchU&&(t.current()===99&&t.raise("Invalid unicode escape"),t.raise("Invalid escape")),!1)},G.regexp_eatBackReference=function(t){var n=t.pos;if(this.regexp_eatDecimalEscape(t)){var e=t.lastIntValue;if(t.switchU)return e>t.maxBackReference&&(t.maxBackReference=e),!0;if(e<=t.numCapturingParens)return!0;t.pos=n}return!1},G.regexp_eatKGroupName=function(t){if(t.eat(107)){if(this.regexp_eatGroupName(t))return t.backReferenceNames.push(t.lastStringValue),!0;t.raise("Invalid named reference")}return!1},G.regexp_eatCharacterEscape=function(t){return this.regexp_eatControlEscape(t)||this.regexp_eatCControlLetter(t)||this.regexp_eatZero(t)||this.regexp_eatHexEscapeSequence(t)||this.regexp_eatRegExpUnicodeEscapeSequence(t,!1)||!t.switchU&&this.regexp_eatLegacyOctalEscapeSequence(t)||this.regexp_eatIdentityEscape(t)},G.regexp_eatCControlLetter=function(t){var n=t.pos;if(t.eat(99)){if(this.regexp_eatControlLetter(t))return!0;t.pos=n}return!1},G.regexp_eatZero=function(t){return t.current()===48&&!oa(t.lookahead())&&(t.lastIntValue=0,t.advance(),!0)},G.regexp_eatControlEscape=function(t){var n=t.current();return n===116?(t.lastIntValue=9,t.advance(),!0):n===110?(t.lastIntValue=10,t.advance(),!0):n===118?(t.lastIntValue=11,t.advance(),!0):n===102?(t.lastIntValue=12,t.advance(),!0):n===114&&(t.lastIntValue=13,t.advance(),!0)},G.regexp_eatControlLetter=function(t){var n=t.current();return!!$l(n)&&(t.lastIntValue=n%32,t.advance(),!0)},G.regexp_eatRegExpUnicodeEscapeSequence=function(t,n){n===void 0&&(n=!1);var e,r=t.pos,a=n||t.switchU;if(t.eat(117)){if(this.regexp_eatFixedHexDigits(t,4)){var i=t.lastIntValue;if(a&&i>=55296&&i<=56319){var s=t.pos;if(t.eat(92)&&t.eat(117)&&this.regexp_eatFixedHexDigits(t,4)){var o=t.lastIntValue;if(o>=56320&&o<=57343)return t.lastIntValue=1024*(i-55296)+(o-56320)+65536,!0}t.pos=s,t.lastIntValue=i}return!0}if(a&&t.eat(123)&&this.regexp_eatHexDigits(t)&&t.eat(125)&&(e=t.lastIntValue)>=0&&e<=1114111)return!0;a&&t.raise("Invalid unicode escape"),t.pos=r}return!1},G.regexp_eatIdentityEscape=function(t){if(t.switchU)return!!this.regexp_eatSyntaxCharacter(t)||!!t.eat(47)&&(t.lastIntValue=47,!0);var n=t.current();return!(n===99||t.switchN&&n===107)&&(t.lastIntValue=n,t.advance(),!0)},G.regexp_eatDecimalEscape=function(t){t.lastIntValue=0;var n=t.current();if(n>=49&&n<=57){do t.lastIntValue=10*t.lastIntValue+(n-48),t.advance();while((n=t.current())>=48&&n<=57);return!0}return!1},G.regexp_eatCharacterClassEscape=function(t){var n=t.current();if(function(e){return e===100||e===68||e===115||e===83||e===119||e===87}(n))return t.lastIntValue=-1,t.advance(),!0;if(t.switchU&&this.options.ecmaVersion>=9&&(n===80||n===112)){if(t.lastIntValue=-1,t.advance(),t.eat(123)&&this.regexp_eatUnicodePropertyValueExpression(t)&&t.eat(125))return!0;t.raise("Invalid property name")}return!1},G.regexp_eatUnicodePropertyValueExpression=function(t){var n=t.pos;if(this.regexp_eatUnicodePropertyName(t)&&t.eat(61)){var e=t.lastStringValue;if(this.regexp_eatUnicodePropertyValue(t)){var r=t.lastStringValue;return this.regexp_validateUnicodePropertyNameAndValue(t,e,r),!0}}if(t.pos=n,this.regexp_eatLoneUnicodePropertyNameOrValue(t)){var a=t.lastStringValue;return this.regexp_validateUnicodePropertyNameOrValue(t,a),!0}return!1},G.regexp_validateUnicodePropertyNameAndValue=function(t,n,e){Ye(t.unicodeProperties.nonBinary,n)||t.raise("Invalid property name"),t.unicodeProperties.nonBinary[n].test(e)||t.raise("Invalid property value")},G.regexp_validateUnicodePropertyNameOrValue=function(t,n){t.unicodeProperties.binary.test(n)||t.raise("Invalid property name")},G.regexp_eatUnicodePropertyName=function(t){var n=0;for(t.lastStringValue="";El(n=t.current());)t.lastStringValue+=It(n),t.advance();return t.lastStringValue!==""},G.regexp_eatUnicodePropertyValue=function(t){var n=0;for(t.lastStringValue="";Rd(n=t.current());)t.lastStringValue+=It(n),t.advance();return t.lastStringValue!==""},G.regexp_eatLoneUnicodePropertyNameOrValue=function(t){return this.regexp_eatUnicodePropertyValue(t)},G.regexp_eatCharacterClass=function(t){if(t.eat(91)){if(t.eat(94),this.regexp_classRanges(t),t.eat(93))return!0;t.raise("Unterminated character class")}return!1},G.regexp_classRanges=function(t){for(;this.regexp_eatClassAtom(t);){var n=t.lastIntValue;if(t.eat(45)&&this.regexp_eatClassAtom(t)){var e=t.lastIntValue;!t.switchU||n!==-1&&e!==-1||t.raise("Invalid character class"),n!==-1&&e!==-1&&n>e&&t.raise("Range out of order in character class")}}},G.regexp_eatClassAtom=function(t){var n=t.pos;if(t.eat(92)){if(this.regexp_eatClassEscape(t))return!0;if(t.switchU){var e=t.current();(e===99||Cl(e))&&t.raise("Invalid class escape"),t.raise("Invalid escape")}t.pos=n}var r=t.current();return r!==93&&(t.lastIntValue=r,t.advance(),!0)},G.regexp_eatClassEscape=function(t){var n=t.pos;if(t.eat(98))return t.lastIntValue=8,!0;if(t.switchU&&t.eat(45))return t.lastIntValue=45,!0;if(!t.switchU&&t.eat(99)){if(this.regexp_eatClassControlLetter(t))return!0;t.pos=n}return this.regexp_eatCharacterClassEscape(t)||this.regexp_eatCharacterEscape(t)},G.regexp_eatClassControlLetter=function(t){var n=t.current();return!(!oa(n)&&n!==95)&&(t.lastIntValue=n%32,t.advance(),!0)},G.regexp_eatHexEscapeSequence=function(t){var n=t.pos;if(t.eat(120)){if(this.regexp_eatFixedHexDigits(t,2))return!0;t.switchU&&t.raise("Invalid escape"),t.pos=n}return!1},G.regexp_eatDecimalDigits=function(t){var n=t.pos,e=0;for(t.lastIntValue=0;oa(e=t.current());)t.lastIntValue=10*t.lastIntValue+(e-48),t.advance();return t.pos!==n},G.regexp_eatHexDigits=function(t){var n=t.pos,e=0;for(t.lastIntValue=0;kl(e=t.current());)t.lastIntValue=16*t.lastIntValue+wl(e),t.advance();return t.pos!==n},G.regexp_eatLegacyOctalEscapeSequence=function(t){if(this.regexp_eatOctalDigit(t)){var n=t.lastIntValue;if(this.regexp_eatOctalDigit(t)){var e=t.lastIntValue;n<=3&&this.regexp_eatOctalDigit(t)?t.lastIntValue=64*n+8*e+t.lastIntValue:t.lastIntValue=8*n+e}else t.lastIntValue=n;return!0}return!1},G.regexp_eatOctalDigit=function(t){var n=t.current();return Cl(n)?(t.lastIntValue=n-48,t.advance(),!0):(t.lastIntValue=0,!1)},G.regexp_eatFixedHexDigits=function(t,n){var e=t.pos;t.lastIntValue=0;for(var r=0;r<n;++r){var a=t.current();if(!kl(a))return t.pos=e,!1;t.lastIntValue=16*t.lastIntValue+wl(a),t.advance()}return!0};var _a=function(t){this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,t.options.locations&&(this.loc=new Ze(t,t.startLoc,t.endLoc)),t.options.ranges&&(this.range=[t.start,t.end])},Y=pn.prototype;function Sl(t){return typeof BigInt!="function"?null:BigInt(t.replace(/_/g,""))}Y.next=function(t){!t&&this.type.keyword&&this.containsEsc&&this.raiseRecoverable(this.start,"Escape sequence in keyword "+this.type.keyword),this.options.onToken&&this.options.onToken(new _a(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},Y.getToken=function(){return this.next(),new _a(this)},typeof Symbol<"u"&&(Y[Symbol.iterator]=function(){var t=this;return{next:function(){var n=t.getToken();return{done:n.type===p.eof,value:n}}}}),Y.nextToken=function(){var t=this.curContext();return t&&t.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(p.eof):t.override?t.override(this):void this.readToken(this.fullCharCodeAtPos())},Y.readToken=function(t){return _t(t,this.options.ecmaVersion>=6)||t===92?this.readWord():this.getTokenFromCode(t)},Y.fullCharCodeAtPos=function(){var t=this.input.charCodeAt(this.pos);if(t<=55295||t>=56320)return t;var n=this.input.charCodeAt(this.pos+1);return n<=56319||n>=57344?t:(t<<10)+n-56613888},Y.skipBlockComment=function(){var t=this.options.onComment&&this.curPosition(),n=this.pos,e=this.input.indexOf("*/",this.pos+=2);if(e===-1&&this.raise(this.pos-2,"Unterminated comment"),this.pos=e+2,this.options.locations)for(var r=void 0,a=n;(r=il(this.input,a,this.pos))>-1;)++this.curLine,a=this.lineStart=r;this.options.onComment&&this.options.onComment(!0,this.input.slice(n+2,e),n,this.pos,t,this.curPosition())},Y.skipLineComment=function(t){for(var n=this.pos,e=this.options.onComment&&this.curPosition(),r=this.input.charCodeAt(this.pos+=t);this.pos<this.input.length&&!Jt(r);)r=this.input.charCodeAt(++this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(n+t,this.pos),n,this.pos,e,this.curPosition())},Y.skipSpace=function(){n:for(;this.pos<this.input.length;){var t=this.input.charCodeAt(this.pos);switch(t){case 32:case 160:++this.pos;break;case 13:this.input.charCodeAt(this.pos+1)===10&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:switch(this.input.charCodeAt(this.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break n}break;default:if(!(t>8&&t<14||t>=5760&&Yi.test(String.fromCharCode(t))))break n;++this.pos}}},Y.finishToken=function(t,n){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var e=this.type;this.type=t,this.value=n,this.updateContext(e)},Y.readToken_dot=function(){var t=this.input.charCodeAt(this.pos+1);if(t>=48&&t<=57)return this.readNumber(!0);var n=this.input.charCodeAt(this.pos+2);return this.options.ecmaVersion>=6&&t===46&&n===46?(this.pos+=3,this.finishToken(p.ellipsis)):(++this.pos,this.finishToken(p.dot))},Y.readToken_slash=function(){var t=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):t===61?this.finishOp(p.assign,2):this.finishOp(p.slash,1)},Y.readToken_mult_modulo_exp=function(t){var n=this.input.charCodeAt(this.pos+1),e=1,r=t===42?p.star:p.modulo;return this.options.ecmaVersion>=7&&t===42&&n===42&&(++e,r=p.starstar,n=this.input.charCodeAt(this.pos+2)),n===61?this.finishOp(p.assign,e+1):this.finishOp(r,e)},Y.readToken_pipe_amp=function(t){var n=this.input.charCodeAt(this.pos+1);return n===t?this.options.ecmaVersion>=12&&this.input.charCodeAt(this.pos+2)===61?this.finishOp(p.assign,3):this.finishOp(t===124?p.logicalOR:p.logicalAND,2):n===61?this.finishOp(p.assign,2):this.finishOp(t===124?p.bitwiseOR:p.bitwiseAND,1)},Y.readToken_caret=function(){return this.input.charCodeAt(this.pos+1)===61?this.finishOp(p.assign,2):this.finishOp(p.bitwiseXOR,1)},Y.readToken_plus_min=function(t){var n=this.input.charCodeAt(this.pos+1);return n===t?n!==45||this.inModule||this.input.charCodeAt(this.pos+2)!==62||this.lastTokEnd!==0&&!Gn.test(this.input.slice(this.lastTokEnd,this.pos))?this.finishOp(p.incDec,2):(this.skipLineComment(3),this.skipSpace(),this.nextToken()):n===61?this.finishOp(p.assign,2):this.finishOp(p.plusMin,1)},Y.readToken_lt_gt=function(t){var n=this.input.charCodeAt(this.pos+1),e=1;return n===t?(e=t===62&&this.input.charCodeAt(this.pos+2)===62?3:2,this.input.charCodeAt(this.pos+e)===61?this.finishOp(p.assign,e+1):this.finishOp(p.bitShift,e)):n!==33||t!==60||this.inModule||this.input.charCodeAt(this.pos+2)!==45||this.input.charCodeAt(this.pos+3)!==45?(n===61&&(e=2),this.finishOp(p.relational,e)):(this.skipLineComment(4),this.skipSpace(),this.nextToken())},Y.readToken_eq_excl=function(t){var n=this.input.charCodeAt(this.pos+1);return n===61?this.finishOp(p.equality,this.input.charCodeAt(this.pos+2)===61?3:2):t===61&&n===62&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(p.arrow)):this.finishOp(t===61?p.eq:p.prefix,1)},Y.readToken_question=function(){var t=this.options.ecmaVersion;if(t>=11){var n=this.input.charCodeAt(this.pos+1);if(n===46){var e=this.input.charCodeAt(this.pos+2);if(e<48||e>57)return this.finishOp(p.questionDot,2)}if(n===63)return t>=12&&this.input.charCodeAt(this.pos+2)===61?this.finishOp(p.assign,3):this.finishOp(p.coalesce,2)}return this.finishOp(p.question,1)},Y.readToken_numberSign=function(){var t=35;if(this.options.ecmaVersion>=13&&(++this.pos,_t(t=this.fullCharCodeAtPos(),!0)||t===92))return this.finishToken(p.privateId,this.readWord1());this.raise(this.pos,"Unexpected character '"+It(t)+"'")},Y.getTokenFromCode=function(t){switch(t){case 46:return this.readToken_dot();case 40:return++this.pos,this.finishToken(p.parenL);case 41:return++this.pos,this.finishToken(p.parenR);case 59:return++this.pos,this.finishToken(p.semi);case 44:return++this.pos,this.finishToken(p.comma);case 91:return++this.pos,this.finishToken(p.bracketL);case 93:return++this.pos,this.finishToken(p.bracketR);case 123:return++this.pos,this.finishToken(p.braceL);case 125:return++this.pos,this.finishToken(p.braceR);case 58:return++this.pos,this.finishToken(p.colon);case 96:if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(p.backQuote);case 48:var n=this.input.charCodeAt(this.pos+1);if(n===120||n===88)return this.readRadixNumber(16);if(this.options.ecmaVersion>=6){if(n===111||n===79)return this.readRadixNumber(8);if(n===98||n===66)return this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.readNumber(!1);case 34:case 39:return this.readString(t);case 47:return this.readToken_slash();case 37:case 42:return this.readToken_mult_modulo_exp(t);case 124:case 38:return this.readToken_pipe_amp(t);case 94:return this.readToken_caret();case 43:case 45:return this.readToken_plus_min(t);case 60:case 62:return this.readToken_lt_gt(t);case 61:case 33:return this.readToken_eq_excl(t);case 63:return this.readToken_question();case 126:return this.finishOp(p.prefix,1);case 35:return this.readToken_numberSign()}this.raise(this.pos,"Unexpected character '"+It(t)+"'")},Y.finishOp=function(t,n){var e=this.input.slice(this.pos,this.pos+n);return this.pos+=n,this.finishToken(t,e)},Y.readRegexp=function(){for(var t,n,e=this.pos;;){this.pos>=this.input.length&&this.raise(e,"Unterminated regular expression");var r=this.input.charAt(this.pos);if(Gn.test(r)&&this.raise(e,"Unterminated regular expression"),t)t=!1;else{if(r==="[")n=!0;else if(r==="]"&&n)n=!1;else if(r==="/"&&!n)break;t=r==="\\"}++this.pos}var a=this.input.slice(e,this.pos);++this.pos;var i=this.pos,s=this.readWord1();this.containsEsc&&this.unexpected(i);var o=this.regexpState||(this.regexpState=new gt(this));o.reset(e,a,s),this.validateRegExpFlags(o),this.validateRegExpPattern(o);var _=null;try{_=new RegExp(a,s)}catch{}return this.finishToken(p.regexp,{pattern:a,flags:s,value:_})},Y.readInt=function(t,n,e){for(var r=this.options.ecmaVersion>=12&&n===void 0,a=e&&this.input.charCodeAt(this.pos)===48,i=this.pos,s=0,o=0,_=0,l=n??1/0;_<l;++_,++this.pos){var u=this.input.charCodeAt(this.pos),f=void 0;if(r&&u===95)a&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed in legacy octal numeric literals"),o===95&&this.raiseRecoverable(this.pos,"Numeric separator must be exactly one underscore"),_===0&&this.raiseRecoverable(this.pos,"Numeric separator is not allowed at the first of digits"),o=u;else{if((f=u>=97?u-97+10:u>=65?u-65+10:u>=48&&u<=57?u-48:1/0)>=t)break;o=u,s=s*t+f}}return r&&o===95&&this.raiseRecoverable(this.pos-1,"Numeric separator is not allowed at the last of digits"),this.pos===i||n!=null&&this.pos-i!==n?null:s},Y.readRadixNumber=function(t){var n=this.pos;this.pos+=2;var e=this.readInt(t);return e==null&&this.raise(this.start+2,"Expected number in radix "+t),this.options.ecmaVersion>=11&&this.input.charCodeAt(this.pos)===110?(e=Sl(this.input.slice(n,this.pos)),++this.pos):_t(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(p.num,e)},Y.readNumber=function(t){var n=this.pos;t||this.readInt(10,void 0,!0)!==null||this.raise(n,"Invalid number");var e=this.pos-n>=2&&this.input.charCodeAt(n)===48;e&&this.strict&&this.raise(n,"Invalid number");var r=this.input.charCodeAt(this.pos);if(!e&&!t&&this.options.ecmaVersion>=11&&r===110){var a=Sl(this.input.slice(n,this.pos));return++this.pos,_t(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(p.num,a)}e&&/[89]/.test(this.input.slice(n,this.pos))&&(e=!1),r!==46||e||(++this.pos,this.readInt(10),r=this.input.charCodeAt(this.pos)),r!==69&&r!==101||e||((r=this.input.charCodeAt(++this.pos))!==43&&r!==45||++this.pos,this.readInt(10)===null&&this.raise(n,"Invalid number")),_t(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var i,s=(i=this.input.slice(n,this.pos),e?parseInt(i,8):parseFloat(i.replace(/_/g,"")));return this.finishToken(p.num,s)},Y.readCodePoint=function(){var t;if(this.input.charCodeAt(this.pos)===123){this.options.ecmaVersion<6&&this.unexpected();var n=++this.pos;t=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,t>1114111&&this.invalidStringToken(n,"Code point out of bounds")}else t=this.readHexChar(4);return t},Y.readString=function(t){for(var n="",e=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var r=this.input.charCodeAt(this.pos);if(r===t)break;r===92?(n+=this.input.slice(e,this.pos),n+=this.readEscapedChar(!1),e=this.pos):r===8232||r===8233?(this.options.ecmaVersion<10&&this.raise(this.start,"Unterminated string constant"),++this.pos,this.options.locations&&(this.curLine++,this.lineStart=this.pos)):(Jt(r)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return n+=this.input.slice(e,this.pos++),this.finishToken(p.string,n)};var Al={};Y.tryReadTemplateToken=function(){this.inTemplateElement=!0;try{this.readTmplToken()}catch(t){if(t!==Al)throw t;this.readInvalidTemplateToken()}this.inTemplateElement=!1},Y.invalidStringToken=function(t,n){if(this.inTemplateElement&&this.options.ecmaVersion>=9)throw Al;this.raise(t,n)},Y.readTmplToken=function(){for(var t="",n=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var e=this.input.charCodeAt(this.pos);if(e===96||e===36&&this.input.charCodeAt(this.pos+1)===123)return this.pos!==this.start||this.type!==p.template&&this.type!==p.invalidTemplate?(t+=this.input.slice(n,this.pos),this.finishToken(p.template,t)):e===36?(this.pos+=2,this.finishToken(p.dollarBraceL)):(++this.pos,this.finishToken(p.backQuote));if(e===92)t+=this.input.slice(n,this.pos),t+=this.readEscapedChar(!0),n=this.pos;else if(Jt(e)){switch(t+=this.input.slice(n,this.pos),++this.pos,e){case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:t+=`
`;break;default:t+=String.fromCharCode(e)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),n=this.pos}else++this.pos}},Y.readInvalidTemplateToken=function(){for(;this.pos<this.input.length;this.pos++)switch(this.input[this.pos]){case"\\":++this.pos;break;case"$":if(this.input[this.pos+1]!=="{")break;case"`":return this.finishToken(p.invalidTemplate,this.input.slice(this.start,this.pos))}this.raise(this.start,"Unterminated template")},Y.readEscapedChar=function(t){var n=this.input.charCodeAt(++this.pos);switch(++this.pos,n){case 110:return`
`;case 114:return"\r";case 120:return String.fromCharCode(this.readHexChar(2));case 117:return It(this.readCodePoint());case 116:return"	";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 13:this.input.charCodeAt(this.pos)===10&&++this.pos;case 10:return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";case 56:case 57:if(this.strict&&this.invalidStringToken(this.pos-1,"Invalid escape sequence"),t){var e=this.pos-1;this.invalidStringToken(e,"Invalid escape sequence in template string")}default:if(n>=48&&n<=55){var r=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],a=parseInt(r,8);return a>255&&(r=r.slice(0,-1),a=parseInt(r,8)),this.pos+=r.length-1,n=this.input.charCodeAt(this.pos),r==="0"&&n!==56&&n!==57||!this.strict&&!t||this.invalidStringToken(this.pos-1-r.length,t?"Octal literal in template string":"Octal literal in strict mode"),String.fromCharCode(a)}return Jt(n)?"":String.fromCharCode(n)}},Y.readHexChar=function(t){var n=this.pos,e=this.readInt(16,t);return e===null&&this.invalidStringToken(n,"Bad character escape sequence"),e},Y.readWord1=function(){this.containsEsc=!1;for(var t="",n=!0,e=this.pos,r=this.options.ecmaVersion>=6;this.pos<this.input.length;){var a=this.fullCharCodeAtPos();if(Wt(a,r))this.pos+=a<=65535?1:2;else{if(a!==92)break;this.containsEsc=!0,t+=this.input.slice(e,this.pos);var i=this.pos;this.input.charCodeAt(++this.pos)!==117&&this.invalidStringToken(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var s=this.readCodePoint();(n?_t:Wt)(s,r)||this.invalidStringToken(i,"Invalid Unicode escape"),t+=It(s),e=this.pos}n=!1}return t+this.input.slice(e,this.pos)},Y.readWord=function(){var t=this.readWord1(),n=p.name;return this.keywords.test(t)&&(n=ea[t]),this.finishToken(n,t)};var Il="8.8.2";pn.acorn={Parser:pn,version:Il,defaultOptions:ra,Position:me,SourceLocation:Ze,getLineInfo:Zi,Node:nr,TokenType:Q,tokTypes:p,keywordTypes:ea,TokContext:Wn,tokContexts:un,isIdentifierChar:Wt,isIdentifierStart:_t,Token:_a,isNewLine:Jt,lineBreak:Gn,lineBreakG:al,nonASCIIwhitespace:Yi};var qd=Object.freeze({__proto__:null,Node:nr,Parser:pn,Position:me,SourceLocation:Ze,TokContext:Wn,Token:_a,TokenType:Q,defaultOptions:ra,getLineInfo:Zi,isIdentifierChar:Wt,isIdentifierStart:_t,isNewLine:Jt,keywordTypes:ea,lineBreak:Gn,lineBreakG:al,nonASCIIwhitespace:Yi,parse:function(t,n){return pn.parse(t,n)},parseExpressionAt:function(t,n,e){return pn.parseExpressionAt(t,n,e)},tokContexts:un,tokTypes:p,tokenizer:function(t,n){return pn.tokenizer(t,n)},version:Il});const la=t=>()=>L(function(n){return{code:"NO_FS_IN_BROWSER",message:`Cannot access the file system (via "${n}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`,url:wn("plugin-development/#a-simple-example")}}(t)),Vd=la("fs.mkdir"),Xd=la("fs.readFile"),Ud=la("fs.writeFile");async function Nl(t,n,e,r,a,i,s,o,_){const l=await function(u,f,m,h,v,d,g,y){let E=null,b=null;if(v){E=new Set;for(const x of v)u===x.source&&f===x.importer&&E.add(x.plugin);b=(x,$)=>({...x,resolve:(S,A,{assertions:N,custom:k,isEntry:I,skipSelf:R}=In)=>h(S,A,k,I,N||Fn,R?[...v,{importer:A,plugin:$,source:S}]:v)})}return m.hookFirstAndGetPlugin("resolveId",[u,f,{assertions:y,custom:d,isEntry:g}],b,E)}(t,n,r,a,i,s,o,_);return l==null?la("path.resolve")():l[0]}const is="at position ",ss="at output position ",Hd={delete:()=>!1,get(){},has:()=>!1,set(){}};function ca(t){return t.startsWith(is)||t.startsWith(ss)?L({code:im,message:"A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."}):L({code:um,message:`The plugin name ${t} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`})}const Tl=(t,n,e=Jd)=>{const{onwarn:r,onLog:a}=t,i=Wd(e,r);if(a){const s=zt[n];return(o,_)=>a(o,jl(_),(l,u)=>{if(l==="error")return L(ct(u));zt[l]>=s&&i(l,ct(u))})}return i},Wd=(t,n)=>n?(e,r)=>{e===V?n(jl(r),a=>t(V,ct(a))):t(e,r)}:t,jl=t=>(Object.defineProperty(t,"toString",{value:()=>Ll(t),writable:!0}),t),ct=t=>typeof t=="string"?{message:t}:typeof t=="function"?ct(t()):t,Ll=t=>{let n="";return t.plugin&&(n+=`(${t.plugin} plugin) `),t.loc&&(n+=`${H(t.loc.file)} (${t.loc.line}:${t.loc.column}) `),n+t.message},Jd=(t,n)=>{const e=Ll(n);switch(t){case V:return console.warn(e);case we:return console.debug(e);default:return console.info(e)}};function Ml(t,n,e,r,a=/$./){const i=new Set(n),s=Object.keys(t).filter(o=>!(i.has(o)||a.test(o)));s.length>0&&r(V,function(o,_,l){return{code:Cm,message:`Unknown ${o}: ${_.join(", ")}. Allowed options: ${l.join(", ")}`}}(e,s,[...i].sort()))}const Kd={recommended:{annotations:!0,correctVarValueBeforeDeclaration:!1,manualPureFunctions:bn,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!1},safest:{annotations:!0,correctVarValueBeforeDeclaration:!0,manualPureFunctions:bn,moduleSideEffects:()=>!0,propertyReadSideEffects:!0,tryCatchDeoptimization:!0,unknownGlobalSideEffects:!0},smallest:{annotations:!0,correctVarValueBeforeDeclaration:!1,manualPureFunctions:bn,moduleSideEffects:()=>!1,propertyReadSideEffects:!1,tryCatchDeoptimization:!1,unknownGlobalSideEffects:!1}},Yd={es2015:{arrowFunctions:!0,constBindings:!0,objectShorthand:!0,reservedNamesAsProps:!0,symbols:!0},es5:{arrowFunctions:!1,constBindings:!1,objectShorthand:!1,reservedNamesAsProps:!0,symbols:!1}},Dl=(t,n,e,r,a)=>{const i=t==null?void 0:t.preset;if(i){const s=n[i];if(s)return{...s,...t};L(vn(`${e}.preset`,r,`valid values are ${mt(Object.keys(n))}`,i))}return((s,o,_,l)=>u=>{if(typeof u=="string"){const f=s[u];if(f)return f;L(vn(o,_,`valid values are ${l}${mt(Object.keys(s))}. You can also supply an object for more fine-grained control`,u))}return(f=>f&&typeof f=="object"?f:{})(u)})(n,e,r,a)(t)},ua=async t=>(await async function(n){do n=(await Promise.all(n)).flat(1/0);while(n.some(e=>e==null?void 0:e.then));return n}([t])).filter(Boolean);async function Zd(t,n,e,r){const a=n.id,i=[];let s=t.map===null?null:Hi(t.map);const o=t.code;let _=t.ast;const l=[],u=[];let f=!1;const m=()=>f=!0;let h="";const v=t.code,d=y=>(E,b)=>{E=ct(E),b&&yr(E,b,v,a),E.id=a,E.hook="transform",y(E)};let g;try{g=await e.hookReduceArg0("transform",[v,a],function(y,E,b){let x,$;if(typeof E=="string")x=E;else{if(!E||typeof E!="object")return y;if(n.updateOptions(E),E.code==null)return(E.map||E.ast)&&r(V,function(S){return{code:Em,message:`The plugin "${S}" returned a "map" or "ast" without returning a "code". This will be ignored.`}}(b.name)),y;({code:x,map:$,ast:_}=E)}return $!==null&&i.push(Hi(typeof $=="string"?JSON.parse($):$)||{missing:!0,plugin:b.name}),x},(y,E)=>{return h=E.name,{...y,addWatchFile($){l.push($),y.addWatchFile($)},cache:f?y.cache:(b=y.cache,x=m,{delete:$=>(x(),b.delete($)),get:$=>(x(),b.get($)),has:$=>(x(),b.has($)),set:($,S)=>(x(),b.set($,S))}),debug:d(y.debug),emitFile:$=>(u.push($),e.emitFile($)),error:($,S)=>(typeof $=="string"&&($={message:$}),S&&yr($,S,v,a),$.id=a,$.hook="transform",y.error($)),getCombinedSourcemap(){const $=function(S,A,N,k,I){return k.length===0?N:{version:3,...q_(S,A,N,k,R_(I)).traceMappings()}}(a,o,s,i,r);return $?(s!==$&&(s=$,i.length=0),new mr({...$,file:null,sourcesContent:$.sourcesContent})):new Lt(o).generateMap({hires:!0,includeContent:!0,source:a})},info:d(y.info),setAssetSource(){return this.error({code:gm,message:"setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook."})},warn:d(y.warn)};var b,x})}catch(y){return L(Se(y,h,{hook:"transform",id:a}))}return!f&&u.length>0&&(n.transformFiles=u),{ast:_,code:g,customTransformCache:f,originalCode:o,originalSourcemap:s,sourcemapChain:i,transformDependencies:l}}const os="resolveDependencies";class Qd{constructor(n,e,r,a){this.graph=n,this.modulesById=e,this.options=r,this.pluginDriver=a,this.implicitEntryModules=new Set,this.indexedEntryModules=[],this.latestLoadModulesPromise=Promise.resolve(),this.moduleLoadPromises=new Map,this.modulesWithLoadedDependencies=new Set,this.nextChunkNamePriority=0,this.nextEntryModuleIndex=0,this.resolveId=async(i,s,o,_,l,u=null)=>this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(i,s,!1)&&await Nl(i,s,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,u,o,typeof _=="boolean"?_:!s,l),s,i),l),this.hasModuleSideEffects=r.treeshake?r.treeshake.moduleSideEffects:()=>!0}async addAdditionalModules(n){const e=this.extendLoadModulesPromise(Promise.all(n.map(r=>this.loadEntryModule(r,!1,void 0,null))));return await this.awaitLoadModulesPromise(),e}async addEntryModules(n,e){const r=this.nextEntryModuleIndex;this.nextEntryModuleIndex+=n.length;const a=this.nextChunkNamePriority;this.nextChunkNamePriority+=n.length;const i=await this.extendLoadModulesPromise(Promise.all(n.map(({id:s,importer:o})=>this.loadEntryModule(s,!0,o,null))).then(s=>{for(const[o,_]of s.entries()){_.isUserDefinedEntryPoint=_.isUserDefinedEntryPoint||e,Ol(_,n[o],e,a+o);const l=this.indexedEntryModules.find(u=>u.module===_);l?l.index=Math.min(l.index,r+o):this.indexedEntryModules.push({index:r+o,module:_})}return this.indexedEntryModules.sort(({index:o},{index:_})=>o>_?1:-1),s}));return await this.awaitLoadModulesPromise(),{entryModules:this.indexedEntryModules.map(({module:s})=>s),implicitEntryModules:[...this.implicitEntryModules],newEntryModules:i}}async emitChunk({fileName:n,id:e,importer:r,name:a,implicitlyLoadedAfterOneOf:i,preserveSignature:s}){const o={fileName:n||null,id:e,importer:r,name:a||null},_=i?await this.addEntryWithImplicitDependants(o,i):(await this.addEntryModules([o],!1)).newEntryModules[0];return s!=null&&(_.preserveSignature=s),_}async preloadModule(n){return(await this.fetchModule(this.getResolvedIdWithDefaults(n,Fn),void 0,!1,!n.resolveDependencies||os)).info}addEntryWithImplicitDependants(n,e){const r=this.nextChunkNamePriority++;return this.extendLoadModulesPromise(this.loadEntryModule(n.id,!1,n.importer,null).then(async a=>{if(Ol(a,n,!1,r),!a.info.isEntry){this.implicitEntryModules.add(a);const i=await Promise.all(e.map(s=>this.loadEntryModule(s,!1,n.importer,a.id)));for(const s of i)a.implicitlyLoadedAfter.add(s);for(const s of a.implicitlyLoadedAfter)s.implicitlyLoadedBefore.add(a)}return a}))}async addModuleSource(n,e,r){let a;try{a=await this.graph.fileOperationQueue.run(async()=>await this.pluginDriver.hookFirst("load",[n])??await Xd(n,"utf8"))}catch(o){let _=`Could not load ${n}`;throw e&&(_+=` (imported by ${H(e)})`),_+=`: ${o.message}`,o.message=_,o}const i=typeof a=="string"?{code:a}:a!=null&&typeof a=="object"&&typeof a.code=="string"?a:L(function(o){return{code:"BAD_LOADER",message:`Error loading "${H(o)}": plugin load hook should return a string, a { code, map } object, or nothing/null.`}}(n)),s=this.graph.cachedModules.get(n);if(!s||s.customTransformCache||s.originalCode!==i.code||await this.pluginDriver.hookFirst("shouldTransformCachedModule",[{ast:s.ast,code:s.code,id:s.id,meta:s.meta,moduleSideEffects:s.moduleSideEffects,resolvedSources:s.resolvedIds,syntheticNamedExports:s.syntheticNamedExports}]))r.updateOptions(i),r.setSource(await Zd(i,r,this.pluginDriver,this.options.onLog));else{if(s.transformFiles)for(const o of s.transformFiles)this.pluginDriver.emitFile(o);r.setSource(s)}}async awaitLoadModulesPromise(){let n;do n=this.latestLoadModulesPromise,await n;while(n!==this.latestLoadModulesPromise)}extendLoadModulesPromise(n){return this.latestLoadModulesPromise=Promise.all([n,this.latestLoadModulesPromise]),this.latestLoadModulesPromise.catch(()=>{}),n}async fetchDynamicDependencies(n,e){const r=await Promise.all(e.map(a=>a.then(async([i,s])=>s===null?null:typeof s=="string"?(i.resolution=s,null):i.resolution=await this.fetchResolvedDependency(H(s.id),n.id,s))));for(const a of r)a&&(n.dynamicDependencies.add(a),a.dynamicImporters.push(n.id))}async fetchModule({assertions:n,id:e,meta:r,moduleSideEffects:a,syntheticNamedExports:i},s,o,_){const l=this.modulesById.get(e);if(l instanceof hn)return s&&Ur(n,l.info.assertions)&&this.options.onLog(V,xr(l.info.assertions,n,e,s)),await this.handleExistingModule(l,o,_),l;const u=new hn(this.graph,e,this.options,o,a,i,r,n);this.modulesById.set(e,u),this.graph.watchFiles[e]=!0;const f=this.addModuleSource(e,s,u).then(()=>[this.getResolveStaticDependencyPromises(u),this.getResolveDynamicImportPromises(u),m]),m=zl(f).then(()=>this.pluginDriver.hookParallel("moduleParsed",[u.info]));m.catch(()=>{}),this.moduleLoadPromises.set(u,f);const h=await f;return _?_===os&&await m:await this.fetchModuleDependencies(u,...h),u}async fetchModuleDependencies(n,e,r,a){this.modulesWithLoadedDependencies.has(n)||(this.modulesWithLoadedDependencies.add(n),await Promise.all([this.fetchStaticDependencies(n,e),this.fetchDynamicDependencies(n,r)]),n.linkImports(),await a)}fetchResolvedDependency(n,e,r){if(r.external){const{assertions:a,external:i,id:s,moduleSideEffects:o,meta:_}=r;let l=this.modulesById.get(s);if(l){if(!(l instanceof fn))return L(function(u,f){return{code:"INVALID_EXTERNAL_ID",message:`"${u}" is imported as an external by "${H(f)}", but is already an existing non-external module id.`}}(n,e));Ur(l.info.assertions,a)&&this.options.onLog(V,xr(l.info.assertions,a,n,e))}else l=new fn(this.options,s,o,_,i!=="absolute"&&vt(s),a),this.modulesById.set(s,l);return Promise.resolve(l)}return this.fetchModule(r,e,!1,!1)}async fetchStaticDependencies(n,e){for(const r of await Promise.all(e.map(a=>a.then(([i,s])=>this.fetchResolvedDependency(i,n.id,s)))))n.dependencies.add(r),r.importers.push(n.id);if(!this.options.treeshake||n.info.moduleSideEffects==="no-treeshake")for(const r of n.dependencies)r instanceof hn&&(r.importedFromNotTreeshaken=!0)}getNormalizedResolvedIdWithoutDefaults(n,e,r){const{makeAbsoluteExternalsRelative:a}=this.options;if(n){if(typeof n=="object"){const o=n.external||this.options.external(n.id,e,!0);return{...n,external:o&&(o==="relative"||!vt(n.id)||o===!0&&_s(n.id,r,a)||"absolute")}}const s=this.options.external(n,e,!0);return{external:s&&(_s(n,r,a)||"absolute"),id:s&&a?Pl(n,e):n}}const i=a?Pl(r,e):r;return n===!1||this.options.external(i,e,!0)?{external:_s(i,r,a)||"absolute",id:i}:null}getResolveDynamicImportPromises(n){return n.dynamicImports.map(async e=>{const r=await this.resolveDynamicImport(n,typeof e.argument=="string"?e.argument:e.argument.esTreeNode,n.id,function(a){var o,_,l;const i=(l=(_=(o=a.arguments)==null?void 0:o[0])==null?void 0:_.properties.find(u=>Mi(u)==="assert"))==null?void 0:l.value;if(!i)return Fn;const s=i.properties.map(u=>{const f=Mi(u);return typeof f=="string"&&typeof u.value.value=="string"?[f,u.value.value]:null}).filter(u=>!!u);return s.length>0?Object.fromEntries(s):Fn}(e.node));return r&&typeof r=="object"&&(e.id=r.id),[e,r]})}getResolveStaticDependencyPromises(n){return Array.from(n.sourcesWithAssertions,async([e,r])=>[e,n.resolvedIds[e]=n.resolvedIds[e]||this.handleInvalidResolvedId(await this.resolveId(e,n.id,Fn,!1,r),e,n.id,r)])}getResolvedIdWithDefaults(n,e){if(!n)return null;const r=n.external||!1;return{assertions:n.assertions||e,external:r,id:n.id,meta:n.meta||{},moduleSideEffects:n.moduleSideEffects??this.hasModuleSideEffects(n.id,!!r),resolvedBy:n.resolvedBy??"rollup",syntheticNamedExports:n.syntheticNamedExports??!1}}async handleExistingModule(n,e,r){const a=this.moduleLoadPromises.get(n);if(r)return r===os?zl(a):a;if(e){n.info.isEntry=!0,this.implicitEntryModules.delete(n);for(const i of n.implicitlyLoadedAfter)i.implicitlyLoadedBefore.delete(n);n.implicitlyLoadedAfter.clear()}return this.fetchModuleDependencies(n,...await a)}handleInvalidResolvedId(n,e,r,a){return n===null?ja(e)?L(function(i,s){return{code:Ks,exporter:i,id:s,message:`Could not resolve "${i}" from "${H(s)}"`}}(e,r)):(this.options.onLog(V,function(i,s){return{code:Ks,exporter:i,id:s,message:`"${i}" is imported by "${H(s)}", but could not be resolved – treating it as an external dependency.`,url:wn("troubleshooting/#warning-treating-module-as-external-dependency")}}(e,r)),{assertions:a,external:!0,id:e,meta:{},moduleSideEffects:this.hasModuleSideEffects(e,!0),resolvedBy:"rollup",syntheticNamedExports:!1}):(n.external&&n.syntheticNamedExports&&this.options.onLog(V,function(i,s){return{code:"EXTERNAL_SYNTHETIC_EXPORTS",exporter:i,message:`External "${i}" cannot have "syntheticNamedExports" enabled (imported by "${H(s)}").`}}(e,r)),n)}async loadEntryModule(n,e,r,a){const i=await Nl(n,r,this.options.preserveSymlinks,this.pluginDriver,this.resolveId,null,Fn,!0,Fn);return i==null?L(a===null?function(s){return{code:Js,message:`Could not resolve entry module "${H(s)}".`}}(n):function(s,o){return{code:Ua,message:`Module "${H(s)}" that should be implicitly loaded before "${H(o)}" could not be resolved.`}}(n,a)):i===!1||typeof i=="object"&&i.external?L(a===null?function(s){return{code:Js,message:`Entry module "${H(s)}" cannot be external.`}}(n):function(s,o){return{code:Ua,message:`Module "${H(s)}" that should be implicitly loaded before "${H(o)}" cannot be external.`}}(n,a)):this.fetchModule(this.getResolvedIdWithDefaults(typeof i=="object"?i:{id:i},Fn),void 0,e,!1)}async resolveDynamicImport(n,e,r,a){const i=await this.pluginDriver.hookFirst("resolveDynamicImport",[e,r,{assertions:a}]);if(typeof e!="string")return typeof i=="string"?i:i?this.getResolvedIdWithDefaults(i,a):null;if(i==null){const s=n.resolvedIds[e];return s?(Ur(s.assertions,a)&&this.options.onLog(V,xr(s.assertions,a,e,r)),s):n.resolvedIds[e]=this.handleInvalidResolvedId(await this.resolveId(e,n.id,Fn,!1,a),e,n.id,a)}return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(i,r,e),a),e,r,a)}}function Pl(t,n){return ja(t)?n?Jn(n,"..",t):Jn(t):t}function Ol(t,{fileName:n,name:e},r,a){var i;if(n!==null)t.chunkFileNames.add(n);else if(e!==null){let s=0;for(;((i=t.chunkNames[s])==null?void 0:i.priority)<a;)s++;t.chunkNames.splice(s,0,{isUserDefined:r,name:e,priority:a})}}function _s(t,n,e){return e===!0||e==="ifRelativeSource"&&ja(n)||!vt(t)}async function zl(t){const[n,e]=await t;return Promise.all([...n,...e])}class nh extends Co{constructor(){super(),this.parent=null,this.variables.set("undefined",new f_)}findVariable(n){let e=this.variables.get(n);return e||(e=new li(n),this.variables.set(n,e)),e}}function Fl(t){return Ke().update(t).digest("hex")}function Bl(t,n,e,r,a){const i=r.sanitizeFileName(t||"asset");return L_(j_(typeof r.assetFileNames=="function"?r.assetFileNames({name:t,source:n,type:"asset"}):r.assetFileNames,"output.assetFileNames",{ext:()=>yt(i).slice(1),extname:()=>yt(i),hash:s=>e.slice(0,Math.max(0,s||8)),name:()=>i.slice(0,Math.max(0,i.length-yt(i).length))}),a)}function Gl(t,{bundle:n},e){n[Zr].has(t.toLowerCase())?e(V,function(r){return{code:fm,message:`The emitted file "${r}" overwrites a previously emitted file of the same name.`}}(t)):n[t]=qi}const th=new Set(["chunk","asset","prebuilt-chunk"]);function Rl(t,n,e){if(!(typeof t=="string"||t instanceof Uint8Array)){const r=n.fileName||n.name||e;return L(Mn(`Could not set source for ${typeof r=="string"?`asset "${r}"`:"unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`))}return t}function eh(t,n){return typeof t.fileName!="string"?L((e=t.name||n,{code:sm,message:`Plugin error - Unable to get file name for asset "${e}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`})):t.fileName;var e}function rh(t,n){return t.fileName?t.fileName:n?n.get(t.module).getFileName():L((e=t.fileName||t.name,{code:_m,message:`Plugin error - Unable to get file name for emitted chunk "${e}". You can only get file names once chunks have been generated after the "renderStart" hook.`}));var e}class ah{constructor(n,e,r){this.graph=n,this.options=e,this.facadeChunkByModule=null,this.nextIdBase=1,this.output=null,this.outputFileEmitters=[],this.emitFile=a=>function(i){return!!(i&&th.has(i.type))}(a)?a.type==="prebuilt-chunk"?this.emitPrebuiltChunk(a):function(i){const s=i.fileName||i.name;return!s||typeof s=="string"&&!dr(s)}(a)?a.type==="chunk"?this.emitChunk(a):this.emitAsset(a):L(Mn(`The "fileName" or "name" properties of emitted chunks and assets must be strings that are neither absolute nor relative paths, received "${a.fileName||a.name}".`)):L(Mn(`Emitted files must be of type "asset", "chunk" or "prebuilt-chunk", received "${a&&a.type}".`)),this.finaliseAssets=()=>{for(const[a,i]of this.filesByReferenceId)if(i.type==="asset"&&typeof i.fileName!="string")return L({code:"ASSET_SOURCE_MISSING",message:`Plugin error creating asset "${i.name||a}" - no asset source set.`})},this.getFileName=a=>{const i=this.filesByReferenceId.get(a);return i?i.type==="chunk"?rh(i,this.facadeChunkByModule):i.type==="prebuilt-chunk"?i.fileName:eh(i,a):L({code:"FILE_NOT_FOUND",message:`Plugin error - Unable to get file name for unknown file "${a}".`})},this.setAssetSource=(a,i)=>{const s=this.filesByReferenceId.get(a);if(!s)return L({code:"ASSET_NOT_FOUND",message:`Plugin error - Unable to set the source for unknown asset "${a}".`});if(s.type!=="asset")return L(Mn(`Asset sources can only be set for emitted assets but "${a}" is an emitted chunk.`));if(s.source!==void 0)return L({code:"ASSET_SOURCE_ALREADY_SET",message:`Unable to set the source for asset "${s.name||a}", source already set.`});const o=Rl(i,s,a);if(this.output)this.finalizeAdditionalAsset(s,o,this.output);else{s.source=o;for(const _ of this.outputFileEmitters)_.finalizeAdditionalAsset(s,o,_.output)}},this.setChunkInformation=a=>{this.facadeChunkByModule=a},this.setOutputBundle=(a,i)=>{const s=this.output={bundle:a,fileNamesBySource:new Map,outputOptions:i};for(const _ of this.filesByReferenceId.values())_.fileName&&Gl(_.fileName,s,this.options.onLog);const o=new Map;for(const _ of this.filesByReferenceId.values())_.type==="asset"&&_.source!==void 0?_.fileName?this.finalizeAdditionalAsset(_,_.source,s):zn(o,Fl(_.source),()=>[]).push(_):_.type==="prebuilt-chunk"&&(this.output.bundle[_.fileName]=this.createPrebuiltChunk(_));for(const[_,l]of o)this.finalizeAssetsWithSameSource(l,_,s)},this.filesByReferenceId=r?new Map(r.filesByReferenceId):new Map,r==null||r.addOutputFileEmitter(this)}addOutputFileEmitter(n){this.outputFileEmitters.push(n)}assignReferenceId(n,e){let r=e;do r=Ke().update(r).digest("hex").slice(0,8);while(this.filesByReferenceId.has(r)||this.outputFileEmitters.some(({filesByReferenceId:a})=>a.has(r)));n.referenceId=r,this.filesByReferenceId.set(r,n);for(const{filesByReferenceId:a}of this.outputFileEmitters)a.set(r,n);return r}createPrebuiltChunk(n){return{code:n.code,dynamicImports:[],exports:n.exports||[],facadeModuleId:null,fileName:n.fileName,implicitlyLoadedBefore:[],importedBindings:{},imports:[],isDynamicEntry:!1,isEntry:!1,isImplicitEntry:!1,map:n.map||null,moduleIds:[],modules:{},name:n.fileName,referencedFiles:[],type:"chunk"}}emitAsset(n){const e=n.source===void 0?void 0:Rl(n.source,n,null),r={fileName:n.fileName,name:n.name,needsCodeReference:!!n.needsCodeReference,referenceId:"",source:e,type:"asset"},a=this.assignReferenceId(r,n.fileName||n.name||String(this.nextIdBase++));if(this.output)this.emitAssetWithReferenceId(r,this.output);else for(const i of this.outputFileEmitters)i.emitAssetWithReferenceId(r,i.output);return a}emitAssetWithReferenceId(n,e){const{fileName:r,source:a}=n;r&&Gl(r,e,this.options.onLog),a!==void 0&&this.finalizeAdditionalAsset(n,a,e)}emitChunk(n){if(this.graph.phase>St.LOAD_AND_PARSE)return L({code:Xs,message:"Cannot emit chunks after module loading has finished."});if(typeof n.id!="string")return L(Mn(`Emitted chunks need to have a valid string id, received "${n.id}"`));const e={fileName:n.fileName,module:null,name:n.name||n.id,referenceId:"",type:"chunk"};return this.graph.moduleLoader.emitChunk(n).then(r=>e.module=r).catch(()=>{}),this.assignReferenceId(e,n.id)}emitPrebuiltChunk(n){if(typeof n.code!="string")return L(Mn(`Emitted prebuilt chunks need to have a valid string code, received "${n.code}".`));if(typeof n.fileName!="string"||dr(n.fileName))return L(Mn(`The "fileName" property of emitted prebuilt chunks must be strings that are neither absolute nor relative paths, received "${n.fileName}".`));const e={code:n.code,exports:n.exports,fileName:n.fileName,map:n.map,referenceId:"",type:"prebuilt-chunk"},r=this.assignReferenceId(e,e.fileName);return this.output&&(this.output.bundle[e.fileName]=this.createPrebuiltChunk(e)),r}finalizeAdditionalAsset(n,e,{bundle:r,fileNamesBySource:a,outputOptions:i}){let{fileName:s,needsCodeReference:o,referenceId:_}=n;if(!s){const f=Fl(e);s=a.get(f),s||(s=Bl(n.name,e,f,i,r),a.set(f,s))}const l={...n,fileName:s,source:e};this.filesByReferenceId.set(_,l);const u=r[s];(u==null?void 0:u.type)==="asset"?u.needsCodeReference&&(u.needsCodeReference=o):r[s]={fileName:s,name:n.name,needsCodeReference:o,source:e,type:"asset"}}finalizeAssetsWithSameSource(n,e,{bundle:r,fileNamesBySource:a,outputOptions:i}){let s,o="",_=!0;for(const l of n){_&&(_=l.needsCodeReference);const u=Bl(l.name,l.source,e,i,r);(!o||u.length<o.length||u.length===o.length&&u<o)&&(o=u,s=l)}a.set(e,o);for(const l of n){const u={...l,fileName:o};this.filesByReferenceId.set(l.referenceId,u)}r[o]={fileName:o,name:s.name,needsCodeReference:_,source:s.source,type:"asset"}}}function de(t,n,e,r,a){return zt[t]<zt[a]?rt:(i,s)=>{s!=null&&e(V,{code:dm,message:`Plugin "${r}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.`}),(i=ct(i)).code&&!i.pluginCode&&(i.pluginCode=i.code),i.code=n,i.plugin=r,e(t,i)}}function ih(t,n,e,r,a,i){const{logLevel:s,onLog:o}=r;let _,l=!0;if(typeof t.cacheKey!="string"&&(t.name.startsWith(is)||t.name.startsWith(ss)||i.has(t.name)?l=!1:i.add(t.name)),n)if(l){const m=t.cacheKey||t.name;f=n[m]||(n[m]=Object.create(null)),_={delete:h=>delete f[h],get(h){const v=f[h];if(v)return v[0]=0,v[1]},has(h){const v=f[h];return!!v&&(v[0]=0,!0)},set(h,v){f[h]=[0,v]}}}else u=t.name,_={delete:()=>ca(u),get:()=>ca(u),has:()=>ca(u),set:()=>ca(u)};else _=Hd;var u,f;return{addWatchFile(m){if(e.phase>=St.GENERATE)return this.error({code:Xs,message:'Cannot call "addWatchFile" after the build has finished.'});e.watchFiles[m]=!0},cache:_,debug:de(we,"PLUGIN_LOG",o,t.name,s),emitFile:a.emitFile.bind(a),error:m=>L(Se(ct(m),t.name)),getFileName:a.getFileName,getModuleIds:()=>e.modulesById.keys(),getModuleInfo:e.getModuleInfo,getWatchFiles:()=>Object.keys(e.watchFiles),info:de(Ot,"PLUGIN_LOG",o,t.name,s),load:m=>e.moduleLoader.preloadModule(m),meta:{rollupVersion:Na,watchMode:e.watchMode},get moduleIds(){const m=e.modulesById.keys();return function*(){Ft(`Accessing "this.moduleIds" on the plugin context by plugin ${t.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,"plugin-development/#this-getmoduleids",!0,r,t.name),yield*m}()},parse:e.contextParse.bind(e),resolve:(m,h,{assertions:v,custom:d,isEntry:g,skipSelf:y}=In)=>e.moduleLoader.resolveId(m,h,d,g,v||Fn,y?[{importer:h,plugin:t,source:m}]:null),setAssetSource:a.setAssetSource,warn:de(V,"PLUGIN_WARNING",o,t.name,s)}}const sh=Object.keys({buildEnd:1,buildStart:1,closeBundle:1,closeWatcher:1,load:1,moduleParsed:1,onLog:1,options:1,resolveDynamicImport:1,resolveId:1,shouldTransformCachedModule:1,transform:1,watchChange:1});class ls{constructor(n,e,r,a,i){this.graph=n,this.options=e,this.pluginCache=a,this.sortedPlugins=new Map,this.unfulfilledActions=new Set,this.fileEmitter=new ah(n,e,i&&i.fileEmitter),this.emitFile=this.fileEmitter.emitFile.bind(this.fileEmitter),this.getFileName=this.fileEmitter.getFileName.bind(this.fileEmitter),this.finaliseAssets=this.fileEmitter.finaliseAssets.bind(this.fileEmitter),this.setChunkInformation=this.fileEmitter.setChunkInformation.bind(this.fileEmitter),this.setOutputBundle=this.fileEmitter.setOutputBundle.bind(this.fileEmitter),this.plugins=[...i?i.plugins:[],...r];const s=new Set;if(this.pluginContexts=new Map(this.plugins.map(_=>[_,ih(_,a,n,e,this.fileEmitter,s)])),i)for(const _ of r)for(const l of sh)l in _&&e.onLog(V,(o=_.name,{code:"INPUT_HOOK_IN_OUTPUT_PLUGIN",message:`The "${l}" hook used by the output plugin ${o} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`}));var o}createOutputPluginDriver(n){return new ls(this.graph,this.options,n,this.pluginCache,this)}getUnfulfilledHookActions(){return this.unfulfilledActions}hookFirst(n,e,r,a){return this.hookFirstAndGetPlugin(n,e,r,a).then(i=>i&&i[0])}async hookFirstAndGetPlugin(n,e,r,a){for(const i of this.getSortedPlugins(n)){if(a!=null&&a.has(i))continue;const s=await this.runHook(n,e,i,r);if(s!=null)return[s,i]}return null}hookFirstSync(n,e,r){for(const a of this.getSortedPlugins(n)){const i=this.runHookSync(n,e,a,r);if(i!=null)return i}return null}async hookParallel(n,e,r){const a=[];for(const i of this.getSortedPlugins(n))i[n].sequential?(await Promise.all(a),a.length=0,await this.runHook(n,e,i,r)):a.push(this.runHook(n,e,i,r));await Promise.all(a)}hookReduceArg0(n,[e,...r],a,i){let s=Promise.resolve(e);for(const o of this.getSortedPlugins(n))s=s.then(_=>this.runHook(n,[_,...r],o,i).then(l=>a.call(this.pluginContexts.get(o),_,l,o)));return s}hookReduceArg0Sync(n,[e,...r],a,i){for(const s of this.getSortedPlugins(n)){const o=[e,...r],_=this.runHookSync(n,o,s,i);e=a.call(this.pluginContexts.get(s),e,_,s)}return e}async hookReduceValue(n,e,r,a){const i=[],s=[];for(const o of this.getSortedPlugins(n,_h))o[n].sequential?(i.push(...await Promise.all(s)),s.length=0,i.push(await this.runHook(n,r,o))):s.push(this.runHook(n,r,o));return i.push(...await Promise.all(s)),i.reduce(a,await e)}hookReduceValueSync(n,e,r,a,i){let s=e;for(const o of this.getSortedPlugins(n)){const _=this.runHookSync(n,r,o,i);s=a.call(this.pluginContexts.get(o),s,_,o)}return s}hookSeq(n,e,r){let a=Promise.resolve();for(const i of this.getSortedPlugins(n))a=a.then(()=>this.runHook(n,e,i,r));return a.then(lh)}getSortedPlugins(n,e){return zn(this.sortedPlugins,n,()=>cs(n,this.plugins,e))}runHook(n,e,r,a){const i=r[n],s=typeof i=="object"?i.handler:i;let o=this.pluginContexts.get(r);a&&(o=a(o,r));let _=null;return Promise.resolve().then(()=>{if(typeof s!="function")return s;const l=s.apply(o,e);return l!=null&&l.then?(_=[r.name,n,e],this.unfulfilledActions.add(_),Promise.resolve(l).then(u=>(this.unfulfilledActions.delete(_),u))):l}).catch(l=>(_!==null&&this.unfulfilledActions.delete(_),L(Se(l,r.name,{hook:n}))))}runHookSync(n,e,r,a){const i=r[n],s=typeof i=="object"?i.handler:i;let o=this.pluginContexts.get(r);a&&(o=a(o,r));try{return s.apply(o,e)}catch(_){return L(Se(_,r.name,{hook:n}))}}}function cs(t,n,e=oh){const r=[],a=[],i=[];for(const s of n){const o=s[t];if(o){if(typeof o=="object"){if(e(o.handler,t,s),o.order==="pre"){r.push(s);continue}if(o.order==="post"){i.push(s);continue}}else e(o,t,s);a.push(s)}}return[...r,...a,...i]}function oh(t,n,e){typeof t!="function"&&L(function(r,a){return{code:Vs,hook:r,message:`Error running plugin hook "${r}" for plugin "${a}", expected a function hook or an object with a "handler" function.`,plugin:a}}(n,e.name))}function _h(t,n,e){if(typeof t!="string"&&typeof t!="function")return L(function(r,a){return{code:Vs,hook:r,message:`Error running plugin hook "${r}" for plugin "${a}", expected a string, a function hook or an object with a "handler" string or function.`,plugin:a}}(n,e.name))}function lh(){}class ch{constructor(n){this.maxParallel=n,this.queue=[],this.workerCount=0}run(n){return new Promise((e,r)=>{this.queue.push({reject:r,resolve:e,task:n}),this.work()})}async work(){if(this.workerCount>=this.maxParallel)return;let n;for(this.workerCount++;n=this.queue.shift();){const{reject:e,resolve:r,task:a}=n;try{r(await a())}catch(i){e(i)}}this.workerCount--}}class uh{constructor(n,e){var r,a;if(this.options=n,this.astLru=function(i){var s,o,_,l=i||1;function u(m,h){++s>l&&(_=o,f(1),++s),o[m]=h}function f(m){s=0,o=Object.create(null),m||(_=Object.create(null))}return f(),{clear:f,has:function(m){return o[m]!==void 0||_[m]!==void 0},get:function(m){var h=o[m];return h!==void 0?h:(h=_[m])!==void 0?(u(m,h),h):void 0},set:function(m,h){o[m]!==void 0?o[m]=h:u(m,h)}}}(5),this.cachedModules=new Map,this.deoptimizationTracker=new re,this.entryModules=[],this.modulesById=new Map,this.needsTreeshakingPass=!1,this.phase=St.LOAD_AND_PARSE,this.scope=new nh,this.watchFiles=Object.create(null),this.watchMode=!1,this.externalModules=[],this.implicitEntryModules=[],this.modules=[],this.getModuleInfo=i=>{const s=this.modulesById.get(i);return s?s.info:null},n.cache!==!1){if((r=n.cache)!=null&&r.modules)for(const i of n.cache.modules)this.cachedModules.set(i.id,i);this.pluginCache=((a=n.cache)==null?void 0:a.plugins)||Object.create(null);for(const i in this.pluginCache){const s=this.pluginCache[i];for(const o of Object.values(s))o[0]++}}if(e){this.watchMode=!0;const i=(...o)=>this.pluginDriver.hookParallel("watchChange",o),s=()=>this.pluginDriver.hookParallel("closeWatcher",[]);e.onCurrentRun("change",i),e.onCurrentRun("close",s)}this.pluginDriver=new ls(this,n,n.plugins,this.pluginCache),this.acornParser=pn.extend(...n.acornInjectPlugins),this.moduleLoader=new Qd(this,this.modulesById,this.options,this.pluginDriver),this.fileOperationQueue=new ch(n.maxParallelFileOps),this.pureFunctions=(({treeshake:i})=>{const s=Object.create(null);for(const o of i?i.manualPureFunctions:[]){let _=s;for(const l of o.split("."))_=_[l]||(_[l]=Object.create(null));_[si]=!0}return s})(n)}async build(){$n("generate module graph",2),await this.generateModuleGraph(),yn("generate module graph",2),$n("sort and bind modules",2),this.phase=St.ANALYSE,this.sortModules(),yn("sort and bind modules",2),$n("mark included statements",2),this.includeStatements(),yn("mark included statements",2),this.phase=St.GENERATE}contextParse(n,e={}){const r=e.onComment,a=[];e.onComment=r&&typeof r=="function"?(s,o,_,l,...u)=>(a.push({end:l,start:_,type:s?"Block":"Line",value:o}),r.call(e,s,o,_,l,...u)):a;const i=this.acornParser.parse(n,{...this.options.acorn,...e});return typeof r=="object"&&r.push(...a),e.onComment=r,function(s,o,_){const l=[],u=[];for(const f of s){for(const[m,h]of Km)h.test(f.value)&&l.push({...f,annotationType:m});Hm.test(f.value)&&u.push(f)}for(const f of u)Sr(o,f,!1);co(o,{annotationIndex:0,annotations:l,code:_})}(a,i,n),i}getCache(){for(const n in this.pluginCache){const e=this.pluginCache[n];let r=!0;for(const[a,i]of Object.entries(e))i[0]>=this.options.experimentalCacheExpiry?delete e[a]:r=!1;r&&delete this.pluginCache[n]}return{modules:this.modules.map(n=>n.toJSON()),plugins:this.pluginCache}}async generateModuleGraph(){var n;if({entryModules:this.entryModules,implicitEntryModules:this.implicitEntryModules}=await this.moduleLoader.addEntryModules((n=this.options.input,Array.isArray(n)?n.map(e=>({fileName:null,id:e,implicitlyLoadedAfter:[],importer:void 0,name:null})):Object.entries(n).map(([e,r])=>({fileName:null,id:r,implicitlyLoadedAfter:[],importer:void 0,name:e}))),!0),this.entryModules.length===0)throw new Error("You must supply options.input to rollup");for(const e of this.modulesById.values())e instanceof hn?this.modules.push(e):this.externalModules.push(e)}includeStatements(){const n=[...this.entryModules,...this.implicitEntryModules];for(const e of n)We(e);if(this.options.treeshake){let e=1;do{$n(`treeshaking pass ${e}`,3),this.needsTreeshakingPass=!1;for(const r of this.modules)r.isExecuted&&(r.info.moduleSideEffects==="no-treeshake"?r.includeAllInBundle():r.include());if(e===1)for(const r of n)r.preserveSignature!==!1&&(r.includeAllExports(!1),this.needsTreeshakingPass=!0);yn("treeshaking pass "+e++,3)}while(this.needsTreeshakingPass)}else for(const e of this.modules)e.includeAllInBundle();for(const e of this.externalModules)e.warnUnusedImports();for(const e of this.implicitEntryModules)for(const r of e.implicitlyLoadedAfter)r.info.isEntry||r.isIncluded()||L(Tm(r))}sortModules(){const{orderedModules:n,cyclePaths:e}=function(r){let a=0;const i=[],s=new Set,o=new Set,_=new Map,l=[],u=f=>{if(f instanceof hn){for(const m of f.dependencies)_.has(m)?s.has(m)||i.push(ed(m,f,_)):(_.set(m,f),u(m));for(const m of f.implicitlyLoadedBefore)o.add(m);for(const{resolution:m}of f.dynamicImports)m instanceof hn&&o.add(m);l.push(f)}f.execIndex=a++,s.add(f)};for(const f of r)_.has(f)||(_.set(f,null),u(f));for(const f of o)_.has(f)||(_.set(f,null),u(f));return{cyclePaths:i,orderedModules:l}}(this.entryModules);for(const r of e)this.options.onLog(V,Im(r));this.modules=n;for(const r of this.modules)r.bindReferences();this.warnForMissingExports()}warnForMissingExports(){for(const n of this.modules)for(const e of n.importDescriptions.values())e.name==="*"||e.module.getVariableForExportName(e.name)[0]||n.log(V,$r(e.name,n.id,e.module.id),e.start)}}function ql(t,n){return n()}function Vl(t,n,e,r){t=cs("onLog",t);const a=zt[r],i=(s,o,_=Ds)=>{if(!(zt[s]<a)){for(const l of t){if(_.has(l))continue;const{onLog:u}=l,f=m=>zt[m]<a?rt:h=>i(m,ct(h),new Set(_).add(l));if(("handler"in u?u.handler:u).call({debug:f(we),error:m=>L(ct(m)),info:f(Ot),meta:{rollupVersion:Na,watchMode:e},warn:f(V)},s,o)===!1)return}n(s,o)}};return i}const fh="{".charCodeAt(0),mh=" ".charCodeAt(0),Xl="assert";function ph(t){const n=t.acorn||qd,{tokTypes:e,TokenType:r}=n;return class extends t{constructor(...a){super(...a),this.assertToken=new r(Xl)}_codeAt(a){return this.input.charCodeAt(a)}_eat(a){this.type!==a&&this.unexpected(),this.next()}readToken(a){let i=0;for(;i<6;i++)if(this._codeAt(this.pos+i)!==Xl.charCodeAt(i))return super.readToken(a);for(;this._codeAt(this.pos+i)!==fh;i++)if(this._codeAt(this.pos+i)!==mh)return super.readToken(a);return this.type.label==="{"?super.readToken(a):(this.pos+=6,this.finishToken(this.assertToken))}parseDynamicImport(a){if(this.next(),a.source=this.parseMaybeAssign(),this.eat(e.comma)){const i=this.parseObj(!1);a.arguments=[i]}return this._eat(e.parenR),this.finishNode(a,"ImportExpression")}parseExport(a,i){if(this.next(),this.eat(e.star)){if(this.options.ecmaVersion>=11&&(this.eatContextual("as")?(a.exported=this.parseIdent(!0),this.checkExport(i,a.exported.name,this.lastTokStart)):a.exported=null),this.expectContextual("from"),this.type!==e.string&&this.unexpected(),a.source=this.parseExprAtom(),this.type===this.assertToken||this.type===e._with){this.next();const m=this.parseImportAssertions();m&&(a.assertions=m)}return this.semicolon(),this.finishNode(a,"ExportAllDeclaration")}if(this.eat(e._default)){var s;if(this.checkExport(i,"default",this.lastTokStart),this.type===e._function||(s=this.isAsyncFunction())){var o=this.startNode();this.next(),s&&this.next(),a.declaration=this.parseFunction(o,5,!1,s)}else if(this.type===e._class){var _=this.startNode();a.declaration=this.parseClass(_,"nullableID")}else a.declaration=this.parseMaybeAssign(),this.semicolon();return this.finishNode(a,"ExportDefaultDeclaration")}if(this.shouldParseExportStatement())a.declaration=this.parseStatement(null),a.declaration.type==="VariableDeclaration"?this.checkVariableExport(i,a.declaration.declarations):this.checkExport(i,a.declaration.id.name,a.declaration.id.start),a.specifiers=[],a.source=null;else{if(a.declaration=null,a.specifiers=this.parseExportSpecifiers(i),this.eatContextual("from")){if(this.type!==e.string&&this.unexpected(),a.source=this.parseExprAtom(),this.type===this.assertToken||this.type===e._with){this.next();const m=this.parseImportAssertions();m&&(a.assertions=m)}}else{for(var l=0,u=a.specifiers;l<u.length;l+=1){var f=u[l];this.checkUnreserved(f.local),this.checkLocalExport(f.local)}a.source=null}this.semicolon()}return this.finishNode(a,"ExportNamedDeclaration")}parseImport(a){if(this.next(),this.type===e.string?(a.specifiers=[],a.source=this.parseExprAtom()):(a.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),a.source=this.type===e.string?this.parseExprAtom():this.unexpected()),this.type===this.assertToken||this.type==e._with){this.next();const i=this.parseImportAssertions();i&&(a.assertions=i)}return this.semicolon(),this.finishNode(a,"ImportDeclaration")}parseImportAssertions(){this._eat(e.braceL);const a=this.parseAssertEntries();return this._eat(e.braceR),a}parseAssertEntries(){const a=[],i=new Set;do{if(this.type===e.braceR)break;const s=this.startNode();let o;o=this.type===e.string?this.parseLiteral(this.value):this.parseIdent(!0),this.next(),s.key=o,i.has(s.key.name)&&this.raise(this.pos,"Duplicated key in assertions"),i.add(s.key.name),this.type!==e.string&&this.raise(this.pos,"Only string is supported as an assertion value"),s.value=this.parseLiteral(this.value),a.push(this.finishNode(s,"ImportAttribute"))}while(this.eat(e.comma));return a}}}function Ul(t){return Array.isArray(t)?t.filter(Boolean):t?[t]:[]}const dh=t=>({ecmaVersion:"latest",sourceType:"module",...t.acorn}),hh=t=>[ph,...Ul(t.acornInjectPlugins)],gh=t=>{var n;return t.cache===!0?void 0:((n=t.cache)==null?void 0:n.cache)||t.cache},bh=t=>{if(t===!0)return()=>!0;if(typeof t=="function")return(n,...e)=>!n.startsWith("\0")&&t(n,...e)||!1;if(t){const n=new Set,e=[];for(const r of Ul(t))r instanceof RegExp?e.push(r):n.add(r);return(r,...a)=>n.has(r)||e.some(i=>i.test(r))}return()=>!1},vh=(t,n,e)=>{const r=t.inlineDynamicImports;return r&&Ae('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.',qa,!0,n,e),r},yh=t=>{const n=t.input;return n==null?[]:typeof n=="string"?[n]:n},xh=(t,n,e)=>{const r=t.manualChunks;return r&&Ae('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.',Xa,!0,n,e),r},$h=(t,n,e)=>{const r=t.maxParallelFileReads;typeof r=="number"&&Ae('The "maxParallelFileReads" option is deprecated. Use the "maxParallelFileOps" option instead.',"configuration-options/#maxparallelfileops",!0,n,e);const a=t.maxParallelFileOps??r;return typeof a=="number"?a<=0?1/0:a:20},Eh=(t,n)=>{const e=t.moduleContext;if(typeof e=="function")return r=>e(r)??n;if(e){const r=Object.create(null);for(const[a,i]of Object.entries(e))r[Jn(a)]=i;return a=>r[a]??n}return()=>n},kh=(t,n,e)=>{const r=t.preserveModules;return r&&Ae('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.',"configuration-options/#output-preservemodules",!0,n,e),r},wh=t=>{if(t.treeshake===!1)return!1;const n=Dl(t.treeshake,Kd,"treeshake","configuration-options/#treeshake","false, true, ");return{annotations:n.annotations!==!1,correctVarValueBeforeDeclaration:n.correctVarValueBeforeDeclaration===!0,manualPureFunctions:n.manualPureFunctions??bn,moduleSideEffects:Ch(n.moduleSideEffects),propertyReadSideEffects:n.propertyReadSideEffects==="always"?"always":n.propertyReadSideEffects!==!1,tryCatchDeoptimization:n.tryCatchDeoptimization!==!1,unknownGlobalSideEffects:n.unknownGlobalSideEffects!==!1}},Ch=t=>{if(typeof t=="boolean")return()=>t;if(t==="no-external")return(n,e)=>!e;if(typeof t=="function")return(n,e)=>!!n.startsWith("\0")||t(n,e)!==!1;if(Array.isArray(t)){const n=new Set(t);return e=>n.has(e)}return t&&L(vn("treeshake.moduleSideEffects","configuration-options/#treeshake-modulesideeffects",'please use one of false, "no-external", a function or an array')),()=>!0},Sh=/[\u0000-\u001F"#$&*+,:;<=>?[\]^`{|}\u007F]/g,Ah=/^[a-z]:/i;function Ih(t){const n=Ah.exec(t),e=n?n[0]:"";return e+t.slice(e.length).replace(Sh,"_")}const Nh=(t,n,e)=>{const{file:r}=t;if(typeof r=="string"){if(n)return L(vn("output.file",Ce,'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));if(!Array.isArray(e.input))return L(vn("output.file",Ce,'you must set "output.dir" instead of "output.file" when providing named inputs'))}return r},Th=t=>{const n=t.format;switch(n){case void 0:case"es":case"esm":case"module":return"es";case"cjs":case"commonjs":return"cjs";case"system":case"systemjs":return"system";case"amd":case"iife":case"umd":return n;default:return L(vn("output.format",Bs,'Valid values are "amd", "cjs", "system", "es", "iife" or "umd"',n))}},jh=(t,n)=>{const e=(t.inlineDynamicImports??n.inlineDynamicImports)||!1,{input:r}=n;return e&&(Array.isArray(r)?r:Object.keys(r)).length>1?L(vn("output.inlineDynamicImports",qa,'multiple inputs are not supported when "output.inlineDynamicImports" is true')):e},Lh=(t,n,e)=>{const r=(t.preserveModules??e.preserveModules)||!1;if(r){if(n)return L(vn("output.inlineDynamicImports",qa,'this option is not supported for "output.preserveModules"'));if(e.preserveEntrySignatures===!1)return L(vn("preserveEntrySignatures","configuration-options/#preserveentrysignatures",'setting this option to false is not supported for "output.preserveModules"'))}return r},Mh=(t,n)=>{const e=t.preferConst;return e!=null&&Ft('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.',"configuration-options/#output-generatedcode-constbindings",!0,n),!!e},Dh=t=>{const{preserveModulesRoot:n}=t;if(n!=null)return Jn(n)},Ph=t=>{const n={autoId:!1,basePath:"",define:"define",forceJsExtensionForImports:!1,...t.amd};return(n.autoId||n.basePath)&&n.id?L(vn("output.amd.id",Fs,'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"')):n.basePath&&!n.autoId?L(vn("output.amd.basePath","configuration-options/#output-amd-basepath",'this option only works with "output.amd.autoId"')):n.autoId?{autoId:!0,basePath:n.basePath,define:n.define,forceJsExtensionForImports:n.forceJsExtensionForImports}:{autoId:!1,define:n.define,forceJsExtensionForImports:n.forceJsExtensionForImports,id:n.id}},fa=(t,n)=>{const e=t[n];return typeof e=="function"?e:()=>e||""},Oh=(t,n)=>{const{dir:e}=t;return typeof e=="string"&&typeof n=="string"?L(vn("output.dir",Ce,'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')):e},zh=(t,n,e)=>{const r=t.dynamicImportFunction;return r&&(Ft('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.',"plugin-development/#renderdynamicimport",!0,n),e!=="es"&&n.onLog(V,vn("output.dynamicImportFunction","configuration-options/#output-dynamicimportfunction",'this option is ignored for formats other than "es"'))),r},Fh=(t,n)=>{const e=t.entryFileNames;return e==null&&n.add("entryFileNames"),e??"[name].js"};function Bh(t,n){const e=t.experimentalDeepDynamicChunkOptimization;return e!=null&&Ft('The "output.experimentalDeepDynamicChunkOptimization" option is deprecated as Rollup always runs the full chunking algorithm now. The option should be removed.',nm,!0,n),e||!1}function Gh(t,n){const e=t.exports;if(e==null)n.add("exports");else if(!["default","named","none","auto"].includes(e))return L({code:qs,message:`"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${e}".`,url:wn(Ra)});return e||"auto"}const Rh=(t,n)=>{const e=Dl(t.generatedCode,Yd,"output.generatedCode","configuration-options/#output-generatedcode","");return{arrowFunctions:e.arrowFunctions===!0,constBindings:e.constBindings===!0||n,objectShorthand:e.objectShorthand===!0,reservedNamesAsProps:e.reservedNamesAsProps!==!1,symbols:e.symbols===!0}},qh=(t,n)=>{if(n)return"";const e=t.indent;return e===!1?"":e??!0},Hl=new Set(["compat","auto","esModule","default","defaultOnly"]),Vh=t=>{const n=t.interop;if(typeof n=="function"){const e=Object.create(null);let r=null;return a=>a===null?r||us(r=n(a)):a in e?e[a]:us(e[a]=n(a))}return n===void 0?()=>"default":()=>us(n)},us=t=>Hl.has(t)?t:L(vn("output.interop",Va,`use one of ${Array.from(Hl,n=>JSON.stringify(n)).join(", ")}`,t)),Xh=(t,n,e,r)=>{const a=t.manualChunks||r.manualChunks;if(a){if(n)return L(vn("output.manualChunks",Xa,'this option is not supported for "output.inlineDynamicImports"'));if(e)return L(vn("output.manualChunks",Xa,'this option is not supported for "output.preserveModules"'))}return a||{}},Uh=(t,n,e)=>t.minifyInternalExports??(e||n==="es"||n==="system"),Hh=(t,n,e)=>{const r=t.namespaceToStringTag;return r!=null?(Ft('The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.',"configuration-options/#output-generatedcode-symbols",!0,e),r):n.symbols||!1},Wh=t=>{const{sourcemapBaseUrl:n}=t;if(n)return function(r){try{new URL(r)}catch{return!1}return!0}(n)?(e=n).endsWith("/")?e:e+"/":L(vn("output.sourcemapBaseUrl","configuration-options/#output-sourcemapbaseurl",`must be a valid URL, received ${JSON.stringify(n)}`));var e};function Jh(t){return async function(n,e){const{options:r,unsetOptions:a}=await async function(_,l){if(!_)throw new Error("You must supply an options object to rollup");const u=await async function(h,v){const d=cs("options",await ua(h.plugins)),g=h.logLevel||Ot,y=Vl(d,Tl(h,g),v,g);for(const E of d){const{name:b,options:x}=E,$="handler"in x?x.handler:x,S=await $.call({debug:de(we,"PLUGIN_LOG",y,b,g),error:A=>L(Se(ct(A),b,{hook:"onLog"})),info:de(Ot,"PLUGIN_LOG",y,b,g),meta:{rollupVersion:Na,watchMode:v},warn:de(V,"PLUGIN_WARNING",y,b,g)},h);S&&(h=S)}return h}(_,l),{options:f,unsetOptions:m}=await async function(h,v){const d=new Set,g=h.context??"undefined",y=await ua(h.plugins),E=h.logLevel||Ot,b=Vl(y,Tl(h,E),v,E),x=h.strictDeprecations||!1,$=$h(h,b,x),S={acorn:dh(h),acornInjectPlugins:hh(h),cache:gh(h),context:g,experimentalCacheExpiry:h.experimentalCacheExpiry??10,experimentalLogSideEffects:h.experimentalLogSideEffects||!1,external:bh(h.external),inlineDynamicImports:vh(h,b,x),input:yh(h),logLevel:E,makeAbsoluteExternalsRelative:h.makeAbsoluteExternalsRelative??"ifRelativeSource",manualChunks:xh(h,b,x),maxParallelFileOps:$,maxParallelFileReads:$,moduleContext:Eh(h,g),onLog:b,onwarn:A=>b(V,A),perf:h.perf||!1,plugins:y,preserveEntrySignatures:h.preserveEntrySignatures??"exports-only",preserveModules:kh(h,b,x),preserveSymlinks:h.preserveSymlinks||!1,shimMissingExports:h.shimMissingExports||!1,strictDeprecations:x,treeshake:wh(h)};return Ml(h,[...Object.keys(S),"watch"],"input options",b,/^(output)$/),{options:S,unsetOptions:d}}(u,l);return Wl(f.plugins,is),{options:f,unsetOptions:m}}(n,e!==null);(function(_){_.perf?(He=new Map,$n=Ep,yn=kp,_.plugins=_.plugins.map(Sp)):($n=rt,yn=rt)})(r);const i=new uh(r,e),s=n.cache!==!1;n.cache&&(r.cache=void 0,n.cache=void 0),$n("BUILD",1),await ql(i.pluginDriver,async()=>{try{$n("initialize",2),await i.pluginDriver.hookParallel("buildStart",[r]),yn("initialize",2),await i.build()}catch(_){const l=Object.keys(i.watchFiles);throw l.length>0&&(_.watchFiles=l),await i.pluginDriver.hookParallel("buildEnd",[_]),await i.pluginDriver.hookParallel("closeBundle",[]),_}await i.pluginDriver.hookParallel("buildEnd",[])}),yn("BUILD",1);const o={cache:s?i.getCache():void 0,async close(){o.closed||(o.closed=!0,await i.pluginDriver.hookParallel("closeBundle",[]))},closed:!1,generate:async _=>o.closed?L(Ys()):Jl(!1,r,a,_,i),watchFiles:Object.keys(i.watchFiles),write:async _=>o.closed?L(Ys()):Jl(!0,r,a,_,i)};return r.perf&&(o.getTimings=wp),o}(t,null)}function Wl(t,n){for(const[e,r]of t.entries())r.name||(r.name=`${n}${e+1}`)}async function Jl(t,n,e,r,a){const{options:i,outputPluginDriver:s,unsetOptions:o}=await async function(_,l,u,f){if(!_)throw new Error("You must supply an options object");const m=await ua(_.plugins);Wl(m,ss);const h=l.createOutputPluginDriver(m);return{...await Kh(u,f,_,h),outputPluginDriver:h}}(r,a.pluginDriver,n,e);return ql(0,async()=>{const _=new Ed(i,o,n,s,a),l=await _.generate(t);if(t){if($n("WRITE",1),!i.dir&&!i.file)return L({code:xm,message:'You must specify "output.file" or "output.dir" for the build.',url:wn(Ce)});await Promise.all(Object.values(l).map(f=>a.fileOperationQueue.run(()=>async function(m,h){const v=Jn(h.dir||Mt(h.file),m.fileName);return await Vd(Mt(v),{recursive:!0}),Ud(v,m.type==="asset"?m.source:m.code)}(f,i)))),await s.hookParallel("writeBundle",[i,l]),yn("WRITE",1)}return u=l,{output:Object.values(u).filter(f=>Object.keys(f).length>0).sort((f,m)=>Kl(f)-Kl(m))};var u})}function Kh(t,n,e,r){return async function(a,i,s){const o=new Set(s),_=a.compact||!1,l=Th(a),u=jh(a,i),f=Lh(a,u,i),m=Nh(a,f,i),h=Mh(a,i),v=Rh(a,h),d={amd:Ph(a),assetFileNames:a.assetFileNames??"assets/[name]-[hash][extname]",banner:fa(a,"banner"),chunkFileNames:a.chunkFileNames??"[name]-[hash].js",compact:_,dir:Oh(a,m),dynamicImportFunction:zh(a,i,l),dynamicImportInCjs:a.dynamicImportInCjs??!0,entryFileNames:Fh(a,o),esModule:a.esModule??"if-default-prop",experimentalDeepDynamicChunkOptimization:Bh(a,i),experimentalMinChunkSize:a.experimentalMinChunkSize??1,exports:Gh(a,o),extend:a.extend||!1,externalImportAssertions:a.externalImportAssertions??!0,externalLiveBindings:a.externalLiveBindings??!0,file:m,footer:fa(a,"footer"),format:l,freeze:a.freeze??!0,generatedCode:v,globals:a.globals||{},hoistTransitiveImports:a.hoistTransitiveImports??!0,indent:qh(a,_),inlineDynamicImports:u,interop:Vh(a),intro:fa(a,"intro"),manualChunks:Xh(a,u,f,i),minifyInternalExports:Uh(a,l,_),name:a.name,namespaceToStringTag:Hh(a,v,i),noConflict:a.noConflict||!1,outro:fa(a,"outro"),paths:a.paths||{},plugins:await ua(a.plugins),preferConst:h,preserveModules:f,preserveModulesRoot:Dh(a),sanitizeFileName:typeof a.sanitizeFileName=="function"?a.sanitizeFileName:a.sanitizeFileName===!1?g=>g:Ih,sourcemap:a.sourcemap||!1,sourcemapBaseUrl:Wh(a),sourcemapExcludeSources:a.sourcemapExcludeSources||!1,sourcemapFile:a.sourcemapFile,sourcemapIgnoreList:typeof a.sourcemapIgnoreList=="function"?a.sourcemapIgnoreList:a.sourcemapIgnoreList===!1?()=>!1:g=>g.includes("node_modules"),sourcemapPathTransform:a.sourcemapPathTransform,strict:a.strict??!0,systemNullSetters:a.systemNullSetters??!0,validate:a.validate||!1};return Ml(a,Object.keys(d),"output options",i.onLog),{options:d,unsetOptions:o}}(r.hookReduceArg0Sync("outputOptions",[e],(a,i)=>i||a,a=>{const i=()=>a.error({code:om,message:'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.'});return{...a,emitFile:i,setAssetSource:i}}),t,n)}var er;function Kl(t){return t.type==="asset"?er.ASSET:t.isEntry?er.ENTRY_CHUNK:er.SECONDARY_CHUNK}(function(t){t[t.ENTRY_CHUNK=0]="ENTRY_CHUNK",t[t.SECONDARY_CHUNK=1]="SECONDARY_CHUNK",t[t.ASSET=2]="ASSET"})(er||(er={}));const Yl=["log","warn","info","debug","error"];console.original={};let ma=[],pa=!1,Yh=(t,n)=>{const e=n.map(r=>typeof r=="object"?r instanceof Error?JSON.stringify(r,Object.getOwnPropertyNames(r)):JSON.stringify(r):r);ma.push({kind:t,args:e,date:Date.now()})},Zh=(t=!1)=>{const n={apply:(e,r,a)=>{if(Yh(e.name,a),e.bind(r),t)return e(...a)}};Yl.forEach(e=>{pa||(console.original[e]=console[e]),console[e]=new Proxy(console[e],n)}),pa=!0},Qh=()=>{pa&&Yl.forEach(t=>{console[t]=console.original[t]}),pa=!1},n1=(t=!1)=>{ma=[],Zh(t)},t1=()=>{Qh()},Zl=()=>{ma=[]},e1=()=>ma,r1=t=>t.map(n=>n.args.join(" "));const rr={},Ql=Object.assign({"../../_build/default/playground/output/node_modules/melange.js/caml.js":ec,"../../_build/default/playground/output/node_modules/melange.js/caml_array.js":rc,"../../_build/default/playground/output/node_modules/melange.js/caml_array_extern.js":ac,"../../_build/default/playground/output/node_modules/melange.js/caml_bytes.js":ic,"../../_build/default/playground/output/node_modules/melange.js/caml_exceptions.js":sc,"../../_build/default/playground/output/node_modules/melange.js/caml_external_polyfill.js":oc,"../../_build/default/playground/output/node_modules/melange.js/caml_float.js":_c,"../../_build/default/playground/output/node_modules/melange.js/caml_float_extern.js":lc,"../../_build/default/playground/output/node_modules/melange.js/caml_format.js":cc,"../../_build/default/playground/output/node_modules/melange.js/caml_gc.js":uc,"../../_build/default/playground/output/node_modules/melange.js/caml_hash.js":fc,"../../_build/default/playground/output/node_modules/melange.js/caml_hash_primitive.js":mc,"../../_build/default/playground/output/node_modules/melange.js/caml_int32.js":pc,"../../_build/default/playground/output/node_modules/melange.js/caml_int32_extern.js":dc,"../../_build/default/playground/output/node_modules/melange.js/caml_int64.js":hc,"../../_build/default/playground/output/node_modules/melange.js/caml_int64_extern.js":gc,"../../_build/default/playground/output/node_modules/melange.js/caml_io.js":bc,"../../_build/default/playground/output/node_modules/melange.js/caml_js_exceptions.js":vc,"../../_build/default/playground/output/node_modules/melange.js/caml_lexer.js":yc,"../../_build/default/playground/output/node_modules/melange.js/caml_md5.js":xc,"../../_build/default/playground/output/node_modules/melange.js/caml_module.js":$c,"../../_build/default/playground/output/node_modules/melange.js/caml_nativeint_extern.js":Ec,"../../_build/default/playground/output/node_modules/melange.js/caml_obj.js":kc,"../../_build/default/playground/output/node_modules/melange.js/caml_oo.js":wc,"../../_build/default/playground/output/node_modules/melange.js/caml_oo_curry.js":Cc,"../../_build/default/playground/output/node_modules/melange.js/caml_option.js":Sc,"../../_build/default/playground/output/node_modules/melange.js/caml_parser.js":Ac,"../../_build/default/playground/output/node_modules/melange.js/caml_splice_call.js":Ic,"../../_build/default/playground/output/node_modules/melange.js/caml_string.js":Nc,"../../_build/default/playground/output/node_modules/melange.js/caml_string_extern.js":Tc,"../../_build/default/playground/output/node_modules/melange.js/caml_sys.js":jc,"../../_build/default/playground/output/node_modules/melange.js/caml_undefined_extern.js":Lc,"../../_build/default/playground/output/node_modules/melange.js/curry.js":Mc,"../../_build/default/playground/output/node_modules/melange.js/js.js":Dc,"../../_build/default/playground/output/node_modules/melange.js/js_OO.js":Pc,"../../_build/default/playground/output/node_modules/melange.js/js__.js":Oc,"../../_build/default/playground/output/node_modules/melange.js/js_array.js":zc,"../../_build/default/playground/output/node_modules/melange.js/js_array2.js":Fc,"../../_build/default/playground/output/node_modules/melange.js/js_bigint.js":Bc,"../../_build/default/playground/output/node_modules/melange.js/js_console.js":Gc,"../../_build/default/playground/output/node_modules/melange.js/js_date.js":Rc,"../../_build/default/playground/output/node_modules/melange.js/js_dict.js":qc,"../../_build/default/playground/output/node_modules/melange.js/js_exn.js":Vc,"../../_build/default/playground/output/node_modules/melange.js/js_float.js":Xc,"../../_build/default/playground/output/node_modules/melange.js/js_global.js":Uc,"../../_build/default/playground/output/node_modules/melange.js/js_int.js":Hc,"../../_build/default/playground/output/node_modules/melange.js/js_internal.js":Wc,"../../_build/default/playground/output/node_modules/melange.js/js_json.js":Jc,"../../_build/default/playground/output/node_modules/melange.js/js_map.js":Kc,"../../_build/default/playground/output/node_modules/melange.js/js_mapperRt.js":Yc,"../../_build/default/playground/output/node_modules/melange.js/js_math.js":Zc,"../../_build/default/playground/output/node_modules/melange.js/js_null.js":Qc,"../../_build/default/playground/output/node_modules/melange.js/js_null_undefined.js":nu,"../../_build/default/playground/output/node_modules/melange.js/js_promise.js":tu,"../../_build/default/playground/output/node_modules/melange.js/js_re.js":eu,"../../_build/default/playground/output/node_modules/melange.js/js_set.js":ru,"../../_build/default/playground/output/node_modules/melange.js/js_string.js":au,"../../_build/default/playground/output/node_modules/melange.js/js_string2.js":iu,"../../_build/default/playground/output/node_modules/melange.js/js_typed_array.js":su,"../../_build/default/playground/output/node_modules/melange.js/js_typed_array2.js":ou,"../../_build/default/playground/output/node_modules/melange.js/js_types.js":_u,"../../_build/default/playground/output/node_modules/melange.js/js_undefined.js":lu,"../../_build/default/playground/output/node_modules/melange.js/js_vector.js":cu,"../../_build/default/playground/output/node_modules/melange.js/js_weakmap.js":uu,"../../_build/default/playground/output/node_modules/melange.js/js_weakset.js":fu,"../../_build/default/playground/output/node_modules/melange.js/melange_mini_stdlib.js":mu,"../../_build/default/playground/output/node_modules/melange/arg.js":pu,"../../_build/default/playground/output/node_modules/melange/array.js":du,"../../_build/default/playground/output/node_modules/melange/arrayLabels.js":hu,"../../_build/default/playground/output/node_modules/melange/atomic.js":gu,"../../_build/default/playground/output/node_modules/melange/bool.js":bu,"../../_build/default/playground/output/node_modules/melange/buffer.js":vu,"../../_build/default/playground/output/node_modules/melange/bytes.js":yu,"../../_build/default/playground/output/node_modules/melange/bytesLabels.js":xu,"../../_build/default/playground/output/node_modules/melange/callback.js":$u,"../../_build/default/playground/output/node_modules/melange/camlinternalAtomic.js":Eu,"../../_build/default/playground/output/node_modules/melange/camlinternalFormat.js":ku,"../../_build/default/playground/output/node_modules/melange/camlinternalFormatBasics.js":wu,"../../_build/default/playground/output/node_modules/melange/camlinternalLazy.js":Cu,"../../_build/default/playground/output/node_modules/melange/camlinternalMod.js":Su,"../../_build/default/playground/output/node_modules/melange/camlinternalOO.js":Au,"../../_build/default/playground/output/node_modules/melange/char.js":Iu,"../../_build/default/playground/output/node_modules/melange/complex.js":Nu,"../../_build/default/playground/output/node_modules/melange/digest.js":Tu,"../../_build/default/playground/output/node_modules/melange/domain.js":ju,"../../_build/default/playground/output/node_modules/melange/either.js":Lu,"../../_build/default/playground/output/node_modules/melange/ephemeron.js":Mu,"../../_build/default/playground/output/node_modules/melange/filename.js":Du,"../../_build/default/playground/output/node_modules/melange/float.js":Pu,"../../_build/default/playground/output/node_modules/melange/format.js":Ou,"../../_build/default/playground/output/node_modules/melange/fun.js":zu,"../../_build/default/playground/output/node_modules/melange/gc.js":Fu,"../../_build/default/playground/output/node_modules/melange/hashtbl.js":Bu,"../../_build/default/playground/output/node_modules/melange/in_channel.js":Gu,"../../_build/default/playground/output/node_modules/melange/int.js":Ru,"../../_build/default/playground/output/node_modules/melange/int32.js":qu,"../../_build/default/playground/output/node_modules/melange/int64.js":Vu,"../../_build/default/playground/output/node_modules/melange/lazy.js":Xu,"../../_build/default/playground/output/node_modules/melange/lexing.js":Uu,"../../_build/default/playground/output/node_modules/melange/list.js":Hu,"../../_build/default/playground/output/node_modules/melange/listLabels.js":Wu,"../../_build/default/playground/output/node_modules/melange/map.js":Ju,"../../_build/default/playground/output/node_modules/melange/marshal.js":Ku,"../../_build/default/playground/output/node_modules/melange/moreLabels.js":Yu,"../../_build/default/playground/output/node_modules/melange/mutex.js":Zu,"../../_build/default/playground/output/node_modules/melange/obj.js":Qu,"../../_build/default/playground/output/node_modules/melange/oo.js":nf,"../../_build/default/playground/output/node_modules/melange/option.js":tf,"../../_build/default/playground/output/node_modules/melange/out_channel.js":ef,"../../_build/default/playground/output/node_modules/melange/parsing.js":rf,"../../_build/default/playground/output/node_modules/melange/printexc.js":af,"../../_build/default/playground/output/node_modules/melange/printf.js":sf,"../../_build/default/playground/output/node_modules/melange/queue.js":of,"../../_build/default/playground/output/node_modules/melange/random.js":_f,"../../_build/default/playground/output/node_modules/melange/result.js":lf,"../../_build/default/playground/output/node_modules/melange/scanf.js":cf,"../../_build/default/playground/output/node_modules/melange/seq.js":uf,"../../_build/default/playground/output/node_modules/melange/set.js":ff,"../../_build/default/playground/output/node_modules/melange/stack.js":mf,"../../_build/default/playground/output/node_modules/melange/stdLabels.js":pf,"../../_build/default/playground/output/node_modules/melange/std_exit.js":df,"../../_build/default/playground/output/node_modules/melange/stdlib.js":hf,"../../_build/default/playground/output/node_modules/melange/string.js":gf,"../../_build/default/playground/output/node_modules/melange/stringLabels.js":bf,"../../_build/default/playground/output/node_modules/melange/sys.js":vf,"../../_build/default/playground/output/node_modules/melange/type.js":yf,"../../_build/default/playground/output/node_modules/melange/uchar.js":xf,"../../_build/default/playground/output/node_modules/melange/unit.js":$f,"../../_build/default/playground/output/node_modules/melange/weak.js":Ef});Object.keys(Ql).forEach(t=>{const n=Ql[t];rr[t.replace("../../_build/default/playground/output/node_modules/","")]=n});const a1=eval,da=new Map;async function i1(t){if(da.has(t))return da.get(t);const n=fetch(t).then(async e=>{if(!e.ok)throw new Error(await e.text());return{url:e.url,body:await e.text()}}).catch(e=>{throw da.delete(t),e});return da.set(t,n),n}Pf("bundle",async(t,n)=>{switch(n.type){case"clear.logs":Zl(),t.logs=[];break;case"bundle":const e=n.code;if(!e)return;n1(),Zl(),rr["main.js"]=e;const r=await Jh({input:"main.js",plugins:[{name:"loader",resolveId(i,s){var o=i;return i.substring(0,2)=="./"&&s&&(o=s.substring(0,s.lastIndexOf("/")+1)+o.substring(2,i.length)),rr.hasOwnProperty(o)?o:i[0]=="/"?"https://esm.sh"+i:i.substring(0,8)!="https://"?"https://esm.sh/"+i:i},async load(i){if(rr.hasOwnProperty(i))return rr[i];{const s=await i1(i);return s==null?void 0:s.body}}}]}),{output:a}=await r.generate({format:"iife",name:"MelangeApp"});try{const i="import * as React";e.indexOf(i)>=0?t.bundledCode=a[0].code:(t.bundledCode=void 0,a1(a[0].code))}catch(i){console.log(i)}t.logs=r1(e1()),t1();break;default:throw new Error}})})();
